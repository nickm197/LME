<?xml version="1.0" encoding="UTF-8"?>

<text>
 <s id="1">Ada is a programming language designed in accordance with requirements defined by the United States Department of Defense: the so-called Steelman requirements.</s>
 <s id="2">Overall, these requirements call for a language with considerable expressive power covering a wide application domain.</s>
 <s id="3">As a result, the language includes facilities offered by classical languages such as Pascal as well as facilities often found only in specialized languages.</s>
 <s id="4">Thus the language is a modern algorithmic language with the usual control structures, and with the ability to define types and subprograms.</s>
 <s id="5">It also serves the need for modularity, whereby data, types, and subprograms can be packaged.</s>
 <s id="6">It treats modularity in the physical sense as well, with a facility to support separate compilation.</s>
 <s id="7">In addition to these aspects, the language covers real-time programming, with facilities to model parallel tasks and to handle exceptions.</s>
 <s id="8">It also covers systems programming;</s>
 <s id="9">this requires precise control over the representation of data and access to system-dependent properties.</s>
 <s id="10">Finally, both application-level and machine-level input-output are defined.</s>
 <s id="11">This standard specifies the form and meaning of program units written in Ada.</s>
 <s id="12">Its purpose is to promote the portability of Ada programs to a variety of data processing systems.</s>
 <s id="13">This standard specifies:</s>
 <s id="14">The form of a program unit written in Ada.</s>
 <s id="15">The effect of translating and executing such a program unit.</s>
 <s id="16">The manner in which program units may be combined to form Ada programs.</s>
 <s id="17">The predefined program units that a conforming implementation must supply.</s>
 <s id="18">The permissible variations within the standard, and the manner in which they must be specified.</s>
 <s id="19">Those violations of the standard that a conforming implementation is required to detect, and the effect of attempting to translate or execute a program unit containing such violations.</s>
 <s id="20">Those violations of the standard that a conforming implementation is not required to detect.</s>
 <s id="21">This standard does not specify:</s>
 <s id="22">The means whereby a program unit written in Ada is transformed into object code executable by a processor.</s>
 <s id="23">The means whereby translation or execution of program units is invoked and the executing units are controlled.</s>
 <s id="24">The size or speed of the object code, or the relative execution speed of different language constructs.</s>
 <s id="25">The form or contents of any listings produced by implementations; in particular, the form or contents of error or warning messages.</s>
 <s id="26">The effect of executing a program unit that contains any violation that a conforming implementation is not required to detect.</s>
 <s id="27">The size of a program or program unit that will exceed the capacity of a particular conforming implementation.</s>
 <s id="28">Where this standard specifies that a program unit written in Ada has an exact effect, this effect is the operational meaning of the program unit and must be produced by all conforming implementations.</s>
 <s id="29">Where this standard specifies permissible variations in the effects of constituents of a program unit written in Ada, the operational meaning of the program unit as a whole is understood to be the range of possible effects that result from all these variations, and a conforming implementation is allowed to produce any of these possible effects.</s>
 <s id="30">Examples of permissible variations are:</s>
 <s id="31">The represented values of fixed or floating numeric quantities, and the results of operations upon them.</s>
 <s id="32">The order of execution of statements in different parallel tasks, in the absence of explicit synchronization.</s>
 <s id="33">A conforming implementation is one that:</s>
 <s id="34">Correctly translates and executes legal program units written in Ada, provided that they are not so large as to exceed the capacity of the implementation.</s>
 <s id="35">Rejects all program units that are so large as to exceed the capacity of the implementation.</s>
 <s id="36">Rejects all program units that contain errors whose detection is required by the standard.</s>
 <s id="37">Supplies all predefined program units required by the standard.</s>
 <s id="38">Contains no variations except where the standard permits.</s>
 <s id="39">Specifies all such permitted variations in the manner prescribed by the standard.</s>
 <s id="40">This reference manual contains fourteen chapters, three annexes, three appendices, and an index.</s>
 <s id="41">Each chapter is divided into sections that have a common structure.</s>
 <s id="42">Each section introduces its subject, gives any necessary syntax rules, and describes the semantics of the corresponding language constructs.</s>
 <s id="43">Examples and notes, and then references, may appear at the end of a section.</s>
 <s id="44">Examples are meant to illustrate the possible forms of the constructs described.</s>
 <s id="45">Notes are meant to emphasize consequences of the rules described in the section or elsewhere.</s>
 <s id="46">References are meant to attract the attention of readers to a term or phrase having a technical meaning defined in another section.</s>
 <s id="47">The standard definition of the Ada programming language consists of the fourteen chapters and the three annexes, subject to the following restriction: the material in each of the items listed below is informative, and not part of the standard definition of the Ada programming language:</s>
 <s id="48">Section 1.3 Design goals and sources</s>
 <s id="49">Section 1.4 Language summary</s>
 <s id="50">The examples, notes, and references given at the end of each section</s>
 <s id="51">Each section whose title starts with the word "Example" or "Examples"</s>
 <s id="52">Ada was designed with three overriding concerns: program reliability and maintenance, programming as a human activity, and efficiency.</s>
 <s id="53">The need for languages that promote reliability and simplify maintenance is well established.</s>
 <s id="54">Hence emphasis was placed on program readability over ease of writing.</s>
 <s id="55">For example, the rules of the language require that program variables be explicitly declared and that their type be specified.</s>
 <s id="56">Since the type of a variable is invariant, compilers can ensure that operations on variables are compatible with the properties intended for objects of the type.</s>
 <s id="57">Furthermore, error-prone notations have been avoided, and the syntax of the language avoids the use of encoded forms in favor of more English-like constructs.</s>
 <s id="58">Finally, the language offers support for separate compilation of program units in a way that facilitates program development and maintenance, and which provides the same degree of checking between units as within a unit.</s>
 <s id="59">Concern for the human programmer was also stressed during the design.</s>
 <s id="60">Above all, an attempt was made to keep the language as small as possible, given the ambitious nature of the application domain.</s>
 <s id="61">We have attempted to cover this domain with a small number of underlying concepts integrated in a consistent and systematic way.</s>
 <s id="62">Nevertheless we have tried to avoid the pitfalls of excessive involution, and in the constant search for simpler designs we have tried to provide language constructs that correspond intuitively to what the users will normally expect.</s>
 <s id="63">Like many other human activities, the development of programs is becoming ever more decentralized and distributed.</s>
 <s id="64">Consequently, the ability to assemble a program from independently produced software components has been a central idea in this design.</s>
 <s id="65">The concepts of packages, of private types, and of generic units are directly related to this idea, which has ramifications in many other aspects of the language.</s>
 <s id="66">No language can avoid the problem of efficiency.</s>
 <s id="67">Languages that require over-elaborate compilers, or that lead to the inefficient use of storage or execution time, force these inefficiencies on all machines and on all programs.</s>
 <s id="68">Every construct of the language was examined in the light of present implementation techniques.</s>
 <s id="69">Any proposed construct whose implementation was unclear or that required excessive machine resources was rejected.</s>
 <s id="70">None of the above design goals was considered as achievable after the fact.</s>
 <s id="71">The design goals drove the entire design process from the beginning.</s>
 <s id="72">A perpetual difficulty in language design is that one must both identify the capabilities required by the application domain and design language features that provide these capabilities.</s>
 <s id="73">The difficulty existed in this design, although to a lesser degree than usual because of the Steelman requirements.</s>
 <s id="74">These requirements often simplified the design process by allowing it to concentrate on the design of a given system providing a well defined set of capabilities, rather than on the definition of the capabilities themselves.</s>
 <s id="75">Another significant simplification of the design work resulted from earlier experience acquired by several successful Pascal derivatives developed with similar goals.</s>
 <s id="76">These are the languages Euclid, Lis, Mesa, Modula, and Sue.</s>
 <s id="77">Many of the key ideas and syntactic forms developed in these languages have counterparts in Ada.</s>
 <s id="78">Several existing languages such as Algol 68 and Simula, and also recent research languages such as Alphard and Clu, influenced this language in several respects, although to a lesser degree than did the Pascal family.</s>
 <s id="79">Finally, the evaluation reports received on an earlier formulation (the Green language), and on alternative proposals (the Red, Blue, and Yellow languages), the language reviews that took place at different stages of this project, and the thousands of comments received from fifteen different countries during the preliminary stages of the Ada design and during the ANSI canvass, all had a significant impact on the standard definition of the language.</s>
 <s id="80">An Ada program is composed of one or more program units.</s>
 <s id="81">These program units can be compiled separately.</s>
 <s id="82">Program units may be subprograms (which define executable algorithms), package units (which define collections of entities), task units (which define parallel computations), or generic units (which define parameterized forms of packages and subprograms).</s>
 <s id="83">Each unit normally consists of two parts: a specification, containing the information that must be visible to other units, and a body, containing the implementation details, which need not be visible to other units.</s>
 <s id="84">This distinction of the specification and body, and the ability to compile units separately, allows a program to be designed, written, and tested as a set of largely independent software components.</s>
 <s id="85">An Ada program will normally make use of a library of program units of general utility.</s>
 <s id="86">The language provides means whereby individual organizations can construct their own libraries.</s>
 <s id="87">The text of a separately compiled program unit must name the library units it requires.</s>
 <s id="88">Program Units</s>
 <s id="89">A subprogram is the basic unit for expressing an algorithm.</s>
 <s id="90">There are two kinds of subprograms: procedures and functions.</s>
 <s id="91">A procedure is the means of invoking a series of actions.</s>
 <s id="92">For example, it may read data, update variables, or produce some output.</s>
 <s id="93">It may have parameters, to provide a controlled means of passing information between the procedure and the point of call.</s>
 <s id="94">A function is the means of invoking the computation of a value.</s>
 <s id="95">It is similar to a procedure, but in addition will return a result.</s>
 <s id="96">A package is the basic unit for defining a collection of logically related entities.</s>
 <s id="97">For example, a package can be used to define a common pool of data and types, a collection of related subprograms, or a set of type declarations and associated operations.</s>
 <s id="98">Portions of a package can be hidden from the user, thus allowing access only to the logical properties expressed by the package specification.</s>
 <s id="99">A task unit is the basic unit for defining a task whose sequence of actions may be executed in parallel with those of other tasks.</s>
 <s id="100">Such tasks may be implemented on multicomputers, multiprocessors, or with interleaved execution on a single processor.</s>
 <s id="101">A task unit may define either a single executing task or a task type permitting the creation of any number of similar tasks.</s>
 <s id="102">Declarations and Statements</s>
 <s id="103">The body of a program unit generally contains two parts: a declarative part, which defines the logical entities to be used in the program unit, and a sequence of statements, which defines the execution of the program unit.</s>
 <s id="104">The declarative part associates names with declared entities.</s>
 <s id="105">For example, a name may denote a type, a constant, a variable, or an exception.</s>
 <s id="106">A declarative part also introduces the names and parameters of other nested subprograms, packages, task units, and generic units to be used in the program unit.</s>
 <s id="107">The sequence of statements describes a sequence of actions that are to be performed.</s>
 <s id="108">The statements are executed in succession</s>
 <s id="109">(unless an exit, return, or goto statement, or the raising of an exception, causes execution to continue from another place).</s>
 <s id="110">An assignment statement changes the value of a variable.</s>
 <s id="111">A procedure call invokes execution of a procedure after associating any actual parameters provided at the call with the corresponding formal parameters.</s>
 <s id="112">Case statements and if statements allow the selection of an enclosed sequence of statements based on the value of an expression or on the value of a condition.</s>
 <s id="113">The loop statement provides the basic iterative mechanism in the language.</s>
 <s id="114">A loop statement specifies that a sequence of statements is to be executed repeatedly as directed by an iteration scheme, or until an exit statement is encountered.</s>
 <s id="115">A block statement comprises a sequence of statements preceded by the declaration of local entities used by the statements.</s>
 <s id="116">Certain statements are only applicable to tasks.</s>
 <s id="117">A delay statement delays the execution of a task for a specified duration.</s>
 <s id="118">An entry call statement is written as a procedure call statement;</s>
 <s id="119">it specifies that the task issuing the call is ready for a rendezvous with another task that has this entry.</s>
 <s id="120">The called task is ready to accept the entry call when its execution reaches a corresponding accept statement, which specifies the actions then to be performed.</s>
 <s id="121">After completion of the rendezvous, both the calling task and the task having the entry may continue their execution in parallel.</s>
 <s id="122">One form of the select statement allows a selective wait for one of several alternative rendezvous.</s>
 <s id="123">Other forms of the select statement allow conditional or timed entry calls.</s>
 <s id="124">Execution of a program unit may encounter error situations in which normal program execution cannot continue.</s>
 <s id="125">For example, an arithmetic computation may exceed the maximum allowed value of a number, or an attempt may be made to access an array component by using an incorrect index value.</s>
 <s id="126">To deal with such error situations, the statements of a program unit can be textually followed by exception handlers that specify the actions to be taken when the error situation arises.</s>
 <s id="127">Exceptions can be raised explicitly by a raise statement.</s>
 <s id="128">Data Types</s>
 <s id="129">Every object in the language has a type, which characterizes a set of values and a set of applicable operations.</s>
 <s id="130">The main classes of types are scalar types (comprising enumeration and numeric types), composite types, access types, and private types.</s>
 <s id="131">An enumeration type defines an ordered set of distinct enumeration literals, for example a list of states or an alphabet of characters.</s>
 <s id="132">The enumeration types BOOLEAN and CHARACTER are predefined.</s>
 <s id="133">Numeric types provide a means of performing exact or approximate numerical computations.</s>
 <s id="134">Exact computations use integer types, which denote sets of consecutive integers.</s>
 <s id="135">Approximate computations use either fixed point types, with absolute bounds on the error, or floating point types, with relative bounds on the error.</s>
 <s id="136">The numeric types INTEGER, FLOAT, and DURATION are predefined.</s>
 <s id="137">Composite types allow definitions of structured objects with related components.</s>
 <s id="138">The composite types in the language provide for arrays and records.</s>
 <s id="139">An array is an object with indexed components of the same type.</s>
 <s id="140">A record is an object with named components of possibly different types.</s>
 <s id="141">The array type STRING is predefined.</s>
 <s id="142">A record may have special components called discriminants.</s>
 <s id="143">Alternative record structures that depend on the values of discriminants can be defined within a record type.</s>
 <s id="144">Access types allow the construction of linked data structures created by the evaluation of allocators.</s>
 <s id="145">They allow several variables of an access type to designate the same object, and components of one object to designate the same or other objects.</s>
 <s id="146">Both the elements in such a linked data structure and their relation to other elements can be altered during program execution.</s>
 <s id="147">Private types can be defined in a package that conceals structural details that are externally irrelevant.</s>
 <s id="148">Only the logically necessary properties (including any discriminants) are made visible to the users of such types.</s>
 <s id="149">The concept of a type is refined by the concept of a subtype, whereby a user can constrain the set of allowed values of a type.</s>
 <s id="150">Subtypes can be used to define subranges of scalar types, arrays with a limited set of index values, and records and private types with particular discriminant values.</s>
 <s id="151">Other Facilities</s>
 <s id="152">Representation clauses can be used to specify the mapping between types and features of an underlying machine.</s>
 <s id="153">For example, the user can specify that objects of a given type must be represented with a given number of bits, or that the components of a record are to be represented using a given storage layout.</s>
 <s id="154">Other features allow the controlled use of low level, nonportable, or implementation-dependent aspects, including the direct insertion of machine code.</s>
 <s id="155">Input-output is defined in the language by means of predefined library packages.</s>
 <s id="156">Facilities are provided for input-output of values of user-defined as well as of predefined types.</s>
 <s id="157">Standard means of representing values in display form are also provided.</s>
 <s id="158">Finally, the language provides a powerful means of parameterization of program units, called generic program units.</s>
 <s id="159">The generic parameters can be types and subprograms (as well as objects) and so allow general algorithms to be applied to all types of a given class.</s>
 <s id="160">The form of Ada program units is described by means of a context-free syntax together with context-dependent requirements expressed by narrative rules.</s>
 <s id="161">The meaning of Ada program units is described by means of narrative rules defining both the effects of each construct and the composition rules for constructs.</s>
 <s id="162">This narrative employs technical terms whose precise definition is given in the text</s>
 <s id="163">(references to the section containing the definition of a technical term appear at the end of each section that uses the term).</s>
 <s id="164">All other terms are in the English language and bear their natural meaning, as defined in Webster's Third New International Dictionary of the English Language.</s>
 <s id="165">The context-free syntax of the language is described using a simple variant of Backus-Naur-Form.</s>
 <s id="166">In particular,</s>
 <s id="167">Lower case words, some containing embedded underlines, are used to denote syntactic categories, for example:</s>
 <s id="168">Whenever the name of a syntactic category is used apart from the syntax rules themselves, spaces take the place of the underlines (thus: adding operator).</s>
 <s id="169">Boldface words are used to denote reserved words, for example:</s>
 <s id="170">Square brackets enclose optional items.</s>
 <s id="171">Thus the two following rules are equivalent.</s>
 <s id="172">Braces enclose a repeated item.</s>
 <s id="173">The item may appear zero or more times;</s>
 <s id="174">the repetitions occur from left to right as with an equivalent left-recursive rule.</s>
 <s id="175">Thus the two following rules are equivalent.</s>
 <s id="176">A vertical bar separates alternative items unless it occurs immediately after an opening brace, in which case it stands for itself:</s>
 <s id="177">If the name of any syntactic category starts with an italicized part, it is equivalent to the category name without the italicized part.</s>
 <s id="178">The italicized part is intended to convey some semantic information.</s>
 <s id="179">For example type name and task name are both equivalent to name alone.</s>
 <s id="180">The syntax rules describing structured constructs are presented in a form that corresponds to the recommended paragraphing.</s>
 <s id="181">For example, an if statement is defined as</s>
 <s id="182">Different lines are used for parts of a syntax rule if the corresponding parts of the construct described by the rule are intended to be on different lines.</s>
 <s id="183">Indentation in the rule is a recommendation for indentation of the corresponding part of the construct.</s>
 <s id="184">It is recommended that all indentations be by multiples of a basic step of indentation</s>
 <s id="185">(the number of spaces for the basic step is not defined).</s>
 <s id="186">The preferred places for other line breaks are after semicolons.</s>
 <s id="187">On the other hand, if a complete construct can fit on one line, this is also allowed in the recommended paragraphing.</s>
 <s id="188">The language definition classifies errors into several different categories:</s>
 <s id="189">Errors that must be detected at compilation time by every Ada compiler.</s>
 <s id="190">These errors correspond to any violation of a rule given in this reference manual, other than the violations that correspond to (b) or (c) below.</s>
 <s id="191">In particular, violation of any rule that uses the terms must, allowed, legal, or illegal belongs to this category.</s>
 <s id="192">Any program that contains such an error is not a legal Ada program;</s>
 <s id="193">on the other hand, the fact that a program is legal does not mean, per se, that the program is free from other forms of error.</s>
 <s id="194">Errors that must be detected at run time by the execution of an Ada program.</s>
 <s id="195">The corresponding error situations are associated with the names of the predefined exceptions.</s>
 <s id="196">Every Ada compiler is required to generate code that raises the corresponding exception if such an error situation arises during program execution.</s>
 <s id="197">If an exception is certain to be raised in every execution of a program, then compilers are allowed (although not required) to report this fact at compilation time.</s>
 <s id="198">Erroneous execution.</s>
 <s id="199">The language rules specify certain rules to be obeyed by Ada programs, although there is no requirement on Ada compilers to provide either a compilation-time or a run-time detection of the violation of such rules.</s>
 <s id="200">The errors of this category are indicated by the use of the word erroneous to qualify the execution of the corresponding constructs.</s>
 <s id="201">The effect of erroneous execution is unpredictable.</s>
 <s id="202">Incorrect order dependences.</s>
 <s id="203">Whenever the reference manual specifies that different parts of a given construct are to be executed in some order that is not defined by the language, this means that the implementation is allowed to execute these parts in any given order, following the rules that result from that given order, but not in parallel.</s>
 <s id="204">Furthermore, the construct is incorrect if execution of these parts in a different order would have a different effect.</s>
 <s id="205">Compilers are not required to provide either compilation-time or run-time detection of incorrect order dependences.</s>
 <s id="206">The foregoing is expressed in terms of the process that is called execution; it applies equally to the processes that are called evaluation and elaboration.</s>
 <s id="207">If a compiler is able to recognize at compilation time that a construct is erroneous or contains an incorrect order dependence, then the compiler is allowed to generate, in place of the code otherwise generated for the construct, code that raises the predefined exception PROGRAM_ERROR.</s>
 <s id="208">Similarly, compilers are allowed to generate code that checks at run time for erroneous constructs, for incorrect order dependences, or for both.</s>
 <s id="209">The predefined exception PROGRAM_ERROR is raised if such a check fails.</s>
 <s id="210">The text of a program consists of the texts of one or more compilations.</s>
 <s id="211">The text of a compilation is a sequence of lexical elements, each composed of characters;</s>
 <s id="212">the rules of composition are given in this chapter.</s>
 <s id="213">Pragmas, which provide certain information for the compiler, are also described in this chapter.</s>
 <s id="214">The only characters allowed in the text of a program are the graphic characters and format effectors.</s>
 <s id="215">Each graphic character corresponds to a unique code of the ISO seven-bit coded character set (ISO standard 646), and is represented (visually) by a graphical symbol.</s>
 <s id="216">Some graphic characters are represented by different graphical symbols in alternative national representations of the ISO character set.</s>
 <s id="217">The description of the language definition in this standard reference manual uses the ASCII graphical symbols, the ANSI graphical representation of the ISO character set.</s>
 <s id="218">The basic character set is sufficient for writing any program.</s>
 <s id="219">The characters included in each of the categories of basic graphic characters are defined as follows: upper case letters, digits, special characters, the space character.</s>
 <s id="220">Format effectors are the ISO (and ASCII) characters called horizontal tabulation, vertical tabulation, carriage return, line feed, and form feed.</s>
 <s id="221">The characters included in each of the remaining categories of graphic characters are defined as follows: lower case letters, other special characters.</s>
 <s id="222">Allowable replacements for the special characters vertical bar (|), sharp (#), and quotation (") are defined in section 2.10.</s>
 <s id="223">The ISO character that corresponds to the sharp graphical symbol in the ASCII representation appears as a pound sterling symbol in the French, German, and United Kingdom standard national representations.</s>
 <s id="224">In any case, the font design of graphical symbols (for example, whether they are in italic or bold typeface) is not part of the ISO standard.</s>
 <s id="225">The meanings of the acronyms used in this section are as follows: ANSI stands for American National Standards Institute, ASCII stands for American Standard Code for Information Interchange, and ISO stands for International Organization for Standardization.</s>
 <s id="226">The following names are used when referring to special characters and other special characters:</s>
 <s id="227">The text of a program consists of the texts of one or more compilations.</s>
 <s id="228">The text of each compilation is a sequence of separate lexical elements.</s>
 <s id="229">Each lexical element is either a delimiter, an identifier (which may be a reserved word), a numeric literal, a character literal, a string literal, or a comment.</s>
 <s id="230">The effect of a program depends only on the particular sequences of lexical elements that form its compilations, excluding the comments, if any.</s>
 <s id="231">In some cases an explicit separator is required to separate adjacent lexical elements</s>
 <s id="232">(namely, when without separation, interpretation as a single lexical element is possible).</s>
 <s id="233">A separator is any of a space character, a format effector, or the end of a line.</s>
 <s id="234">A space character is a separator except within a comment, a string literal, or a space character literal.</s>
 <s id="235">Format effectors other than horizontal tabulation are always separators.</s>
 <s id="236">Horizontal tabulation is a separator except within a comment.</s>
 <s id="237">The end of a line is always a separator.</s>
 <s id="238">The language does not define what causes the end of a line.</s>
 <s id="239">However if, for a given implementation, the end of a line is signified by one or more characters, then these characters must be format effectors other than horizontal tabulation.</s>
 <s id="240">In any case, a sequence of one or more format effectors other than horizontal tabulation must cause at least one end of line.</s>
 <s id="241">One or more separators are allowed between any two adjacent lexical elements, before the first of each compilation, or after the last.</s>
 <s id="242">At least one separator is required between an identifier or a numeric literal and an adjacent identifier or numeric literal.</s>
 <s id="243">A delimiter is either one of the following special characters (in the basic character set)</s>
 <s id="244">or one of the following compound delimiters each composed of two adjacent special characters</s>
 <s id="245">Each of the special characters listed for single character delimiters is a single delimiter except if this character is used as a character of a compound delimiter, or as a character of a comment, string literal, character literal, or numeric literal.</s>
 <s id="246">The remaining forms of lexical element are described in other sections of this chapter.</s>
 <s id="247">Each lexical element must fit on one line, since the end of a line is a separator.</s>
 <s id="248">The quotation, sharp, and underline characters, likewise two adjacent hyphens, are not delimiters, but may form part of other lexical elements.</s>
 <s id="249">The following names are used when referring to compound delimiters:</s>
 <s id="250">Identifiers are used as names and also as reserved words.</s>
 <s id="251">All characters of an identifier are significant, including any underline character inserted between a letter or digit and an adjacent letter or digit.</s>
 <s id="252">Identifiers differing only in the use of corresponding upper and lower case letters are considered as the same.</s>
 <s id="253">No space is allowed within an identifier since a space is a separator.</s>
 <s id="254">There are two classes of numeric literals: real literals and integer literals.</s>
 <s id="255">A real literal is a numeric literal that includes a point;</s>
 <s id="256">an integer literal is a numeric literal without a point.</s>
 <s id="257">Real literals are the literals of the type universal real.</s>
 <s id="258">Integer literals are the literals of the type universal integer.</s>
 <s id="259">A decimal literal is a numeric literal expressed in the conventional decimal notation (that is, the base is implicitly ten).</s>
 <s id="260">An underline character inserted between adjacent digits of a decimal literal does not affect the value of this numeric literal.</s>
 <s id="261">The letter E of the exponent, if any, can be written either in lower case or in upper case, with the same meaning.</s>
 <s id="262">An exponent indicates the power of ten by which the value of the decimal literal without the exponent is to be multiplied to obtain the value of the decimal literal with the exponent.</s>
 <s id="263">An exponent for an integer literal must not have a minus sign.</s>
 <s id="264">Leading zeros are allowed.</s>
 <s id="265">No space is allowed in a numeric literal, not even between constituents of the exponent, since a space is a separator.</s>
 <s id="266">A zero exponent is allowed for an integer literal.</s>
 <s id="267">A based literal is a numeric literal expressed in a form that specifies the base explicitly.</s>
 <s id="268">The base must be at least two and at most sixteen.</s>
 <s id="269">An underline character inserted between adjacent digits of a based literal does not affect the value of this numeric literal.</s>
 <s id="270">The base and the exponent, if any, are in decimal notation.</s>
 <s id="271">The only letters allowed as extended digits are the letters A through F for the digits ten through fifteen.</s>
 <s id="272">A letter in a based literal (either an extended digit or the letter E of an exponent) can be written either in lower case or in upper case, with the same meaning.</s>
 <s id="273">The conventional meaning of based notation is assumed;</s>
 <s id="274">in particular the value of each extended digit of a based literal must be less than the base.</s>
 <s id="275">An exponent indicates the power of the base by which the value of the based literal without the exponent is to be multiplied to obtain the value of the based literal with the exponent.</s>
 <s id="276">A character literal is formed by enclosing one of the 95 graphic characters (including the space) between two apostrophe characters.</s>
 <s id="277">A character literal has a value that belongs to a character type.</s>
 <s id="278">A string literal is formed by a sequence of graphic characters (possibly none) enclosed between two quotation characters used as string brackets.</s>
 <s id="279">A string literal has a value that is a sequence of character values corresponding to the graphic characters of the string literal apart from the quotation character itself.</s>
 <s id="280">If a quotation character value is to be represented in the sequence of character values, then a pair of adjacent quotation characters must be written at the corresponding place within the string literal.</s>
 <s id="281">(This means that a string literal that includes two adjacent quotation characters is never interpreted as two adjacent string literals.)</s>
 <s id="282">The length of a string literal is the number of character values in the sequence represented.</s>
 <s id="283">(Each doubled quotation character is counted as a single character.)</s>
 <s id="284">A string literal must fit on one line since it is a lexical element (see 2.2).</s>
 <s id="285">Longer sequences of graphic character values can be obtained by catenation of string literals.</s>
 <s id="286">Similarly catenation of constants declared in the package ASCII can be used to obtain sequences of character values that include nongraphic character values (the so-called control characters).</s>
 <s id="287">Examples of such uses of catenation are given below:</s>
 <s id="288">A comment starts with two adjacent hyphens and extends up to the end of the line.</s>
 <s id="289">A comment can appear on any line of a program.</s>
 <s id="290">The presence or absence of comments has no influence on whether a program is legal or illegal.</s>
 <s id="291">Furthermore, comments do not influence the effect of a program;</s>
 <s id="292">their sole purpose is the enlightenment of the human reader.</s>
 <s id="293">Horizontal tabulation can be used in comments, after the double hyphen, and is equivalent to one or more spaces (see 2.2).</s>
 <s id="294">A pragma is used to convey information to the compiler.</s>
 <s id="295">A pragma starts with the reserved word pragma followed by an identifier that is the name of the pragma.</s>
 <s id="296">Pragmas are only allowed at the following places in a program:</s>
 <s id="297">After a semicolon delimiter, but not within a formal part or discriminant part.</s>
 <s id="298">At any place where the syntax rules allow a construct defined by a syntactic category whose name ends with "declaration", "statement", "clause", or "alternative", or one of the syntactic categories variant and exception handler; but not in place of such a construct.</s>
 <s id="299">Also at any place where a compilation unit would be allowed.</s>
 <s id="300">Additional restrictions exist for the placement of specific pragmas.</s>
 <s id="301">Some pragmas have arguments.</s>
 <s id="302">Argument associations can be either positional or named as for parameter associations of subprogram calls (see 6.4).</s>
 <s id="303">Named associations are, however, only possible if the argument identifiers are defined.</s>
 <s id="304">A name given in an argument must be either a name visible at the place of the pragma or an identifier specific to the pragma.</s>
 <s id="305">The pragmas defined by the language are described in Annex B: they must be supported by every implementation.</s>
 <s id="306">In addition, an implementation may provide implementation-defined pragmas, which must then be described in Appendix F.</s>
 <s id="307">An implementation is not allowed to define pragmas whose presence or absence influences the legality of the text outside such pragmas.</s>
 <s id="308">Consequently, the legality of a program does not depend on the presence or absence of implementation-defined pragmas.</s>
 <s id="309">A pragma that is not language-defined has no effect if its identifier is not recognized by the (current) implementation.</s>
 <s id="310">Furthermore, a pragma (whether language-defined or implementation-defined) has no effect if its placement or its arguments do not correspond to what is allowed for the pragma.</s>
 <s id="311">The region of text over which a pragma has an effect depends on the pragma.</s>
 <s id="312">It is recommended (but not required) that implementations issue warnings for pragmas that are not recognized and therefore ignored.</s>
 <s id="313">Categories ending with "declaration" comprise: basic declaration 3.1, component declaration 3.7, entry declaration 9.5, generic parameter declaration 12.1</s>
 <s id="314">Categories ending with "clause" comprise: alignment clause 13.4, component clause 13.4, context clause 10.1.1, representation clause 13.1, use clause 8.4, with clause 10.1.1</s>
 <s id="315">Categories ending with "alternative" comprise: accept alternative 9.7.1, case statement alternative 5.4, delay alternative 9.7.1, select alternative 9.7.1, selective wait alternative 9.7.1, terminate alternative 9.7.1</s>
 <s id="316">The identifiers listed below are called reserved words and are reserved for special significance in the language.</s>
 <s id="317">For readability of this manual, the reserved words appear in lower case boldface.</s>
 <s id="318">A reserved word must not be used as a declared identifier.</s>
 <s id="319">Reserved words differing only in the use of corresponding upper and lower case letters are considered as the same (see 2.3).</s>
 <s id="320">In some attributes the identifier that appears after the apostrophe is identical to some reserved word.</s>
 <s id="321">The following replacements are allowed for the vertical bar, sharp, and quotation basic characters:</s>
 <s id="322">A vertical bar character (|) can be replaced by an exclamation mark (!) where used as a delimiter.</s>
 <s id="323">The sharp characters (#) of a based literal can be replaced by colons (:) provided that the replacement is done for both occurrences.</s>
 <s id="324">The quotation characters (") used as string brackets at both ends of a string literal can be replaced by percent characters (%) provided that the enclosed sequence of characters contains no quotation character, and provided that both string brackets are replaced.</s>
 <s id="325">Any percent character within the sequence of characters must then be doubled and each such doubled percent character is interpreted as a single percent character value.</s>
 <s id="326">These replacements do not change the meaning of the program.</s>
 <s id="327">It is recommended that use of the replacements for the vertical bar, sharp, and quotation characters be restricted to cases where the corresponding graphical symbols are not available.</s>
 <s id="328">Note that the vertical bar appears as a broken bar on some equipment; replacement is not recommended in this case.</s>
 <s id="329">The rules given for identifiers and numeric literals are such that lower case and upper case letters can be used indifferently;</s>
 <s id="330">these lexical elements can thus be written using only characters of the basic character set.</s>
 <s id="331">If a string literal of the predefined type STRING contains characters that are not in the basic character set, the same sequence of character values can be obtained by catenating string literals that contain only characters of the basic character set with suitable character constants declared in the predefined package ASCII.</s>
 <s id="332">Thus the string literal "AB$CD" could be replaced by "AB" &amp; ASCII.DOLLAR &amp; "CD".</s>
 <s id="333">Similarly, the string literal "ABcd" with lower case letters could be replaced by "AB" &amp; ASCII.LC_C &amp; ASCII.LC_D.</s>
 <s id="334">This chapter describes the types in the language and the rules for declaring constants, variables, and named numbers.</s>
 <s id="335">The language defines several kinds of entities that are declared, either explicitly or implicitly, by declarations.</s>
 <s id="336">Such an entity can be a numeric literal, an object, a discriminant, a record component, a loop parameter, an exception, a type, a subtype, a subprogram, a package, a task unit, a generic unit, a single entry, an entry family, a formal parameter (of a subprogram, entry, or generic subprogram), a generic formal parameter, a named block or loop, a labeled statement, or an operation (in particular, an attribute or an enumeration literal; see 3.3.3).</s>
 <s id="337">There are several forms of declaration.</s>
 <s id="338">A basic declaration is a form of declaration defined as follows.</s>
 <s id="339">Certain forms of declaration always occur (explicitly) as part of a basic declaration; these forms are discriminant specifications, component declarations, entry declarations, parameter specifications, generic parameter declarations, and enumeration literal specifications.</s>
 <s id="340">A loop parameter specification is a form of declaration that occurs only in certain forms of loop statement.</s>
 <s id="341">The remaining forms of declaration are implicit: the name of a block, the name of a loop, and a statement label are implicitly declared.</s>
 <s id="342">Certain operations are implicitly declared (see 3.3.3).</s>
 <s id="343">For each form of declaration the language rules define a certain region of text called the scope of the declaration (see 8.2).</s>
 <s id="344">Several forms of declaration associate an identifier with a declared entity.</s>
 <s id="345">Within its scope, and only there, there are places where it is possible to use the identifier to refer to the associated declared entity;</s>
 <s id="346">these places are defined by the visibility rules (see 8.3).</s>
 <s id="347">At such places the identifier is said to be a name of the entity (its simple name);</s>
 <s id="348">the name is said to denote the associated entity.</s>
 <s id="349">Certain forms of enumeration literal specification associate a character literal with the corresponding declared entity.</s>
 <s id="350">Certain forms of declaration associate an operator symbol or some other notation with an explicitly or implicitly declared operation.</s>
 <s id="351">The process by which a declaration achieves its effect is called the elaboration of the declaration;</s>
 <s id="352">this process happens during program execution.</s>
 <s id="353">After its elaboration, a declaration is said to be elaborated.</s>
 <s id="354">Prior to the completion of its elaboration (including before the elaboration), the declaration is not yet elaborated.</s>
 <s id="355">The elaboration of any declaration has always at least the effect of achieving this change of state (from not yet elaborated to elaborated).</s>
 <s id="356">The phrase "the elaboration has no other effect" is used in this manual whenever this change of state is the only effect of elaboration for some form of declaration.</s>
 <s id="357">An elaboration process is also defined for declarative parts, declarative items, and compilation units (see 3.9 and 10.5).</s>
 <s id="358">Object, number, type, and subtype declarations are described here.</s>
 <s id="359">The remaining basic declarations are described in later chapters.</s>
 <s id="360">The syntax rules use the term identifier for the first occurrence of an identifier in some form of declaration;</s>
 <s id="361">the term simple name is used for any occurrence of an identifier that already denotes some declared entity.</s>
 <s id="362">An object is an entity that contains (has) a value of a given type.</s>
 <s id="363">An object is one of the following:</s>
 <s id="364">an object declared by an object declaration or by a single task declaration,</s>
 <s id="365">a formal parameter of a subprogram, entry, or generic subprogram,</s>
 <s id="366">a generic formal object,</s>
 <s id="367">a loop parameter,</s>
 <s id="368">an object designated by a value of an access type,</s>
 <s id="369">a component or a slice of another object.</s>
 <s id="370">A number declaration is a special form of object declaration that associates an identifier with a value of type universal integer or universal real.</s>
 <s id="371">An object declaration is called a single object declaration if its identifier list has a single identifier;</s>
 <s id="372">it is called a multiple object declaration if the identifier list has two or more identifiers.</s>
 <s id="373">A multiple object declaration is equivalent to a sequence of the corresponding number of single object declarations.</s>
 <s id="374">For each identifier of the list, the equivalent sequence has a single object declaration formed by this identifier, followed by a colon and by whatever appears at the right of the colon in the multiple object declaration;</s>
 <s id="375">the equivalent sequence is in the same order as the identifier list.</s>
 <s id="376">A similar equivalence applies also for the identifier lists of number declarations, component declarations, discriminant specifications, parameter specifications, generic parameter declarations, exception declarations, and deferred constant declarations.</s>
 <s id="377">In the remainder of this reference manual, explanations are given for declarations with a single identifier;</s>
 <s id="378">the corresponding explanations for declarations with several identifiers follow from the equivalence stated above.</s>
 <s id="379">An object declaration declares an object whose type is given either by a subtype indication or by a constrained array definition.</s>
 <s id="380">If the object declaration includes the assignment compound delimiter followed by an expression, the expression specifies an initial value for the declared object;</s>
 <s id="381">the type of the expression must be that of the object.</s>
 <s id="382">The declared object is a constant if the reserved word constant appears in the object declaration;</s>
 <s id="383">the declaration must then include an explicit initialization.</s>
 <s id="384">The value of a constant cannot be modified after initialization.</s>
 <s id="385">Formal parameters of mode in of subprograms and entries, and generic formal parameters of mode in, are also constants;</s>
 <s id="386">a loop parameter is a constant within the corresponding loop;</s>
 <s id="387">a subcomponent or slice of a constant is a constant.</s>
 <s id="388">An object that is not a constant is called a variable</s>
 <s id="389">(in particular, the object declared by an object declaration that does not include the reserved word constant is a variable).</s>
 <s id="390">The only ways to change the value of a variable are either directly by an assignment, or indirectly when the variable is updated (see 6.2) by a procedure or entry call statement</s>
 <s id="391">(this action can be performed either on the variable itself, on a subcomponent of the variable, or on another variable that has the given variable as subcomponent).</s>
 <s id="392">The elaboration of an object declaration proceeds as follows:</s>
 <s id="393">The subtype indication or the constrained array definition is first elaborated.</s>
 <s id="394">This establishes the subtype of the object.</s>
 <s id="395">If the object declaration includes an explicit initialization, the initial value is obtained by evaluating the corresponding expression.</s>
 <s id="396">Otherwise any implicit initial values for the object or for its subcomponents are evaluated.</s>
 <s id="397">The object is created.</s>
 <s id="398">Any initial value (whether explicit or implicit) is assigned to the object or to the corresponding subcomponent.</s>
 <s id="399">Implicit initial values are defined for objects declared by object declarations, and for components of such objects, in the following cases:</s>
 <s id="400">If the type of an object is an access type, the implicit initial value is the null value of the access type.</s>
 <s id="401">If the type of an object is a task type, the implicit initial (and only) value designates a corresponding task.</s>
 <s id="402">If the type of an object is a type with discriminants and the subtype of the object is constrained, the implicit initial (and only) value of each discriminant is defined by the subtype of the object.</s>
 <s id="403">If the type of an object is a composite type, the implicit initial value of each component that has a default expression is obtained by evaluation of this expression, unless the component is a discriminant of a constrained object (the previous case).</s>
 <s id="404">In the case of a component that is itself a composite object and whose value is defined neither by an explicit initialization nor by a default expression, any implicit initial values for components of the composite object are defined by the same rules as for a declared object.</s>
 <s id="405">The steps (a) to (d) are performed in the order indicated.</s>
 <s id="406">For step (b), if the default expression for a discriminant is evaluated, then this evaluation is performed before that of default expressions for subcomponents that depend on discriminants, and also before that of default expressions that include the name of the discriminant.</s>
 <s id="407">Apart from the previous rule, the evaluation of default expressions is performed in some order that is not defined by the language.</s>
 <s id="408">The initialization of an object (the declared object or one of its subcomponents) checks that the initial value belongs to the subtype of the object;</s>
 <s id="409">for an array object declared by an object declaration, an implicit subtype conversion is first applied as for an assignment statement, unless the object is a constant whose subtype is an unconstrained array type.</s>
 <s id="410">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="411">The value of a scalar variable is undefined after elaboration of the corresponding object declaration unless an initial value is assigned to the variable by an initialization (explicitly or implicitly).</s>
 <s id="412">If the operand of a type conversion or qualified expression is a variable that has scalar subcomponents with undefined values, then the values of the corresponding subcomponents of the result are undefined.</s>
 <s id="413">The execution of a program is erroneous if it attempts to evaluate a scalar variable with an undefined value.</s>
 <s id="414">Similarly, the execution of a program is erroneous if it attempts to apply a predefined operator to a variable that has a scalar subcomponent with an undefined value.</s>
 <s id="415">Examples of variable declarations:</s>
 <s id="416">Examples of constant declarations:</s>
 <s id="417">The expression initializing a constant object need not be a static expression (see 4.9).</s>
 <s id="418">In the above examples, LIMIT and LOW_LIMIT are initialized with static expressions, but TOLERANCE is not if DISPERSION is a user-defined function.</s>
 <s id="419">A number declaration is a special form of constant declaration.</s>
 <s id="420">The type of the static expression given for the initialization of a number declaration must be either the type universal integer or the type universal real.</s>
 <s id="421">The constant declared by a number declaration is called a named number and has the type of the static expression.</s>
 <s id="422">The rules concerning expressions of a universal type are explained in section 4.10.</s>
 <s id="423">It is a consequence of these rules that if every primary contained in the expression is of the type universal integer, then the named number is also of this type.</s>
 <s id="424">Similarly, if every primary is of the type universal real, then the named number is also of this type.</s>
 <s id="425">Examples of number declarations:</s>
 <s id="426">A type is characterized by a set of values and a set of operations.</s>
 <s id="427">There exist several classes of types.</s>
 <s id="428">Scalar types are integer types, real types, and types defined by enumeration of their values;</s>
 <s id="429">values of these types have no components.</s>
 <s id="430">Array and record types are composite;</s>
 <s id="431">a value of a composite type consists of component values.</s>
 <s id="432">An access type is a type whose values provide access to objects.</s>
 <s id="433">Private types are types for which the set of possible values is well defined, but not directly available to the users of such types.</s>
 <s id="434">Finally, there are task types.</s>
 <s id="435">(Private types are described in chapter 7, task types are described in chapter 9, the other classes of types are described in this chapter.)</s>
 <s id="436">Certain record and private types have special components called discriminants whose values distinguish alternative forms of values of one of these types.</s>
 <s id="437">If a private type has discriminants, they are known to users of the type.</s>
 <s id="438">Hence a private type is only known by its name, its discriminants if any, and by the corresponding set of operations.</s>
 <s id="439">The set of possible values for an object of a given type can be subjected to a condition that is called a constraint</s>
 <s id="440">(the case where the constraint imposes no restriction is also included);</s>
 <s id="441">a value is said to satisfy a constraint if it satisfies the corresponding condition.</s>
 <s id="442">A subtype is a type together with a constraint;</s>
 <s id="443">a value is said to belong to a subtype of a given type if it belongs to the type and satisfies the constraint;</s>
 <s id="444">the given type is called the base type of the subtype.</s>
 <s id="445">A type is a subtype of itself; such a subtype is said to be unconstrained: it corresponds to a condition that imposes no restriction.</s>
 <s id="446">The base type of a type is the type itself.</s>
 <s id="447">The set of operations defined for a subtype of a given type includes the operations that are defined for the type;</s>
 <s id="448">however the assignment operation to a variable having a given subtype only assigns values that belong to the subtype.</s>
 <s id="449">Additional operations, such as qualification (in a qualified expression), are implicitly defined by a subtype declaration.</s>
 <s id="450">Certain types have default initial values defined for objects of the type; certain other types have default expressions defined for some or all of their components.</s>
 <s id="451">Certain operations of types and subtypes are called attributes;</s>
 <s id="452">these operations are denoted by the form of name described in section 4.1.4.</s>
 <s id="453">The term subcomponent is used in this manual in place of the term component to indicate either a component, or a component of another component or subcomponent.</s>
 <s id="454">Where other subcomponents are excluded, the term component is used instead.</s>
 <s id="455">A given type must not have a subcomponent whose type is the given type itself.</s>
 <s id="456">The name of a class of types is used in this manual as a qualifier for objects and values that have a type of the class considered.</s>
 <s id="457">For example, the term "array object" is used for an object whose type is an array type;</s>
 <s id="458">similarly, the term "access value" is used for a value of an access type.</s>
 <s id="459">The set of values of a subtype is a subset of the values of the base type.</s>
 <s id="460">This subset need not be a proper subset;</s>
 <s id="461">it can be an empty subset.</s>
 <s id="462">A type declaration declares a type.</s>
 <s id="463">The elaboration of a full type declaration consists of the elaboration of the discriminant part, if any (except in the case of the full type declaration for an incomplete or private type declaration), and of the elaboration of the type definition.</s>
 <s id="464">The types created by the elaboration of distinct type definitions are distinct types.</s>
 <s id="465">Moreover, the elaboration of the type definition for a numeric or derived type creates both a base type and a subtype of the base type;</s>
 <s id="466">the same holds for a constrained array definition (one of the two forms of array type definition).</s>
 <s id="467">The simple name declared by a full type declaration denotes the declared type, unless the type declaration declares both a base type and a subtype of the base type, in which case the simple name denotes the subtype, and the base type is anonymous.</s>
 <s id="468">A type is said to be anonymous if it has no simple name.</s>
 <s id="469">For explanatory purposes, this reference manual sometimes refers to an anonymous type by a pseudo-name, written in italics, and uses such pseudo-names at places where the syntax normally requires an identifier.</s>
 <s id="470">Examples of type definitions:</s>
 <s id="471">Examples of type declarations:</s>
 <s id="472">Two type definitions always define two distinct types, even if they are textually identical.</s>
 <s id="473">Thus, the array type definitions given in the declarations of A and B below define distinct types.</s>
 <s id="474">If A and B are declared by a multiple object declaration as below, their types are nevertheless different, since the multiple object declaration is equivalent to the above two single object declarations.</s>
 <s id="475">Incomplete type declarations are used for the definition of recursive and mutually dependent types (see 3.8.1).</s>
 <s id="476">Private type declarations are used in package specifications and in generic parameter declarations (see 7.4 and 12.1).</s>
 <s id="477">A subtype declaration declares a subtype.</s>
 <s id="478">A type mark denotes a type or a subtype.</s>
 <s id="479">If a type mark is the name of a type, the type mark denotes this type and also the corresponding unconstrained subtype.</s>
 <s id="480">The base type of a type mark is, by definition, the base type of the type or subtype denoted by the type mark.</s>
 <s id="481">A subtype indication defines a subtype of the base type of the type mark.</s>
 <s id="482">If an index constraint appears after a type mark in a subtype indication, the type mark must not already impose an index constraint.</s>
 <s id="483">Likewise for a discriminant constraint, the type mark must not already impose a discriminant constraint.</s>
 <s id="484">The elaboration of a subtype declaration consists of the elaboration of the subtype indication.</s>
 <s id="485">The elaboration of a subtype indication creates a subtype.</s>
 <s id="486">If the subtype indication does not include a constraint, the subtype is the same as that denoted by the type mark.</s>
 <s id="487">The elaboration of a subtype indication that includes a constraint proceeds as follows:</s>
 <s id="488">The constraint is first elaborated.</s>
 <s id="489">A check is then made that the constraint is compatible with the type or subtype denoted by the type mark.</s>
 <s id="490">The condition imposed by a constraint is the condition obtained after elaboration of the constraint.</s>
 <s id="491">(The rules of constraint elaboration are such that the expressions and ranges of constraints are evaluated by the elaboration of these constraints.)</s>
 <s id="492">The rules defining compatibility are given for each form of constraint in the appropriate section.</s>
 <s id="493">These rules are such that if a constraint is compatible with a subtype, then the condition imposed by the constraint cannot contradict any condition already imposed by the subtype on its values.</s>
 <s id="494">The exception CONSTRAINT_ERROR is raised if any check of compatibility fails.</s>
 <s id="495">Examples of subtype declarations:</s>
 <s id="496">A subtype declaration does not define a new type.</s>
 <s id="497">The set of operations of a type includes the explicitly declared subprograms that have a parameter or result of the type;</s>
 <s id="498">such subprograms are necessarily declared after the type declaration.</s>
 <s id="499">The remaining operations are each implicitly declared for a given type declaration, immediately after the type definition.</s>
 <s id="500">These implicitly declared operations comprise the basic operations, the predefined operators (see 4.5), and enumeration literals.</s>
 <s id="501">In the case of a derived type declaration, the implicitly declared operations include any derived subprograms.</s>
 <s id="502">The operations implicitly declared for a given type declaration occur after the type declaration and before the next explicit declaration, if any.</s>
 <s id="503">The implicit declarations of derived subprograms occur last.</s>
 <s id="504">A basic operation is an operation that is inherent in one of the following:</s>
 <s id="505">An assignment (in assignment statements and initializations), an allocator, a membership test, or a short-circuit control form.</s>
 <s id="506">A selected component, an indexed component, or a slice.</s>
 <s id="507">A qualification (in qualified expressions), an explicit type conversion, or an implicit type conversion of a value of type universal integer or universal real to the corresponding value of another numeric type.</s>
 <s id="508">A numeric literal (for a universal type), the literal null (for an access type), a string literal, an aggregate, or an attribute.</s>
 <s id="509">For every type or subtype T, the following attribute is defined:</s>
 <s id="510">The base type of T.</s>
 <s id="511">This attribute is allowed only as the prefix of the name of another attribute: for example, T'BASE'FIRST.</s>
 <s id="512">Each literal is an operation whose evaluation yields the corresponding value (see 4.2).</s>
 <s id="513">Likewise, an aggregate is an operation whose evaluation yields a value of a composite type (see 4.3).</s>
 <s id="514">Some operations of a type operate on values of the type, for example, predefined operators and certain subprograms and attributes.</s>
 <s id="515">The evaluation of some operations of a type returns a value of the type, for example, literals and certain functions, attributes, and predefined operators.</s>
 <s id="516">Assignment is an operation that operates on an object and a value.</s>
 <s id="517">The evaluation of the operation corresponding to a selected component, an indexed component, or a slice, yields the object or value denoted by this form of name.</s>
 <s id="518">A derived type definition defines a new (base) type whose characteristics are derived from those of a parent type; the new type is called a derived type.</s>
 <s id="519">A derived type definition further defines a derived subtype, which is a subtype of the derived type.</s>
 <s id="520">The subtype indication that occurs after the reserved word new defines the parent subtype.</s>
 <s id="521">The parent type is the base type of the parent subtype.</s>
 <s id="522">If a constraint exists for the parent subtype, a similar constraint exists for the derived subtype;</s>
 <s id="523">the only difference is that for a range constraint, and likewise for a floating or fixed point constraint that includes a range constraint, the value of each bound is replaced by the corresponding value of the derived type.</s>
 <s id="524">The characteristics of the derived type are defined as follows:</s>
 <s id="525">The derived type belongs to the same class of types as the parent type.</s>
 <s id="526">The set of possible values for the derived type is a copy of the set of possible values for the parent type.</s>
 <s id="527">If the parent type is composite, then the same components exist for the derived type, and the subtype of corresponding components is the same.</s>
 <s id="528">For each basic operation of the parent type, there is a corresponding basic operation of the derived type.</s>
 <s id="529">Explicit type conversion of a value of the parent type into the corresponding value of the derived type is allowed and vice versa as explained in section 4.6.</s>
 <s id="530">For each enumeration literal or predefined operator of the parent type there is a corresponding operation for the derived type.</s>
 <s id="531">If the parent type is a task type, then for each entry of the parent type there is a corresponding entry for the derived type.</s>
 <s id="532">If a default expression exists for a component of an object having the parent type, then the same default expression is used for the corresponding component of an object having the derived type.</s>
 <s id="533">If the parent type is an access type, then the parent and the derived type share the same collection;</s>
 <s id="534">there is a null access value for the derived type and it is the default initial value of that type.</s>
 <s id="535">If an explicit representation clause exists for the parent type and if this clause appears before the derived type definition, then there is a corresponding representation clause (an implicit one) for the derived type.</s>
 <s id="536">Certain subprograms that are operations of the parent type are said to be derivable.</s>
 <s id="537">For each derivable subprogram of the parent type, there is a corresponding derived subprogram for the derived type.</s>
 <s id="538">Two kinds of derivable subprograms exist.</s>
 <s id="539">First, if the parent type is declared immediately within the visible part of a package, then a subprogram that is itself explicitly declared immediately within the visible part becomes derivable after the end of the visible part, if it is an operation of the parent type.</s>
 <s id="540">(The explicit declaration is by a subprogram declaration, a renaming declaration, or a generic instantiation.)</s>
 <s id="541">Second, if the parent type is itself a derived type, then any subprogram that has been derived by this parent type is further derivable, unless the parent type is declared in the visible part of a package and the derived subprogram is hidden by a derivable subprogram of the first kind.</s>
 <s id="542">Each operation of the derived type is implicitly declared at the place of the derived type declaration.</s>
 <s id="543">The implicit declarations of any derived subprograms occur last.</s>
 <s id="544">The specification of a derived subprogram is obtained implicitly by systematic replacement of the parent type by the derived type in the specification of the derivable subprogram.</s>
 <s id="545">Any subtype of the parent type is likewise replaced by a subtype of the derived type with a similar constraint</s>
 <s id="546">(as for the transformation of a constraint of the parent subtype into the corresponding constraint of the derived subtype).</s>
 <s id="547">Finally, any expression of the parent type is made to be the operand of a type conversion that yields a result of the derived type.</s>
 <s id="548">Calling a derived subprogram is equivalent to calling the corresponding subprogram of the parent type, in which each actual parameter that is of the derived type is replaced by a type conversion of this actual parameter to the parent type</s>
 <s id="549">(this means that a conversion to the parent type happens before the call for the modes in and in out;</s>
 <s id="550">a reverse conversion to the derived type happens after the call for the modes in out and out, see 6.4.1).</s>
 <s id="551">In addition, if the result of a called function is of the parent type, this result is converted to the derived type.</s>
 <s id="552">If a derived or private type is declared immediately within the visible part of a package, then, within this visible part, this type must not be used as the parent type of a derived type definition.</s>
 <s id="553">(For private types, see also section 7.4.1.)</s>
 <s id="554">For the elaboration of a derived type definition, the subtype indication is first elaborated, the derived type is then created, and finally, the derived subtype is created.</s>
 <s id="555">The rules of derivation of basic operations and enumeration literals imply that the notation for any literal or aggregate of the derived type is the same as for the parent type;</s>
 <s id="556">such literals and aggregates are said to be overloaded.</s>
 <s id="557">Similarly, it follows that the notation for denoting a component, a discriminant, an entry, a slice, or an attribute is the same for the derived type as for the parent type.</s>
 <s id="558">Hiding of a derived subprogram is allowed even within the same declarative region (see 8.3).</s>
 <s id="559">A derived subprogram hides a predefined operator that has the same parameter and result type profile (see 6.6).</s>
 <s id="560">A generic subprogram declaration is not derivable since it declares a generic unit rather than a subprogram.</s>
 <s id="561">On the other hand, an instantiation of a generic subprogram is a (nongeneric) subprogram, which is derivable if it satisfies the requirements for derivability of subprograms.</s>
 <s id="562">If the parent type is a boolean type, the predefined relational operators of the derived type deliver a result of the predefined type BOOLEAN (see 4.5.2).</s>
 <s id="563">If a representation clause is given for the parent type but appears after the derived type declaration, then no corresponding representation clause applies to the derived type;</s>
 <s id="564">hence an explicit representation clause for such a derived type is allowed.</s>
 <s id="565">For a derived subprogram, if a parameter belongs to the derived type, the subtype of this parameter need not have any value in common with the derived subtype.</s>
 <s id="566">Scalar types comprise enumeration types, integer types, and real types.</s>
 <s id="567">Enumeration types and integer types are called discrete types;</s>
 <s id="568">each value of a discrete type has a position number which is an integer value.</s>
 <s id="569">Integer types and real types are called numeric types.</s>
 <s id="570">All scalar types are ordered, that is, all relational operators are predefined for their values.</s>
 <s id="571">A range specifies a subset of values of a scalar type.</s>
 <p id="p572">
  <s id="572.1">The range L ..</s>
  <s id="572.2">R specifies the values from L to R inclusive if the relation L &lt;= R is true.</s>
 </p>
 <s id="573">The values L and R are called the lower bound and upper bound of the range, respectively.</s>
 <s id="574">A value V is said to satisfy a range constraint if it belongs to the range;</s>
 <s id="575">the value V is said to belong to the range if the relations L &lt;= V and V &lt;= R are both TRUE.</s>
 <s id="576">A null range is a range for which the relation R &lt; L is TRUE;</s>
 <s id="577">no value belongs to a null range.</s>
 <s id="578">The operators &lt;= and &lt; in the above definitions are the predefined operators of the scalar type.</s>
 <s id="579">If a range constraint is used in a subtype indication, either directly or as part of a floating or fixed point constraint, the type of the simple expressions (likewise, of the bounds of a range attribute) must be the same as the base type of the type mark of the subtype indication.</s>
 <s id="580">A range constraint is compatible with a subtype if each bound of the range belongs to the subtype, or if the range constraint defines a null range;</s>
 <s id="581">otherwise the range constraint is not compatible with the subtype.</s>
 <s id="582">The elaboration of a range constraint consists of the evaluation of the range.</s>
 <s id="583">The evaluation of a range defines its lower bound and its upper bound.</s>
 <s id="584">If simple expressions are given to specify the bounds, the evaluation of the range evaluates these simple expressions in some order that is not defined by the language.</s>
 <s id="585">Attributes</s>
 <s id="586">For any scalar type T or for any subtype T of a scalar type, the following attributes are defined:</s>
 <s id="587">Yields the lower bound of T.</s>
 <s id="588">The value of this attribute has the same type as T.</s>
 <s id="589">Yields the upper bound of T.</s>
 <s id="590">The value of this attribute has the same type as T.</s>
 <s id="591">Indexing and iteration rules use values of discrete types.</s>
 <s id="592">An enumeration type definition defines an enumeration type.</s>
 <s id="593">The identifiers and character literals listed by an enumeration type definition must be distinct.</s>
 <s id="594">Each enumeration literal specification is the declaration of the corresponding enumeration literal: this declaration is equivalent to the declaration of a parameterless function, the designator being the enumeration literal, and the result type being the enumeration type.</s>
 <s id="595">The elaboration of an enumeration type definition creates an enumeration type;</s>
 <s id="596">this elaboration includes that of every enumeration literal specification.</s>
 <s id="597">Each enumeration literal yields a different enumeration value.</s>
 <s id="598">The predefined order relations between enumeration values follow the order of corresponding position numbers.</s>
 <s id="599">The position number of the value of the first listed enumeration literal is zero;</s>
 <s id="600">the position number for each other enumeration literal is one more than for its predecessor in the list.</s>
 <s id="601">If the same identifier or character literal is specified in more than one enumeration type definition, the corresponding literals are said to be overloaded.</s>
 <s id="602">At any place where an overloaded enumeration literal occurs in the text of a program, the type of the enumeration literal must be determinable from the context (see 8.7).</s>
 <s id="603">If an enumeration literal occurs in a context that does not otherwise suffice to determine the type of the literal, then qualification by the name of the enumeration type is one way to resolve the ambiguity (see 8.7).</s>
 <s id="604">An enumeration type is said to be a character type if at least one of its enumeration literals is a character literal.</s>
 <s id="605">The predefined type CHARACTER is a character type whose values are the 128 characters of the ASCII character set.</s>
 <s id="606">Each of the 95 graphic characters of this character set is denoted by the corresponding character literal.</s>
 <s id="607">The predefined package ASCII includes the declaration of constants denoting control characters and of constants denoting graphic characters that are not in the basic character set.</s>
 <s id="608">A conventional character set such as EBCDIC can be declared as a character type;</s>
 <s id="609">the internal codes of the characters can be specified by an enumeration representation clause as explained in section 13.3.</s>
 <s id="610">There is a predefined enumeration type named BOOLEAN.</s>
 <s id="611">It contains the two literals FALSE and TRUE ordered with the relation FALSE &lt; TRUE.</s>
 <s id="612">A boolean type is either the type BOOLEAN or a type that is derived, directly or indirectly, from a boolean type.</s>
 <s id="613">An integer type definition defines an integer type whose set of values includes at least those of the specified range.</s>
 <s id="614">If a range constraint is used as an integer type definition, each bound of the range must be defined by a static expression of some integer type, but the two bounds need not have the same integer type.</s>
 <s id="615">(Negative bounds are allowed.)</s>
 <s id="616">A type declaration of the form:</s>
 <s id="617">is, by definition, equivalent to the following declarations:</s>
 <s id="618">where integer type is an anonymous type, and where the predefined integer type is implicitly selected by the implementation, so as to contain the values L to R inclusive.</s>
 <s id="619">The integer type declaration is illegal if none of the predefined integer types satisfies this requirement, excepting universal integer.</s>
 <s id="620">The elaboration of the declaration of an integer type consists of the elaboration of the equivalent type and subtype declarations.</s>
 <s id="621">The predefined integer types include the type INTEGER.</s>
 <s id="622">An implementation may also have predefined types such as SHORT_INTEGER and LONG_INTEGER, which have (substantially) shorter and longer ranges, respectively, than INTEGER.</s>
 <s id="623">The range of each of these types must be symmetric about zero, excepting an extra negative value which may exist in some implementations.</s>
 <s id="624">The base type of each of these types is the type itself.</s>
 <s id="625">Integer literals are the literals of an anonymous predefined integer type that is called universal integer in this reference manual.</s>
 <s id="626">Other integer types have no literals.</s>
 <s id="627">However, for each integer type there exists an implicit conversion that converts a universal integer value into the corresponding value (if any) of the integer type.</s>
 <s id="628">The circumstances under which these implicit conversions are invoked are described in section 4.6.</s>
 <s id="629">The position number of an integer value is the corresponding value of the type universal integer.</s>
 <s id="630">The same arithmetic operators are predefined for all integer types (see 4.5).</s>
 <s id="631">The exception NUMERIC_ERROR is raised by the execution of an operation (in particular an implicit conversion) that cannot deliver the correct result</s>
 <s id="632">(that is, if the value corresponding to the mathematical result is not a value of the integer type).</s>
 <s id="633">However, an implementation is not required to raise the exception NUMERIC_ERROR if the operation is part of a larger expression whose result can be computed correctly, as described in section 11.6.</s>
 <s id="634">The name declared by an integer type declaration is a subtype name.</s>
 <s id="635">On the other hand, the predefined operators of an integer type deliver results whose range is defined by the parent predefined type;</s>
 <s id="636">such a result need not belong to the declared subtype, in which case an attempt to assign the result to a variable of the integer subtype raises the exception CONSTRAINT_ERROR.</s>
 <s id="637">The smallest (most negative) value supported by the predefined integer types of an implementation is the named number SYSTEM.MIN_INT and the largest (most positive) value is SYSTEM.MAX_INT (see 13.7).</s>
 <s id="638">The basic operations of a discrete type include the operations involved in assignment, the membership tests, and qualification;</s>
 <s id="639">for a boolean type they include the short-circuit control forms;</s>
 <s id="640">for an integer type they include the explicit conversion of values of other numeric types to the integer type, and the implicit conversion of values of the type universal integer to the type.</s>
 <s id="641">Finally, for every discrete type or subtype T, the basic operations include the attributes listed below.</s>
 <s id="642">In this presentation, T is referred to as being a subtype (the subtype T) for any property that depends on constraints imposed by T;</s>
 <s id="643">other properties are stated in terms of the base type of T.</s>
 <s id="644">The first group of attributes yield characteristics of the subtype T.</s>
 <s id="645">This group includes the attribute BASE (see 3.3.2), the attributes FIRST and LAST (see 3.5), the representation attribute SIZE (see 13.7.2), and the attribute WIDTH defined as follows:</s>
 <s id="646">Yields the maximum image length over all values of the subtype T</s>
 <s id="647">(the image is the sequence of characters returned by the attribute IMAGE, see below).</s>
 <s id="648">Yields zero for a null range.</s>
 <s id="649">The value of this attribute is of the type universal integer.</s>
 <s id="650">All attributes of the second group are functions with a single parameter.</s>
 <s id="651">The corresponding actual parameter is indicated below by X.</s>
 <s id="652">The parameter X must be a value of the base type of T.</s>
 <s id="653">The result type is the type universal integer.</s>
 <s id="654">The result is the position number of the value of the parameter.</s>
 <s id="655">The parameter X can be of any integer type.</s>
 <s id="656">The result type is the base type of T.</s>
 <s id="657">The result is the value whose position number is the universal integer value corresponding to X.</s>
 <p id="p658">
  <s id="658.1">The exception CONSTRAINT_ERROR is raised if the universal integer value corresponding to X is not in the range T'POS(T'BASE'FIRST) ..</s>
  <s id="658.2">T'POS(T'BASE'LAST).</s>
 </p>
 <s id="659">The parameter X must be a value of the base type of T.</s>
 <s id="660">The result type is the base type of T.</s>
 <s id="661">The result is the value whose position number is one greater than that of X.</s>
 <s id="662">The exception CONSTRAINT_ERROR is raised if X equals T'BASE'LAST.</s>
 <s id="663">The parameter X must be a value of the base type of T.</s>
 <s id="664">The result type is the base type of T.</s>
 <s id="665">The result is the value whose position number is one less than that of X.</s>
 <s id="666">The exception CONSTRAINT_ERROR is raised if X equals T'BASE'FIRST.</s>
 <s id="667">The parameter X must be a value of the base type of T.</s>
 <s id="668">The result type is the predefined type STRING.</s>
 <s id="669">The result is the image of the value of X, that is, a sequence of characters representing the value in display form.</s>
 <s id="670">The image of an integer value is the corresponding decimal literal; without underlines, leading zeros, exponent, or trailing spaces; but with a single leading character that is either a minus sign or a space.</s>
 <s id="671">The lower bound of the image is one.</s>
 <s id="672">The image of an enumeration value is either the corresponding identifier in upper case or the corresponding character literal (including the two apostrophes);</s>
 <s id="673">neither leading nor trailing spaces are included.</s>
 <s id="674">The image of a character C, other than a graphic character, is implementation-defined;</s>
 <s id="675">the only requirement is that the image must be such that C equals CHARACTER'VALUE(CHARACTER'IMAGE(C)).</s>
 <s id="676">The parameter X must be a value of the predefined type STRING.</s>
 <s id="677">The result type is the base type of T.</s>
 <s id="678">Any leading and any trailing spaces of the sequence of characters that corresponds to the parameter are ignored.</s>
 <s id="679">For an enumeration type, if the sequence of characters has the syntax of an enumeration literal and if this literal exists for the base type of T, the result is the corresponding enumeration value.</s>
 <s id="680">For an integer type, if the sequence of characters has the syntax of an integer literal, with an optional single leading character that is a plus or minus sign, and if there is a corresponding value in the base type of T, the result is this value.</s>
 <s id="681">In any other case, the exception CONSTRAINT_ERROR is raised.</s>
 <s id="682">In addition, the attributes A'SIZE and A'ADDRESS are defined for an object A of a discrete type (see 13.7.2).</s>
 <s id="683">Besides the basic operations, the operations of a discrete type include the predefined relational operators.</s>
 <s id="684">For enumeration types, operations include enumeration literals.</s>
 <s id="685">For boolean types, operations include the predefined unary logical negation operator not, and the predefined logical operators.</s>
 <s id="686">For integer types, operations include the predefined arithmetic operators: these are the binary and unary adding operators - and +, all multiplying operators, the unary operator abs, and the exponentiating operator.</s>
 <s id="687">The operations of a subtype are the corresponding operations of its base type except for the following: assignment, membership tests, qualification, explicit type conversions, and the attributes of the first group;</s>
 <s id="688">the effect of each of these operations depends on the subtype</s>
 <s id="689">(assignments, membership tests, qualifications, and conversions involve a subtype check;</s>
 <s id="690">attributes of the first group yield a characteristic of the subtype).</s>
 <s id="691">For a subtype of a discrete type, the results delivered by the attributes SUCC, PRED, VAL, and VALUE need not belong to the subtype;</s>
 <s id="692">similarly, the actual parameters of the attributes POS, SUCC, PRED, and IMAGE need not belong to the subtype.</s>
 <s id="693">The following relations are satisfied (in the absence of an exception) by these attributes:</s>
 <s id="694">Real types provide approximations to the real numbers, with relative bounds on errors for floating point types, and with absolute bounds for fixed point types.</s>
 <s id="695">A set of numbers called model numbers is associated with each real type.</s>
 <s id="696">Error bounds on the predefined operations are given in terms of the model numbers.</s>
 <s id="697">An implementation of the type must include at least these model numbers and represent them exactly.</s>
 <s id="698">An implementation-dependent set of numbers, called the safe numbers, is also associated with each real type.</s>
 <s id="699">The set of safe numbers of a real type must include at least the set of model numbers of the type.</s>
 <s id="700">The range of safe numbers is allowed to be larger than the range of model numbers, but error bounds on the predefined operations for safe numbers are given by the same rules as for model numbers.</s>
 <s id="701">Safe numbers therefore provide guaranteed error bounds for operations on an implementation-dependent range of numbers;</s>
 <s id="702">in contrast, the range of model numbers depends only on the real type definition and is therefore independent of the implementation.</s>
 <s id="703">Real literals are the literals of an anonymous predefined real type that is called universal real in this reference manual.</s>
 <s id="704">Other real types have no literals.</s>
 <s id="705">However, for each real type, there exists an implicit conversion that converts a universal real value into a value of the real type.</s>
 <s id="706">The conditions under which these implicit conversions are invoked are described in section 4.6.</s>
 <s id="707">If the universal real value is a safe number, the implicit conversion delivers the corresponding value;</s>
 <s id="708">if it belongs to the range of safe numbers but is not a safe number, then the converted value can be any value within the range defined by the safe numbers next above and below the universal real value.</s>
 <s id="709">The execution of an operation that yields a value of a real type may raise the exception NUMERIC_ERROR, as explained in section 4.5.7, if it cannot deliver a correct result</s>
 <s id="710">(that is, if the value corresponding to one of the possible mathematical results does not belong to the range of safe numbers);</s>
 <s id="711">in particular, this exception can be raised by an implicit conversion.</s>
 <s id="712">However, an implementation is not required to raise the exception NUMERIC_ERROR if the operation is part of a larger expression whose result can be computed correctly (see 11.6).</s>
 <s id="713">The elaboration of a real type definition includes the elaboration of the floating or fixed point constraint and creates a real type.</s>
 <s id="714">An algorithm written to rely only upon the minimum numerical properties guaranteed by the type definition for model numbers will be portable without further precautions.</s>
 <s id="715">For floating point types, the error bound is specified as a relative precision by giving the required minimum number of significant decimal digits.</s>
 <s id="716">The minimum number of significant decimal digits is specified by the value of the static simple expression of the floating accuracy definition.</s>
 <s id="717">This value must belong to some integer type and must be positive (nonzero);</s>
 <s id="718">it is denoted by D in the remainder of this section.</s>
 <s id="719">If the floating point constraint is used as a real type definition and includes a range constraint, then each bound of the range must be defined by a static expression of some real type, but the two bounds need not have the same real type.</s>
 <s id="720">For a given radix, the following canonical form is defined for any floating point model number other than zero:</s>
 <s id="721">In this form: sign is either +1 or -1;</s>
 <s id="722">mantissa is expressed in a number base given by radix;</s>
 <s id="723">and exponent is an integer number (possibly negative) such that the integer part of mantissa is zero and the first digit of its fractional part is not a zero.</s>
 <s id="724">The specified number D is the minimum number of decimal digits required after the point in the decimal mantissa</s>
 <s id="725">(that is, if radix is ten).</s>
 <s id="726">The value of D in turn determines a corresponding number B that is the minimum number of binary digits required after the point in the binary mantissa</s>
 <s id="727">(that is, if radix is two).</s>
 <s id="728">The number B associated with D is the smallest value such that the relative precision of the binary form is no less than that specified for the decimal form.</s>
 <s id="729">(The number B is the integer next above (D*log(10)/log(2)) + 1.)</s>
 <s id="730">The model numbers defined by a floating accuracy definition comprise zero and all numbers whose binary canonical form has exactly B digits after the point in the mantissa and an exponent in the range -4*B .. +4*B.</s>
 <s id="731">The guaranteed minimum accuracy of operations of a floating point type is defined in terms of the model numbers of the floating point constraint that forms the corresponding real type definition (see 4.5.7).</s>
 <s id="732">The predefined floating point types include the type FLOAT.</s>
 <s id="733">An implementation may also have predefined types such as SHORT_FLOAT and LONG_FLOAT, which have (substantially) less and more accuracy, respectively, than FLOAT.</s>
 <s id="734">The base type of each predefined floating point type is the type itself.</s>
 <s id="735">The model numbers of each predefined floating point type are defined in terms of the number D of decimal digits returned by the attribute DIGITS (see 3.5.8).</s>
 <s id="736">For each predefined floating point type (consequently also for each type derived therefrom), a set of safe numbers is defined as follows.</s>
 <s id="737">The safe numbers have the same number B of mantissa digits as the model numbers of the type and have an exponent in the range -E .. +E where E is implementation-defined and at least equal to the 4*B of model numbers.</s>
 <s id="738">(Consequently, the safe numbers include the model numbers.)</s>
 <s id="739">The rules defining the accuracy of operations with model and safe numbers are given in section 4.5.7.</s>
 <s id="740">The safe numbers of a subtype are those of its base type.</s>
 <s id="741">A floating point type declaration of one of the two forms</s>
 <s id="742">(that is, with or without the optional range constraint indicated by the square brackets):</s>
 <s id="743">is, by definition, equivalent to the following declarations:</s>
 <s id="744">where floating point type is an anonymous type, and where the predefined floating point type is implicitly selected by the implementation so that its model numbers include the model numbers defined by D;</s>
 <p id="p745">
  <s id="745.1">furthermore, if a range L ..</s>
  <s id="745.2">R is supplied, then both L and R must belong to the range of safe numbers.</s>
 </p>
 <s id="746">The floating point declaration is illegal if none of the predefined floating point types satisfies these requirements, excepting universal real.</s>
 <s id="747">The maximum number of digits that can be specified in a floating accuracy definition is given by the system-dependent named number SYSTEM.MAX_DIGITS (see 13.7.1).</s>
 <s id="748">The elaboration of a floating point type declaration consists of the elaboration of the equivalent type and subtype declarations.</s>
 <s id="749">If a floating point constraint follows a type mark in a subtype indication, the type mark must denote a floating point type or subtype.</s>
 <s id="750">The floating point constraint is compatible with the type mark only if the number D specified in the floating accuracy definition is not greater than the corresponding number D for the type or subtype denoted by the type mark.</s>
 <s id="751">Furthermore, if the floating point constraint includes a range constraint, the floating point constraint is compatible with the type mark only if the range constraint is, itself, compatible with the type mark.</s>
 <s id="752">The elaboration of such a subtype indication includes the elaboration of the range constraint, if there is one;</s>
 <s id="753">it creates a floating point subtype whose model numbers are defined by the corresponding floating accuracy definition.</s>
 <s id="754">A value of a floating point type belongs to a floating point subtype if and only if it belongs to the range defined by the subtype.</s>
 <s id="755">The same arithmetic operators are predefined for all floating point types (see 4.5).</s>
 <s id="756">A range constraint is allowed in a floating point subtype indication, either directly after the type mark, or as part of a floating point constraint.</s>
 <s id="757">In either case the bounds of the range must belong to the base type of the type mark (see 3.5).</s>
 <s id="758">The imposition of a floating point constraint on a type mark in a subtype indication cannot reduce the allowed range of values unless it includes a range constraint</s>
 <s id="759">(the range of model numbers that correspond to the specified number of digits can be smaller than the range of numbers of the type mark).</s>
 <s id="760">A value that belongs to a floating point subtype need not be a model number of the subtype.</s>
 <s id="761">Notes on the examples:</s>
 <s id="762">The implemented accuracy for COEFFICIENT is that of a predefined type having at least 10 digits of precision.</s>
 <s id="763">Consequently the specification of 5 digits of precision for the subtype SHORT_COEFF is allowed.</s>
 <s id="764">The largest model number for the type MASS is approximately 1.27E30 and hence less than the specified upper bound (1.0E35).</s>
 <s id="765">Consequently the declaration of this type is legal only if this upper bound is in the range of the safe numbers of a predefined floating point type having at least 7 digits of precision.</s>
 <s id="766">The basic operations of a floating point type include the operations involved in assignment, membership tests, qualification, the explicit conversion of values of other numeric types to the floating point type, and the implicit conversion of values of the type universal real to the type.</s>
 <s id="767">In addition, for every floating point type or subtype T, the basic operations include the attributes listed below.</s>
 <s id="768">In this presentation, T is referred to as being a subtype (the subtype T) for any property that depends on constraints imposed by T;</s>
 <s id="769">other properties are stated in terms of the base type of T.</s>
 <s id="770">The first group of attributes yield characteristics of the subtype T.</s>
 <s id="771">The attributes of this group are the attribute BASE (see 3.3.2), the attributes FIRST and LAST (see 3.5), the representation attribute SIZE (see 13.7.2), and the following attributes:</s>
 <s id="772">Yields the number of decimal digits in the decimal mantissa of model numbers of the subtype T.</s>
 <s id="773">(This attribute yields the number D of section 3.5.7.)</s>
 <s id="774">The value of this attribute is of the type universal integer.</s>
 <s id="775">Yields the number of binary digits in the binary mantissa of model numbers of the subtype T.</s>
 <s id="776">(This attribute yields the number B of section 3.5.7.)</s>
 <s id="777">The value of this attribute is of the type universal integer.</s>
 <s id="778">Yields the absolute value of the difference between the model number 1.0 and the next model number above, for the subtype T.</s>
 <s id="779">The value of this attribute is of the type universal real.</s>
 <s id="780">Yields the largest exponent value in the binary canonical form of model numbers of the subtype T.</s>
 <s id="781">(This attribute yields the product 4*B of section 3.5.7.)</s>
 <s id="782">The value of this attribute is of the type universal integer.</s>
 <s id="783">Yields the smallest positive (nonzero) model number of the subtype T.</s>
 <s id="784">The value of this attribute is of the type universal real.</s>
 <s id="785">Yields the largest positive model number of the subtype T.</s>
 <s id="786">The value of this attribute is of the type universal real.</s>
 <s id="787">The attributes of the second group include the following attributes which yield characteristics of the safe numbers:</s>
 <s id="788">Yields the largest exponent value in the binary canonical form of safe numbers of the base type of T.</s>
 <s id="789">(This attribute yields the number E of section 3.5.7.)</s>
 <s id="790">The value of this attribute is of the type universal integer.</s>
 <s id="791">Yields the smallest positive (nonzero) safe number of the base type of T.</s>
 <s id="792">The value of this attribute is of the type universal real.</s>
 <s id="793">Yields the largest positive safe number of the base type of T.</s>
 <s id="794">The value of this attribute is of the type universal real.</s>
 <s id="795">In addition, the attributes A'SIZE and A'ADDRESS are defined for an object A of a floating point type (see 13.7.2).</s>
 <s id="796">Finally, for each floating point type there are machine-dependent attributes that are not related to model numbers and safe numbers.</s>
 <s id="797">They correspond to the attribute designators MACHINE_RADIX, MACHINE_MANTISSA, MACHINE_EMAX, MACHINE_EMIN, MACHINE_ROUNDS, and MACHINE_OVERFLOWS (see 13.7.3).</s>
 <s id="798">Besides the basic operations, the operations of a floating point type include the relational operators, and the following predefined arithmetic operators: the binary and unary adding operators - and +, the multiplying operators * and /, the unary operator abs, and the exponentiating operator.</s>
 <s id="799">The operations of a subtype are the corresponding operations of the type except for the following: assignment, membership tests, qualification, explicit conversion, and the attributes of the first group;</s>
 <s id="800">the effects of these operations are redefined in terms of the subtype.</s>
 <s id="801">The attributes EMAX, SMALL, LARGE, and EPSILON are provided for convenience; they are all related to MANTISSA by the following formulas:</s>
 <s id="802">The attribute MANTISSA, giving the number of binary digits in the mantissa, is itself related to DIGITS.</s>
 <s id="803">The following relations hold between the characteristics of the model numbers and those of the safe numbers:</s>
 <s id="804">The attributes T'FIRST and T'LAST need not yield model or safe numbers.</s>
 <s id="805">If a certain number of digits is specified in the declaration of a type or subtype T, the attribute T'DIGITS yields this number.</s>
 <s id="806">For fixed point types, the error bound is specified as an absolute value, called the delta of the fixed point type.</s>
 <s id="807">The delta is specified by the value of the static simple expression of the fixed accuracy definition.</s>
 <s id="808">This value must belong to some real type and must be positive (nonzero).</s>
 <s id="809">If the fixed point constraint is used as a real type definition, then it must include a range constraint;</s>
 <s id="810">each bound of the specified range must be defined by a static expression of some real type but the two bounds need not have the same real type.</s>
 <s id="811">If the fixed point constraint is used in a subtype indication, the range constraint is optional.</s>
 <s id="812">A canonical form is defined for any fixed point model number other than zero.</s>
 <s id="813">In this form: sign is either +1 or -1;</s>
 <s id="814">mantissa is a positive (nonzero) integer;</s>
 <s id="815">and any model number is a multiple of a certain positive real number called small, as follows:</s>
 <s id="816">For the model numbers defined by a fixed point constraint, the number small is chosen as the largest power of two that is not greater than the delta of the fixed accuracy definition.</s>
 <s id="817">Alternatively, it is possible to specify the value of small by a length clause (see 13.2), in which case model numbers are multiples of the specified value.</s>
 <s id="818">The guaranteed minimum accuracy of operations of a fixed point type is defined in terms of the model numbers of the fixed point constraint that forms the corresponding real type definition (see 4.5.7).</s>
 <s id="819">For a fixed point constraint that includes a range constraint, the model numbers comprise zero and all multiples of small whose mantissa can be expressed using exactly B binary digits, where the value of B is chosen as the smallest integer number for which each bound of the specified range is either a model number or lies at most small distant from a model number.</s>
 <s id="820">For a fixed point constraint that does not include a range constraint (this is only allowed after a type mark, in a subtype indication), the model numbers are defined by the delta of the fixed accuracy definition and by the range of the subtype denoted by the type mark.</s>
 <s id="821">An implementation must have at least one anonymous predefined fixed point type.</s>
 <s id="822">The base type of each such fixed point type is the type itself.</s>
 <s id="823">The model numbers of each predefined fixed point type comprise zero and all numbers for which mantissa (in the canonical form) has the number of binary digits returned by the attribute MANTISSA, and for which the number small has the value returned by the attribute SMALL.</s>
 <s id="824">A fixed point type declaration of the form:</s>
 <s id="825">is, by definition, equivalent to the following declarations:</s>
 <s id="826">In these declarations, fixed point type is an anonymous type, and the predefined fixed point type is implicitly selected by the implementation so that its model numbers include the model numbers defined by the fixed point constraint (that is, by D, L, and R, and possibly by a length clause specifying small).</s>
 <s id="827">The fixed point declaration is illegal if no predefined type satisfies these requirements.</s>
 <s id="828">The safe numbers of a fixed point type are the model numbers of its base type.</s>
 <s id="829">The elaboration of a fixed point type declaration consists of the elaboration of the equivalent type and subtype declarations.</s>
 <s id="830">If the fixed point constraint follows a type mark in a subtype indication, the type mark must denote a fixed point type or subtype.</s>
 <s id="831">The fixed point constraint is compatible with the type mark only if the delta specified by the fixed accuracy definition is not smaller than the delta for the type or subtype denoted by the type mark.</s>
 <s id="832">Furthermore, if the fixed point constraint includes a range constraint, the fixed point constraint is compatible with the type mark only if the range constraint is, itself, compatible with the type mark.</s>
 <s id="833">The elaboration of such a subtype indication includes the elaboration of the range constraint, if there is one;</s>
 <s id="834">it creates a fixed point subtype whose model numbers are defined by the corresponding fixed point constraint and also by the length clause specifying small, if there is one.</s>
 <s id="835">A value of a fixed point type belongs to a fixed point subtype if and only if it belongs to the range defined by the subtype.</s>
 <s id="836">The same arithmetic operators are predefined for all fixed point types (see 4.5).</s>
 <s id="837">Multiplication and division of fixed point values deliver results of an anonymous predefined fixed point type that is called universal fixed in this reference manual;</s>
 <s id="838">the accuracy of this type is arbitrarily fine.</s>
 <s id="839">The values of this type must be converted explicitly to some numeric type.</s>
 <s id="840">If S is a subtype of a fixed point type or subtype T, then the set of model numbers of S is a subset of those of T.</s>
 <s id="841">If a length clause has been given for T, then both S and T have the same value for small.</s>
 <s id="842">Otherwise, since small is a power of two, the small of S is equal to the small of T multiplied by a nonnegative power of two.</s>
 <s id="843">A range constraint is allowed in a fixed point subtype indication, either directly after the type mark, or as part of a fixed point constraint.</s>
 <s id="844">In either case the bounds of the range must belong to the base type of the type mark (see 3.5).</s>
 <s id="845">The basic operations of a fixed point type include the operations involved in assignment, membership tests, qualification, the explicit conversion of values of other numeric types to the fixed point type, and the implicit conversion of values of the type universal real to the type.</s>
 <s id="846">In addition, for every fixed point type or subtype T the basic operations include the attributes listed below.</s>
 <s id="847">In this presentation T is referred to as being a subtype (the subtype T) for any property that depends on constraints imposed by T;</s>
 <s id="848">other properties are stated in terms of the base type of T.</s>
 <s id="849">The first group of attributes yield characteristics of the subtype T.</s>
 <s id="850">The attributes of this group are the attributes BASE (see 3.3.2), the attributes FIRST and LAST (see 3.5), the representation attribute SIZE (see 13.7.2) and the following attributes:</s>
 <s id="851">Yields the value of the delta specified in the fixed accuracy definition for the subtype T.</s>
 <s id="852">The value of this attribute is of the type universal real.</s>
 <s id="853">Yields the number of binary digits in the mantissa of model numbers of the subtype T.</s>
 <s id="854">(This attribute yields the number B of section 3.5.9.)</s>
 <s id="855">The value of this attribute is of the type universal integer.</s>
 <s id="856">Yields the smallest positive (nonzero) model number of the subtype T.</s>
 <s id="857">The value of this attribute is of the type universal real.</s>
 <s id="858">Yields the largest positive model number of the subtype T.</s>
 <s id="859">The value of this attribute is of the type universal real.</s>
 <s id="860">Yields the minimum number of characters needed for the integer part of the decimal representation of any value of the subtype T, assuming that the representation does not include an exponent, but includes a one-character prefix that is either a minus sign or a space.</s>
 <s id="861">(This minimum number does not include superfluous zeros or underlines, and is at least two.)</s>
 <s id="862">The value of this attribute is of the type universal integer.</s>
 <s id="863">Yields the number of decimal digits needed after the point to accommodate the precision of the subtype T, unless the delta of the subtype T is greater than 0.1, in which case the attribute yields the value one.</s>
 <s id="864">(T'AFT is the smallest positive integer N for which (10**N)*T'DELTA is greater than or equal to one.)</s>
 <s id="865">The value of this attribute is of the type universal integer.</s>
 <s id="866">The attributes of the second group include the following attributes which yield characteristics of the safe numbers:</s>
 <s id="867">Yields the smallest positive (nonzero) safe number of the base type of T.</s>
 <s id="868">The value of this attribute is of the type universal real.</s>
 <s id="869">Yields the largest positive safe number of the base type of T.</s>
 <s id="870">The value of this attribute is of the type universal real.</s>
 <s id="871">In addition, the attributes A'SIZE and A'ADDRESS are defined for an object A of a fixed point type (see 13.7.2).</s>
 <s id="872">Finally, for each fixed point type or subtype T, there are the machine-dependent attributes T'MACHINE_ROUNDS and T'MACHINE_OVERFLOWS (see 13.7.3).</s>
 <s id="873">Besides the basic operations, the operations of a fixed point type include the relational operators, and the following predefined arithmetic operators: the binary and unary adding operators - and +, the multiplying operators * and /, and the operator abs.</s>
 <s id="874">The operations of a subtype are the corresponding operations of the type except for the following: assignment, membership tests, qualification, explicit conversion, and the attributes of the first group;</s>
 <s id="875">the effects of these operations are redefined in terms of the subtype.</s>
 <s id="876">The value of the attribute T'FORE depends only on the range of the subtype T.</s>
 <s id="877">The value of the attribute T'AFT depends only on the value of T'DELTA.</s>
 <s id="878">The following relations exist between attributes of a fixed point type:</s>
 <s id="879">An array object is a composite object consisting of components that have the same subtype.</s>
 <s id="880">The name for a component of an array uses one or more index values belonging to specified discrete types.</s>
 <s id="881">The value of an array object is a composite value consisting of the values of its components.</s>
 <s id="882">An array object is characterized by the number of indices (the dimensionality of the array), the type and position of each index, the lower and upper bounds for each index, and the type and possible constraint of the components.</s>
 <s id="883">The order of the indices is significant.</s>
 <s id="884">A one-dimensional array has a distinct component for each possible index value.</s>
 <s id="885">A multidimensional array has a distinct component for each possible sequence of index values that can be formed by selecting one value for each index position (in the given order).</s>
 <s id="886">The possible values for a given index are all the values between the lower and upper bounds, inclusive;</s>
 <s id="887">this range of values is called the index range.</s>
 <s id="888">An unconstrained array definition defines an array type.</s>
 <s id="889">For each object that has the array type, the number of indices, the type and position of each index, and the subtype of the components are as in the type definition;</s>
 <s id="890">the values of the lower and upper bounds for each index belong to the corresponding index subtype, except for null arrays as explained in section 3.6.1.</s>
 <s id="891">The index subtype for a given index position is, by definition, the subtype denoted by the type mark of the corresponding index subtype definition.</s>
 <s id="892">The compound delimiter &lt;&gt; (called a box) of an index subtype definition stands for an undefined range</s>
 <s id="893">(different objects of the type need not have the same bounds).</s>
 <s id="894">The elaboration of an unconstrained array definition creates an array type; this elaboration includes that of the component subtype indication.</s>
 <s id="895">A constrained array definition defines both an array type and a subtype of this type:</s>
 <s id="896">The array type is an implicitly declared anonymous type; this type is defined by an (implicit) unconstrained array definition, in which the component subtype indication is that of the constrained array definition, and in which the type mark of each index subtype definition denotes the subtype defined by the corresponding discrete range.</s>
 <s id="897">The array subtype is the subtype obtained by imposition of the index constraint on the array type.</s>
 <s id="898">If a constrained array definition is given for a type declaration, the simple name declared by this declaration denotes the array subtype.</s>
 <s id="899">The elaboration of a constrained array definition creates the corresponding array type and array subtype.</s>
 <s id="900">For this elaboration, the index constraint and the component subtype indication are elaborated.</s>
 <s id="901">The evaluation of each discrete range of the index constraint and the elaboration of the component subtype indication are performed in some order that is not defined by the language.</s>
 <s id="902">Examples of type declarations with unconstrained array definitions:</s>
 <s id="903">Examples of type declarations with constrained array definitions:</s>
 <s id="904">Examples of object declarations with constrained array definitions:</s>
 <s id="905">For a one-dimensional array, the rule given means that a type declaration with a constrained array definition such as</s>
 <s id="906">is equivalent (in the absence of an incorrect order dependence) to the succession of declarations</s>
 <s id="907">where index subtype and array type are both anonymous.</s>
 <s id="908">Consequently, T is the name of a subtype and all objects declared with this type mark are arrays that have the same bounds.</s>
 <s id="909">Similar transformations apply to multidimensional arrays.</s>
 <s id="910">A similar transformation applies to an object whose declaration includes a constrained array definition.</s>
 <s id="911">A consequence of this is that no two such objects have the same type.</s>
 <s id="912">An index constraint determines the range of possible values for every index of an array type, and thereby the corresponding array bounds.</s>
 <s id="913">For a discrete range used in a constrained array definition and defined by a range, an implicit conversion to the predefined type INTEGER is assumed if each bound is either a numeric literal, a named number, or an attribute, and the type of both bounds (prior to the implicit conversion) is the type universal integer.</s>
 <s id="914">Otherwise, both bounds must be of the same discrete type, other than universal integer; this type must be determinable independently of the context, but using the fact that the type must be discrete and that both bounds must have the same type.</s>
 <s id="915">These rules apply also to a discrete range used in an iteration rule (see 5.5) or in the declaration of a family of entries (see 9.5).</s>
 <s id="916">If an index constraint follows a type mark in a subtype indication, then the type or subtype denoted by the type mark must not already impose an index constraint.</s>
 <s id="917">The type mark must denote either an unconstrained array type or an access type whose designated type is such an array type.</s>
 <s id="918">In either case, the index constraint must provide a discrete range for each index of the array type and the type of each discrete range must be the same as that of the corresponding index.</s>
 <s id="919">An index constraint is compatible with the type denoted by the type mark if and only if the constraint defined by each discrete range is compatible with the corresponding index subtype.</s>
 <s id="920">If any of the discrete ranges defines a null range, any array thus constrained is a null array, having no components.</s>
 <s id="921">An array value satisfies an index constraint if at each index position the array value and the index constraint have the same index bounds.</s>
 <s id="922">(Note, however, that assignment and certain other operations on arrays involve an implicit subtype conversion.)</s>
 <s id="923">The bounds of each array object are determined as follows:</s>
 <s id="924">For a variable declared by an object declaration, the subtype indication of the corresponding object declaration must define a constrained array subtype (and, thereby, the bounds).</s>
 <s id="925">The same requirement exists for the subtype indication of a component declaration, if the type of the record component is an array type; and for the component subtype indication of an array type definition, if the type of the array components is itself an array type.</s>
 <s id="926">For a constant declared by an object declaration, the bounds of the constant are defined by the initial value if the subtype of the constant is unconstrained;</s>
 <s id="927">they are otherwise defined by this subtype</s>
 <s id="928">(in the latter case, the initial value is the result of an implicit subtype conversion).</s>
 <s id="929">The same rule applies to a generic formal parameter of mode in.</s>
 <s id="930">For an array object designated by an access value, the bounds must be defined by the allocator that creates the array object.</s>
 <s id="931">(The allocated object is constrained with the corresponding values of the bounds.)</s>
 <s id="932">For a formal parameter of a subprogram or entry, the bounds are obtained from the corresponding actual parameter.</s>
 <s id="933">(The formal parameter is constrained with the corresponding values of the bounds.)</s>
 <s id="934">For a renaming declaration and for a generic formal parameter of mode in out, the bounds are those of the renamed object or of the corresponding generic actual parameter.</s>
 <s id="935">For the elaboration of an index constraint, the discrete ranges are evaluated in some order that is not defined by the language.</s>
 <s id="936">Examples of array declarations including an index constraint:</s>
 <s id="937">Example of array declaration with a constrained array subtype:</s>
 <s id="938">Example of record type with a component that is an array:</s>
 <s id="939">The elaboration of a subtype indication consisting of a type mark followed by an index constraint checks the compatibility of the index constraint with the type mark (see 3.3.2).</s>
 <s id="940">All components of an array have the same subtype.</s>
 <s id="941">In particular, for an array of components that are one-dimensional arrays, this means that all components have the same bounds and hence the same length.</s>
 <s id="942">The basic operations of an array type include the operations involved in assignment and aggregates (unless the array type is limited), membership tests, indexed components, qualification, and explicit conversion;</s>
 <s id="943">for one-dimensional arrays the basic operations also include the operations involved in slices, and also string literals if the component type is a character type.</s>
 <s id="944">If A is an array object, an array value, or a constrained array subtype, the basic operations also include the attributes listed below.</s>
 <s id="945">These attributes are not allowed for an unconstrained array type.</s>
 <s id="946">The argument N used in the attribute designators for the N-th dimension of an array must be a static expression of type universal integer.</s>
 <s id="947">The value of N must be positive (nonzero) and no greater than the dimensionality of the array.</s>
 <s id="948">Yields the lower bound of the first index range.</s>
 <s id="949">The value of this attribute has the same type as this lower bound.</s>
 <s id="950">Yields the lower bound of the N-th index range.</s>
 <s id="951">The value of this attribute has the same type as this lower bound.</s>
 <s id="952">Yields the upper bound of the first index range.</s>
 <s id="953">The value of this attribute has the same type as this upper bound.</s>
 <s id="954">Yields the upper bound of the N-th index range.</s>
 <s id="955">The value of this attribute has the same type as this upper bound.</s>
 <p id="p956">
  <s id="956.1">Yields the first index range, that is, the range A'FIRST ..</s>
  <s id="956.2">A'LAST.</s>
 </p>
 <p id="p957">
  <s id="957.1">Yields the N-th index range, that is, the range A'FIRST(N) ..</s>
  <s id="957.2">A'LAST(N).</s>
 </p>
 <s id="958">Yields the number of values of the first index range (zero for a null range).</s>
 <s id="959">The value of this attribute is of the type universal integer.</s>
 <s id="960">Yields the number of values of the N-th index range (zero for a null range).</s>
 <s id="961">The value of this attribute is of the type universal integer.</s>
 <s id="962">In addition, the attribute T'BASE is defined for an array type or subtype T (see 3.3.3); the attribute T'SIZE is defined for an array type or subtype T, and the attributes A'SIZE and A'ADDRESS are defined for an array object A (see 13.7.2).</s>
 <s id="963">Besides the basic operations, the operations of an array type include the predefined comparison for equality and inequality, unless the array type is limited.</s>
 <s id="964">For one-dimensional arrays, the operations include catenation, unless the array type is limited;</s>
 <s id="965">if the component type is a discrete type, the operations also include all predefined relational operators;</s>
 <s id="966">if the component type is a boolean type, then the operations also include the unary logical negation operator not, and the logical operators.</s>
 <s id="967">Examples (using arrays declared in the examples of section 3.6.1):</s>
 <s id="968">The attributes A'FIRST and A'FIRST(1) yield the same value.</s>
 <s id="969">A similar relation exists for the attributes A'LAST, A'RANGE, and A'LENGTH.</s>
 <s id="970">The following relations are satisfied (except for a null array) by the above attributes if the index type is an integer type:</s>
 <s id="971">An array type is limited if its component type is limited (see 7.4.4).</s>
 <s id="972">The values of the predefined type STRING are one-dimensional arrays of the predefined type CHARACTER, indexed by values of the predefined subtype POSITIVE:</s>
 <s id="973">String literals (see 2.6 and 4.2) are basic operations applicable to the type STRING and to any other one-dimensional array type whose component type is a character type.</s>
 <s id="974">The catenation operator is a predefined operator for the type STRING and for one-dimensional array types;</s>
 <s id="975">it is represented as &amp;.</s>
 <s id="976">The relational operators &lt;, &lt;=, &gt;, and &gt;= are defined for values of these types, and correspond to lexicographic order (see 4.5.2).</s>
 <s id="977">A record object is a composite object consisting of named components.</s>
 <s id="978">The value of a record object is a composite value consisting of the values of its components.</s>
 <s id="979">Each component declaration declares a component of the record type.</s>
 <s id="980">Besides components declared by component declarations, the components of a record type include any components declared by discriminant specifications of the record type declaration.</s>
 <s id="981">The identifiers of all components of a record type must be distinct.</s>
 <s id="982">The use of a name that denotes a record component other than a discriminant is not allowed within the record type definition that declares the component.</s>
 <s id="983">A component declaration with several identifiers is equivalent to a sequence of single component declarations, as explained in section 3.2.</s>
 <s id="984">Each single component declaration declares a record component whose subtype is specified by the component subtype definition.</s>
 <s id="985">If a component declaration includes the assignment compound delimiter followed by an expression, the expression is the default expression of the record component;</s>
 <s id="986">the default expression must be of the type of the component.</s>
 <s id="987">Default expressions are not allowed for components that are of a limited type.</s>
 <s id="988">If a record type does not have a discriminant part, the same components are present in all values of the type.</s>
 <s id="989">If the component list of a record type is defined by the reserved word null and there is no discriminant part, then the record type has no components and all records of the type are null records.</s>
 <s id="990">The elaboration of a record type definition creates a record type;</s>
 <s id="991">it consists of the elaboration of any corresponding (single) component declarations, in the order in which they appear, including any component declaration in a variant part.</s>
 <s id="992">The elaboration of a component declaration consists of the elaboration of the component subtype definition.</s>
 <s id="993">For the elaboration of a component subtype definition, if the constraint does not depend on a discriminant (see 3.7.1), then the subtype indication is elaborated.</s>
 <s id="994">If, on the other hand, the constraint depends on a discriminant, then the elaboration consists of the evaluation of any included expression that is not a discriminant.</s>
 <s id="995">Examples of record type declarations:</s>
 <s id="996">Examples of record variables:</s>
 <s id="997">The default expression of a record component is implicitly evaluated by the elaboration of the declaration of a record object, in the absence of an explicit initialization (see 3.2.1).</s>
 <s id="998">If a component declaration has several identifiers, the expression is evaluated once for each such component of the object</s>
 <s id="999">(since the declaration is equivalent to a sequence of single component declarations).</s>
 <s id="1000">Unlike the components of an array, the components of a record need not be of the same type.</s>
 <s id="1001">A discriminant part specifies the discriminants of a type.</s>
 <s id="1002">A discriminant of a record is a component of the record.</s>
 <s id="1003">The type of a discriminant must be discrete.</s>
 <s id="1004">A discriminant part is only allowed in the type declaration for a record type, in a private type declaration or an incomplete type declaration (the corresponding full declaration must then declare a record type), and in the generic parameter declaration for a formal private type.</s>
 <s id="1005">A discriminant specification with several identifiers is equivalent to a sequence of single discriminant specifications, as explained in section 3.2.</s>
 <s id="1006">Each single discriminant specification declares a discriminant.</s>
 <s id="1007">If a discriminant specification includes the assignment compound delimiter followed by an expression, the expression is the default expression of the discriminant;</s>
 <s id="1008">the default expression must be of the type of the discriminant.</s>
 <s id="1009">Default expressions must be provided either for all or for none of the discriminants of a discriminant part.</s>
 <s id="1010">The use of the name of a discriminant is not allowed in default expressions of a discriminant part if the specification of the discriminant is itself given in the discriminant part.</s>
 <s id="1011">Within a record type definition the only allowed uses of the name of a discriminant of the record type are: in the default expressions for record components; in a variant part as the discriminant name; and in a component subtype definition, either as a bound in an index constraint, or to specify a discriminant value in a discriminant constraint.</s>
 <s id="1012">A discriminant name used in these component subtype definitions must appear by itself, not as part of a larger expression.</s>
 <s id="1013">Such component subtype definitions and such constraints are said to depend on a discriminant.</s>
 <s id="1014">A component is said to depend on a discriminant if it is a record component declared in a variant part, or a record component whose component subtype definition depends on a discriminant, or finally, one of the subcomponents of a component that itself depends on a discriminant.</s>
 <s id="1015">Each record value includes a value for each discriminant specified for the record type;</s>
 <s id="1016">it also includes a value for each record component that does not depend on a discriminant.</s>
 <s id="1017">The values of the discriminants determine which other component values are in the record value.</s>
 <s id="1018">Direct assignment to a discriminant of an object is not allowed;</s>
 <s id="1019">furthermore a discriminant is not allowed as an actual parameter of mode in out or out, or as a generic actual parameter of mode in out.</s>
 <s id="1020">The only allowed way to change the value of a discriminant of a variable is to assign a (complete) value to the variable itself.</s>
 <s id="1021">Similarly, an assignment to the variable itself is the only allowed way to change the constraint of one of its components, if the component subtype definition depends on a discriminant of the variable.</s>
 <s id="1022">The elaboration of a discriminant part has no other effect.</s>
 <s id="1023">A discriminant constraint is only allowed in a subtype indication, after a type mark.</s>
 <s id="1024">This type mark must denote either a type with discriminants, or an access type whose designated type is a type with discriminants.</s>
 <s id="1025">A discriminant constraint specifies the values of these discriminants.</s>
 <s id="1026">Each discriminant association associates an expression with one or more discriminants.</s>
 <s id="1027">A discriminant association is said to be named if the discriminants are specified explicitly by their names;</s>
 <s id="1028">it is otherwise said to be positional.</s>
 <s id="1029">For a positional association, the (single) discriminant is implicitly specified by position, in textual order.</s>
 <s id="1030">Named associations can be given in any order, but if both positional and named associations are used in the same discriminant constraint, then positional associations must occur first, at their normal position.</s>
 <s id="1031">Hence once a named association is used, the rest of the discriminant constraint must use only named associations.</s>
 <s id="1032">For a named discriminant association, the discriminant names must denote discriminants of the type for which the discriminant constraint is given.</s>
 <s id="1033">A discriminant association with more than one discriminant name is only allowed if the named discriminants are all of the same type.</s>
 <s id="1034">Furthermore, for each discriminant association (whether named or positional), the expression and the associated discriminants must have the same type.</s>
 <s id="1035">A discriminant constraint must provide exactly one value for each discriminant of the type.</s>
 <s id="1036">A discriminant constraint is compatible with the type denoted by a type mark, if and only if each discriminant value belongs to the subtype of the corresponding discriminant.</s>
 <s id="1037">In addition, for each subcomponent whose component subtype specification depends on a discriminant, the discriminant value is substituted for the discriminant in this component subtype specification and the compatibility of the resulting subtype indication is checked.</s>
 <s id="1038">A composite value satisfies a discriminant constraint if and only if each discriminant of the composite value has the value imposed by the discriminant constraint.</s>
 <s id="1039">The initial values of the discriminants of an object of a type with discriminants are determined as follows:</s>
 <s id="1040">For a variable declared by an object declaration, the subtype indication of the corresponding object declaration must impose a discriminant constraint unless default expressions exist for the discriminants;</s>
 <s id="1041">the discriminant values are defined either by the constraint or, in its absence, by the default expressions.</s>
 <s id="1042">The same requirement exists for the subtype indication of a component declaration, if the type of the record component has discriminants; and for the component subtype indication of an array type, if the type of the array components is a type with discriminants.</s>
 <s id="1043">For a constant declared by an object declaration, the values of the discriminants are those of the initial value if the subtype of the constant is unconstrained;</s>
 <s id="1044">they are otherwise defined by this subtype</s>
 <s id="1045">(in the latter case, an exception is raised if the initial value does not belong to this subtype).</s>
 <s id="1046">The same rule applies to a generic parameter of mode in.</s>
 <s id="1047">For an object designated by an access value, the discriminant values must be defined by the allocator that creates the object.</s>
 <s id="1048">(The allocated object is constrained with the corresponding discriminant values.)</s>
 <s id="1049">For a formal parameter of a subprogram or entry, the discriminants of the formal parameter are initialized with those of the corresponding actual parameter.</s>
 <s id="1050">(The formal parameter is constrained if the corresponding actual parameter is constrained, and in any case if the mode is in or if the subtype of the formal parameter is constrained.)</s>
 <s id="1051">For a renaming declaration and for a generic formal parameter of mode in out, the discriminants are those of the renamed object or of the corresponding generic actual parameter.</s>
 <s id="1052">For the elaboration of a discriminant constraint, the expressions given in the discriminant associations are evaluated in some order that is not defined by the language;</s>
 <s id="1053">the expression of a named association is evaluated once for each named discriminant.</s>
 <s id="1054">Examples (using types declared in the previous section): 01</s>
 <s id="1055">The above rules and the rules defining the elaboration of an object declaration (see 3.2) ensure that discriminants always have a value.</s>
 <s id="1056">In particular, if a discriminant constraint is imposed on an object declaration, each discriminant is initialized with the value specified by the constraint.</s>
 <s id="1057">Similarly, if the subtype of a component has a discriminant constraint, the discriminants of the component are correspondingly initialized.</s>
 <s id="1058">A record type with a variant part specifies alternative lists of components.</s>
 <s id="1059">Each variant defines the components for the corresponding value or values of the discriminant.</s>
 <s id="1060">Each variant starts with a list of choices which must be of the same type as the discriminant of the variant part.</s>
 <s id="1061">The type of the discriminant of a variant part must not be a generic formal type.</s>
 <s id="1062">If the subtype of the discriminant is static, then each value of this subtype must be represented once and only once in the set of choices of the variant part, and no other value is allowed.</s>
 <s id="1063">Otherwise, each value of the (base) type of the discriminant must be represented once and only once in the set of choices.</s>
 <s id="1064">The simple expressions and discrete ranges given as choices in a variant part must be static.</s>
 <s id="1065">A choice defined by a discrete range stands for all values in the corresponding range (none if a null range).</s>
 <s id="1066">The choice others is only allowed for the last variant and as its only choice;</s>
 <s id="1067">it stands for all values (possibly none) not given in the choices of previous variants.</s>
 <s id="1068">A component simple name is not allowed as a choice of a variant</s>
 <s id="1069">(although it is part of the syntax of choice).</s>
 <s id="1070">A record value contains the values of the components of a given variant if and only if the discriminant value is equal to one of the values specified by the choices of the variant.</s>
 <s id="1071">This rule applies in turn to any further variant that is, itself, included in the component list of the given variant.</s>
 <s id="1072">If the component list of a variant is specified by null, the variant has no components.</s>
 <s id="1073">Example of record type with a variant part:</s>
 <s id="1074">Examples of record subtypes:</s>
 <s id="1075">Examples of constrained record ariables:</s>
 <s id="1076">Choices with discrete values are also used in case statements and in array aggregates.</s>
 <s id="1077">Choices with component simple names are used in record aggregates.</s>
 <s id="1078">The basic operations of a record type include the operations involved in assignment and aggregates (unless the type is limited), membership tests, selection of record components, qualifications, and type conversion (for derived types)</s>
 <s id="1079">For any object A of a type with discriminants, the basic operations also include the following attribute:</s>
 <s id="1080">Yields the value TRUE if the discriminant constraint applies to the object A, or if the object is a constant</s>
 <s id="1081">(including a formal parameter or generic formal parameter of mode in);</s>
 <s id="1082">yields the value FALSE otherwise.</s>
 <s id="1083">If A is a generic formal parameter of mode in out, or if A is a formal parameter of mode in out or out and the type mark given in the corresponding parameter specification denotes an unconstrained type with discriminants, then the value of this attribute is obtained from that of the corresponding actual parameter.</s>
 <s id="1084">The value of this attri- bute is of the predefined type BOOLEAN.</s>
 <s id="1085">In addition, the attributes T'BASE and T'SIZE are defined for a record type or subtype T (see 3.3.3);</s>
 <s id="1086">the attributes A'SIZE and A'ADDRESS are defined for a record object A (see 13.7.2).</s>
 <s id="1087">Besides the basic operations, the operations of a record type include the predefined comparison for equality and inequality, unless the type is limited.</s>
 <s id="1088">A record type is limited if the type of any of its components is limited (see 7.4.2).</s>
 <s id="1089">An object declared by an object declaration is created by the elaboration of the object declaration and is denoted by a simple name or by some other form of name.</s>
 <s id="1090">In contrast, there are objects that are created by the eval- uation of allocators (see 4.8) and that have no simple name.</s>
 <s id="1091">Access to such an object is achieved by an access value returned by an allocator;</s>
 <s id="1092">the access value is said to designate the object.</s>
 <s id="1093">For each access type, there is a literal null which has a null access value designating no object at all.</s>
 <s id="1094">The null value of an access type is the default initial value of the type.</s>
 <s id="1095">Other values of an access type are obtained by evaluation of a special operation of the type called an allocator.</s>
 <s id="1096">Each such access value designates an object of the subtype defined by the subtype indication of the access type definition;</s>
 <s id="1097">this subtype is called the designated subtype;</s>
 <s id="1098">the base type of this subtype is called the designated type.</s>
 <s id="1099">The objects designated by the values of an access type form a collection implicitly associated with the type.</s>
 <s id="1100">The elaboration of an access type definition consists of the elaboration of the subtype indication and creates an access type.</s>
 <s id="1101">If an access object is constant, the constrained access value cannot be changed and always designates the same object.</s>
 <s id="1102">On the other hand, the value of the designated object need not remain the same</s>
 <s id="1103">(assignment to the designated object is allowed unless the designated type is limited).</s>
 <s id="1104">The only forms of contraint that are allowed after the name of an access type in a subtype indication are index constraints and discriminant constraints.</s>
 <s id="1105">(See sections 3.6.1 and 3.7.2 for the rules applicable to these subtype indications.)</s>
 <s id="1106">An access value belongs to a corresponding subtype of an access type either if the access value is the null value or if the value of the designated object satisfies the constraint.</s>
 <s id="1107">An access value delivered by an allocator can be assigned to several access objects.</s>
 <s id="1108">Hence it is possible for an object created by an allocator to be designated by more than one variable or constant of the access type.</s>
 <s id="1109">An access value can only designate an object created by an allocator; in particular, it cannot designate an object declared by an object declaration.</s>
 <s id="1110">If the type of the objects designated by the access values is an array type or a type with discriminants, these objects are constrained with either the array bounds or the discriminant values supplied implicitly or explicity for the corresponding allocators (see 4.8).</s>
 <s id="1111">Access values are called pointers of references in some other languages.</s>
 <s id="1112">There are no particular limitations on the designated type of an access type.</s>
 <s id="1113">In particular, the type of a component of the designated type can be another access type, or even the same access type.</s>
 <s id="1114">This permits mutually dependent and recursive access types.</s>
 <s id="1115">Their declarations require a prior incomplete (or private) type declaration for one or more types.</s>
 <s id="1116">For each incomplete type declaration, there must be a corresponding declaration of a type with the same identifier.</s>
 <s id="1117">The corresponding declaration must be either a full type declaration or the declarations of a task type.</s>
 <s id="1118">In the rest of this section, explanations are given in terms of full type declarations;</s>
 <s id="1119">the same rules apply also to declarations of task types.</s>
 <s id="1120">If the incomplete type declaration occurs immediately within either a declarative part or the visible part of a package specification, then the full type declaration must occur later and immediately within this declarative part or visible part.</s>
 <s id="1121">If the incomplete type declaration occurs immediately within private part of a package, then the full type declaration must occur later and immediately within either the private part itself, or the declarative part of the corresponding package body.</s>
 <s id="1122">A discriminant part must be given in the full type declaration if and only if one is given in the incomplete type declaration;</s>
 <s id="1123">if discriminant parts are given, then they must conform (see 6.3.1 for the conformance rules).</s>
 <s id="1124">Prior to the end of the full type declaration, the only allowed use of a name that denotes a type declared by an incomplete type declaration is as the type mark in the subtype indication of an access type definition;</s>
 <s id="1125">the only form of constraint allowed in this subtype indication is a discriminant constraint.</s>
 <s id="1126">The elaboration of an incomplete type declaration creates a type.</s>
 <s id="1127">If the incomplete type declaration has a discriminant part, this elaboration includes that of the discriminant part: in such a case, the discriminant part of the full type declaration is not elaborated.</s>
 <s id="1128">Example of a recursive type:</s>
 <s id="1129">Examples of mutually dependent access types:</s>
 <s id="1130">The basic operations of an access type include the operations involved in assignment, allocators for the access type, membership tests, qualification, explicit conversion, and the literal null.</s>
 <s id="1131">If the designated type is a type with discriminants, the basic operations include the selection of the corresponding discriminants;</s>
 <s id="1132">if the designated type is a record type, they include the selection of the corresponding components;</s>
 <s id="1133">if the designated type is an array type, they include the formation of indexed components and slices;</s>
 <s id="1134">if the designated type is a task type, they include selection of entries and entry families.</s>
 <s id="1135">Furthermore, the basic operations include the formation of a selected component with the reserved word all (see 4.1.3).</s>
 <s id="1136">If the designated type is an array type, the basic operations include the attributes that have the attribute designators FIRST, LAST, RANGE, and LENGTH (likewise, the attribute designators of the N-th dimension).</s>
 <s id="1137">The prefix of each of these attributes must be a value of the access type.</s>
 <s id="1138">These attributes yield the corresponding characteristics of the designated object (see 3.6.2).</s>
 <s id="1139">If the designated type is a task type, the basic operations include the attributes that have the attribute designators TERMINATED and CALLABLE (see 9.9).</s>
 <s id="1140">The prefix of each of these attributes must be a value of the access type.</s>
 <s id="1141">These attributes yield the corresponding characteristics of the designated task objects.</s>
 <s id="1142">In addition, the attribute T'BASE (see 3.3.3) and the representation attributes T'SIZE and T'STORAGE_SIZE (see 13.7.2) are defined for an access type or subtype T;</s>
 <s id="1143">the attributes A'SIZE and A'ADDRESS are defined for an access object A (see 13.7.2).</s>
 <s id="1144">Besides the basic operations, the operations of an access type include the predefined comparison for equality and inequality.</s>
 <s id="1145">A declarative part contains declarative items (possibly none).</s>
 <s id="1146">The elaboration of a declarative part consists of the elaboration of the declarative items, if any, in the order in which they are given in the declarative part.</s>
 <s id="1147">After its elaboration, a declarative item is said to be elaborated.</s>
 <s id="1148">Prior to the completion of its elaboration (including before the elaboration), the declarative item is not yet elaborated.</s>
 <s id="1149">For several forms of declarative item, the language rules (in particular scope and visibility rules) are such that it is either impossible or illegal to use an entity before the elaboration of the declarative item that declares this entity.</s>
 <s id="1150">For example, it is not possible to use the name of a type for an object declaration if the corresponding type declaration is not yet elaborated.</s>
 <s id="1151">In the case of bodies, the following checks are performed:</s>
 <s id="1152">For a subprogram call, a check is made that the body of the subprogram is already elaborated.</s>
 <s id="1153">For the activation of a task, a check is made that the body of the corresponding task unit is already elaborated.</s>
 <s id="1154">For the instantiation of a generic unit that has a body, a check is made that this body is already elaborated.</s>
 <s id="1155">The exception PROGRAM_ERROR is raised if any of these checks fails.</s>
 <s id="1156">If a subprogram declaration, a package declaration, a task declaration, or a generic declaration is a declarative item of a given declarative part, then the body (if there is one) of the program unit declared by the declarative item must itself be a declarative item of this declarative part (and must appear later).</s>
 <s id="1157">If the body is a body stub, then a separately compiled subunit containing the corresponding proper body is required for the program unit (see 10.2).</s>
 <s id="1158">The rules applicable to the different forms of name and expression, and to their evaluation, are given in this chapter.</s>
 <s id="1159">Names can denote declared entities, whether declared explicitly or implicitly (see 3.1).</s>
 <s id="1160">Names can also denote objects designated by access values; subcomponents and slices of objects and values; single entries, entry families, and entries in families of entries.</s>
 <s id="1161">Finally, names can denote attributes of any of the foregoing.</s>
 <s id="1162">A simple name for an entity is either the identifier associated with the entity by its declaration, or another identifier associated with the entity by a renaming declaration.</s>
 <s id="1163">Certain forms of name (indexed and selected components, slices, and attributes) include a prefix that is either a name or a function call.</s>
 <s id="1164">If the type of a prefix is an access type, then the prefix must not be a name that denotes a formal parameter of mode out or a subcomponent thereof.</s>
 <s id="1165">If the prefix of a name is a function call, then the name denotes a component, a slice, an attribute, an entry, or an entry family, either of the result of the function call, or (if the result is an access value) of the object designated by the result.</s>
 <s id="1166">A prefix is said to be appropriate for a type in either of the following cases:</s>
 <s id="1167">The type of the prefix is the type considered.</s>
 <s id="1168">The type of the prefix is an access type whose designated type is the type considered.</s>
 <s id="1169">The evaluation of a name determines the entity denoted by the name.</s>
 <s id="1170">This evaluation has no other effect for a name that is a simple name, a character literal, or an operator symbol.</s>
 <s id="1171">The evaluation of a name that has a prefix includes the evaluation of the prefix, that is, of the corresponding name or function call.</s>
 <s id="1172">If the type of the prefix is an access type, the evaluation of the prefix includes the determination of the object designated by the corresponding access value;</s>
 <s id="1173">the exception CONSTRAINT_ERROR is raised if the value of the prefix is a null access value, except in the case of the prefix of a representation attribute (see 13.7.2).</s>
 <s id="1174">Examples of simple names:</s>
 <s id="1175">An indexed component denotes either a component of an array or an entry in a family of entries.</s>
 <s id="1176">In the case of a component of an array, the prefix must be appropriate for an array type.</s>
 <s id="1177">The expressions specify the index values for the component; there must be one such expression for each index position of the array type.</s>
 <s id="1178">In the case of an entry in a family of entries, the prefix must be a name that denotes an entry family of a task object, and the expression (there must be exactly one) specifies the index value for the individual entry.</s>
 <s id="1179">Each expression must be of the type of the corresponding index.</s>
 <s id="1180">For the evaluation of an indexed component, the prefix and the expressions are evaluated in some order that is not defined by the language.</s>
 <s id="1181">The exception CONSTRAINT_ERROR is raised if an index value does not belong to the range of the corresponding index of the prefixing array or entry family.</s>
 <s id="1182">Examples of indexed components:</s>
 <s id="1183">Notes on the examples:</s>
 <s id="1184">Distinct notations are used for components of multidimensional arrays (such as BOARD) and arrays of arrays (such as PAGE).</s>
 <s id="1185">The components of an array of arrays are arrays and can therefore be indexed.</s>
 <s id="1186">Thus PAGE(10)(20) denotes the 20th component of PAGE(10).</s>
 <s id="1187">In the last example NEXT_FRAME(L) is a function call returning an access value which designates a two-dimensional array.</s>
 <s id="1188">A slice denotes a one-dimensional array formed by a sequence of consecutive components of a one-dimensional array.</s>
 <s id="1189">A slice of a variable is a variable; a slice of a constant is a constant; a slice of a value is a value.</s>
 <s id="1190">The prefix of a slice must be appropriate for a one-dimensional array type.</s>
 <s id="1191">The type of the slice is the base type of this array type.</s>
 <s id="1192">The bounds of the discrete range define those of the slice and must be of the type of the index;</s>
 <s id="1193">the slice is a null slice denoting a null array if the discrete range is a null range.</s>
 <s id="1194">For the evaluation of a name that is a slice, the prefix and the discrete range are evaluated in some order that is not defined by the language.</s>
 <s id="1195">The exception CONSTRAINT_ERROR is raised by the evaluation of a slice, other than a null slice, if any of the bounds of the discrete range does not belong to the index range of the prefixing array.</s>
 <s id="1196">(The bounds of a null slice need not belong to the subtype of the index.)</s>
 <s id="1197">Examples of slices:</s>
 <p id="p1198">
  <s id="1198.1">For a one-dimensional array A, the name A(N ..</s>
  <s id="1198.2">N) is a slice of one component;</s>
 </p>
 <s id="1199">its type is the base type of A.</s>
 <s id="1200">On the other hand, A(N) is a component of the array A and has the corresponding component type.</s>
 <s id="1201">Selected components are used to denote record components, entries, entry families, and objects designated by access values;</s>
 <s id="1202">they are also used as expanded names as described below.</s>
 <s id="1203">The following four forms of selected components are used to denote a discriminant, a record component, an entry, or an object designated by an access value:</s>
 <s id="1204">A discriminant:</s>
 <s id="1205">The selector must be a simple name denoting a discriminant of an object or value.</s>
 <s id="1206">The prefix must be appropriate for the type of this object or value.</s>
 <s id="1207">A component of a record:</s>
 <s id="1208">The selector must be a simple name denoting a component of a record object or value.</s>
 <s id="1209">The prefix must be appropriate for the type of this object or value.</s>
 <s id="1210">For a component of a variant, a check is made that the values of the discriminants are such that the record has this component.</s>
 <s id="1211">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="1212">A single entry or an entry family of a task:</s>
 <s id="1213">The selector must be a simple name denoting a single entry or an entry family of a task.</s>
 <s id="1214">The prefix must be appropriate for the type of this task.</s>
 <s id="1215">An object designated by an access value:</s>
 <s id="1216">The selector must be the reserved word all.</s>
 <s id="1217">The value of the prefix must belong to an access type.</s>
 <s id="1218">A selected component of one of the remaining two forms is called an expanded name.</s>
 <s id="1219">In each case the selector must be either a simple name, a character literal, or an operator symbol.</s>
 <s id="1220">A function call is not allowed as the prefix of an expanded name.</s>
 <s id="1221">An expanded name can denote:</s>
 <s id="1222">An entity declared in the visible part of a package:</s>
 <s id="1223">The prefix must denote the package.</s>
 <s id="1224">The selector must be the simple name, character literal, or operator symbol of the entity.</s>
 <s id="1225">An entity whose declaration occurs immediately within a named construct:</s>
 <s id="1226">The prefix must denote a construct that is either a program unit, a block statement, a loop statement, or an accept statement.</s>
 <s id="1227">In the case of an accept statement, the prefix must be either the simple name of the entry or entry family, or an expanded name ending with such a simple name</s>
 <s id="1228">(that is, no index is allowed).</s>
 <s id="1229">The selector must be the simple name, character literal, or operator symbol of an entity whose declaration occurs immediately within the construct.</s>
 <s id="1230">This form of expanded name is only allowed within the construct itself</s>
 <s id="1231">(including the body and any subunits, in the case of a program unit).</s>
 <s id="1232">A name declared by a renaming declaration is not allowed as the prefix.</s>
 <s id="1233">If the prefix is the name of a subprogram or accept statement and if there is more than one visible enclosing subprogram or accept statement of this name, the expanded name is ambiguous, independently of the selector.</s>
 <s id="1234">If, according to the visibility rules, there is at least one possible interpretation of the prefix of a selected component as the name of an enclosing subprogram or accept statement, then the only interpretations considered are those of rule (f), as expanded names</s>
 <s id="1235">(no interpretations of the prefix as a function call are then considered).</s>
 <s id="1236">The evaluation of a name that is a selected component includes the evaluation of the prefix.</s>
 <s id="1237">Examples of selected components:</s>
 <s id="1238">Examples of expanded names:</s>
 <s id="1239">For a record with components that are other records, the above rules imply that the simple name must be given at each level for the name of a subcomponent.</s>
 <s id="1240">For example, the name NEXT_CAR.OWNER.BIRTH.MONTH cannot be shortened (NEXT_CAR.OWNER.MONTH is not allowed).</s>
 <s id="1241">An attribute denotes a basic operation of an entity given by a prefix.</s>
 <s id="1242">The applicable attribute designators depend on the prefix.</s>
 <s id="1243">An attribute can be a basic operation delivering a value; alternatively it can be a function, a type, or a range.</s>
 <s id="1244">The meaning of the prefix of an attribute must be determinable independently of the attribute designator and independently of the fact that it is the prefix of an attribute.</s>
 <s id="1245">The attributes defined by the language are summarized in Annex A.</s>
 <s id="1246">In addition, an implementation may provide implementation-defined attributes; their description must be given in Appendix F.</s>
 <s id="1247">The attribute designator of any implementation-defined attribute must not be the same as that of any language-defined attribute.</s>
 <s id="1248">The evaluation of a name that is an attribute consists of the evaluation of the prefix.</s>
 <s id="1249">The attribute designators DIGITS, DELTA, and RANGE have the same identifier as a reserved word.</s>
 <s id="1250">However, no confusion is possible since an attribute designator is always preceded by an apostrophe.</s>
 <s id="1251">The only predefined attribute designators that have a universal expression are those for certain operations of array types (see 3.6.2).</s>
 <s id="1252">Examples of attributes:</s>
 <s id="1253">A literal is either a numeric literal, an enumeration literal, the literal null, or a string literal.</s>
 <s id="1254">The evaluation of a literal yields the corresponding value.</s>
 <s id="1255">Numeric literals are the literals of the types universal integer and universal real.</s>
 <s id="1256">Enumeration literals include character literals and yield values of the corresponding enumeration types.</s>
 <s id="1257">The literal null yields a null access value which designates no objects at all.</s>
 <s id="1258">A string literal is a basic operation that combines a sequence of characters into a value of a one-dimensional array of a character type;</s>
 <s id="1259">the bounds of this array are determined according to the rules for positional array aggregates (see 4.3.2).</s>
 <s id="1260">For a null string literal, the upper bound is the predecessor, as given by the PRED attribute, of the lower bound.</s>
 <s id="1261">The evaluation of a null string literal raises the exception CONSTRAINT_ERROR if the lower bound does not have a predecessor (see 3.5.5).</s>
 <s id="1262">The type of a string literal and likewise the type of the literal null must be determinable solely from the context in which this literal appears, excluding the literal itself, but using the fact that the literal null is a value of an access type, and similarly that a string literal is a value of a one-dimensional array type whose component type is a character type.</s>
 <s id="1263">The character literals corresponding to the graphic characters contained within a string literal must be visible at the place of the string literal</s>
 <s id="1264">(although these characters themselves are not used to determine the type of the string literal).</s>
 <s id="1265">An aggregate is a basic operation that combines component values into a composite value of a record or array type.</s>
 <s id="1266">Each component association associates an expression with components (possibly none).</s>
 <s id="1267">A component association is said to be named if the components are specified explicitly by choices; it is otherwise said to be positional.</s>
 <s id="1268">For a positional association, the (single) component is implicitly specified by position, in the order of the corresponding component declarations for record components, in index order for array components.</s>
 <s id="1269">Named associations can be given in any order (except for the choice others), but if both positional and named associations are used in the same aggregate, then positional associations must occur first, at their normal position.</s>
 <s id="1270">Hence once a named association is used, the rest of the aggregate must use only named associations.</s>
 <s id="1271">Aggregates containing a single component association must always be given in named notation.</s>
 <s id="1272">Specific rules concerning component associations exist for record aggregates and array aggregates.</s>
 <s id="1273">Choices in component associations have the same syntax as in variant parts (see 3.7.3).</s>
 <s id="1274">A choice that is a component simple name is only allowed in a record aggregate.</s>
 <s id="1275">For a component association, a choice that is a simple expression or a discrete range is only allowed in an array aggregate;</s>
 <s id="1276">a choice that is a simple expression specifies the component at the corresponding index value;</s>
 <s id="1277">similarly a discrete range specifies the components at the index values in the range.</s>
 <s id="1278">The choice others is only allowed in a component association if the association appears last and has this single choice; it specifies all remaining components, if any.</s>
 <s id="1279">Each component of the value defined by an aggregate must be represented once and only once in the aggregate.</s>
 <s id="1280">Hence each aggregate must be complete and a given component is not allowed to be specified by more than one choice.</s>
 <s id="1281">The type of an aggregate must be determinable solely from the context in which the aggregate appears, excluding the aggregate itself, but using the fact that this type must be composite and not limited.</s>
 <s id="1282">The type of an aggregate in turn determines the required type for each of its components.</s>
 <s id="1283">The above rule implies that the determination of the type of an aggregate cannot use any information from within the aggregate.</s>
 <s id="1284">In particular, this determination cannot use the type of the expression of a component association, or the form or the type of a choice.</s>
 <s id="1285">An aggregate can always be distinguished from an expression enclosed by parentheses: this is a consequence of the fact that named notation is required for an aggregate with a single component.</s>
 <s id="1286">If the type of an aggregate is a record type, the component names given as choices must denote components (including discriminants) of the record type.</s>
 <s id="1287">If the choice others is given as a choice of a record aggregate, it must represent at least one component.</s>
 <s id="1288">A component association with the choice others or with more than one choice is only allowed if the represented components are all of the same type.</s>
 <s id="1289">The expression of a component association must have the type of the associated record components.</s>
 <s id="1290">The value specified for a discriminant that governs a variant part must be given by a static expression</s>
 <s id="1291">(note that this value determines which dependent components must appear in the record value).</s>
 <s id="1292">For the evaluation of a record aggregate, the expressions given in the component associations are evaluated in some order that is not defined by the language.</s>
 <s id="1293">The expression of a named association is evaluated once for each associated component.</s>
 <s id="1294">A check is made that the value of each subcomponent of the aggregate belongs to the subtype of this subcomponent.</s>
 <s id="1295">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="1296">Example of a record aggregate with positional associations:</s>
 <s id="1297">Examples of record aggregates with named associations:</s>
 <s id="1298">Example of component association with several choices:</s>
 <s id="1299">For an aggregate with positional associations, discriminant values appear first since the discriminant part is given first in the record type declaration;</s>
 <s id="1300">they must be in the same order as in the discriminant part.</s>
 <s id="1301">If the type of an aggregate is a one-dimensional array type, then each choice must specify values of the index type, and the expression of each component association must be of the component type.</s>
 <s id="1302">If the type of an aggregate is a multidimensional array type, an n-dimensional aggregate is written as a one-dimensional aggregate, in which the expression specified for each component association is itself written as an (n-1)-dimensional aggregate which is called a subaggregate;</s>
 <s id="1303">the index subtype of the one-dimensional aggregate is given by the first index position of the array type.</s>
 <s id="1304">The same rule is used to write a subaggregate if it is again multidimensional, using successive index positions.</s>
 <s id="1305">A string literal is allowed in a multidimensional aggregate at the place of a one-dimensional array of a character type.</s>
 <s id="1306">In what follows, the rules concerning array aggregates are formulated in terms of one-dimensional aggregates.</s>
 <s id="1307">Apart from a final component association with the single choice others, the rest (if any) of the component associations of an array aggregate must be either all positional or all named.</s>
 <s id="1308">A named association of an array aggregate is only allowed to have a choice that is not static, or likewise a choice that is a null range, if the aggregate includes a single component association and this component association has a single choice.</s>
 <s id="1309">An others choice is static if the applicable index constraint is static.</s>
 <s id="1310">The bounds of an array aggregate that has an others choice are determined by the applicable index constraint.</s>
 <s id="1311">An others choice is only allowed if the aggregate appears in one of the following contexts</s>
 <s id="1312">(which defines the applicable index constraint):</s>
 <s id="1313">The aggregate is an actual parameter, a generic actual parameter, the result expression of a function, or the expression that follows an assignment compound delimiter.</s>
 <s id="1314">Moreover, the subtype of the corresponding formal parameter, generic formal parameter, function result, or object is a constrained array subtype.</s>
 <s id="1315">For an aggregate that appears in such a context and contains an association with an others choice, named associations are allowed for other associations only in the case of a (nongeneric) actual parameter or function result.</s>
 <s id="1316">If the aggregate is a multidimensional array, this restriction also applies to each of its subaggregates.</s>
 <s id="1317">The aggregate is the operand of a qualified expression whose type mark denotes a constrained array subtype.</s>
 <s id="1318">The aggregate is the expression of the component association of an enclosing (array or record) aggregate.</s>
 <s id="1319">Moreover, if this enclosing aggregate is a multidimensional array aggregate then it is itself in one of these three contexts.</s>
 <s id="1320">The bounds of an array aggregate that does not have an others choice are determined as follows.</s>
 <s id="1321">For an aggregate that has named associations, the bounds are determined by the smallest and largest choices given.</s>
 <s id="1322">For a positional aggregate, the lower bound is determined by the applicable index constraint if the aggregate appears in one of the contexts (a) through (c);</s>
 <s id="1323">otherwise, the lower bound is given by S'FIRST where S is the index subtype;</s>
 <s id="1324">in either case, the upper bound is determined by the number of components.</s>
 <s id="1325">The evaluation of an array aggregate that is not a subaggregate proceeds in two steps.</s>
 <s id="1326">First, the choices of this aggregate and of its subaggregates, if any, are evaluated in some order that is not defined by the language.</s>
 <s id="1327">Second, the expressions of the component associations of the array aggregate are evaluated in some order that is not defined by the language;</s>
 <s id="1328">the expression of a named association is evaluated once for each associated component.</s>
 <s id="1329">The evaluation of a subaggregate consists of this second step</s>
 <s id="1330">(the first step is omitted since the choices have already been evaluated).</s>
 <s id="1331">For the evaluation of an aggregate that is not a null array, a check is made that the index values defined by choices belong to the corresponding index subtypes, and also that the value of each subcomponent of the aggregate belongs to the subtype of this subcomponent.</s>
 <s id="1332">For an n-dimensional multidimensional aggregate, a check is made that all (n-1)-dimensional subaggregates have the same bounds.</s>
 <s id="1333">The exception CONSTRAINT_ERROR is raised if any of these checks fails.</s>
 <s id="1334">The allowed contexts for an array aggregate including an others choice are such that the bounds of such an aggregate are always known from the context.</s>
 <s id="1335">Examples of array aggregates with positional associations:</s>
 <s id="1336">Examples of array aggregates with named associations:</s>
 <s id="1337">Examples of two-dimensional array aggregates:</s>
 <s id="1338">Examples of aggregates as initial values:</s>
 <s id="1339">An expression is a formula that defines the computation of a value.</s>
 <s id="1340">Each primary has a value and a type.</s>
 <s id="1341">The only names allowed as primaries are named numbers; attributes that yield values; and names denoting objects (the value of such a primary is the value of the object) or denoting values.</s>
 <s id="1342">Names that denote formal parameters of mode out are not allowed as primaries; names of their subcomponents are only allowed in the case of discriminants.</s>
 <s id="1343">The type of an expression depends only on the type of its constituents and on the operators applied;</s>
 <s id="1344">for an overloaded constituent or operator, the determination of the constituent type, or the identification of the appropriate operator, depends on the context.</s>
 <s id="1345">For each predefined operator, the operand and result types are given in section 4.5.</s>
 <s id="1346">Examples of primaries:</s>
 <s id="1347">Examples of expressions:</s>
 <s id="1348">The language defines the following six classes of operators.</s>
 <s id="1349">The corresponding operator symbols (except /=), and only those, can be used as designators in declarations of functions for user-defined operators.</s>
 <s id="1350">They are given in the order of increasing precedence.</s>
 <s id="1351">The short-circuit control forms and then and or else have the same precedence as logical operators.</s>
 <s id="1352">The membership tests in and not in have the same precedence as relational operators.</s>
 <s id="1353">For a term, simple expression, relation, or expression, operators of higher precedence are associated with their operands before operators of lower precedence.</s>
 <s id="1354">In this case, for a sequence of operators of the same precedence level, the operators are associated in textual order from left to right;</s>
 <s id="1355">parentheses can be used to impose specific associations.</s>
 <s id="1356">The operands of a factor, of a term, of a simple expression, or of a relation, and the operands of an expression that does not contain a short-circuit control form, are evaluated in some order that is not defined by the language</s>
 <s id="1357">(but before application of the corresponding operator).</s>
 <s id="1358">The right operand of a short-circuit control form is evaluated if and only if the left operand has a certain value (see 4.5.1).</s>
 <s id="1359">For each form of type declaration, certain of the above operators are predefined, that is, they are implicitly declared by the type declaration.</s>
 <s id="1360">For each such implicit operator declaration, the names of the parameters are LEFT and RIGHT for binary operators;</s>
 <s id="1361">the single parameter is called RIGHT for unary adding operators and for the unary operators abs and not.</s>
 <s id="1362">The effect of the predefined operators is explained in subsections 4.5.1 through 4.5.7.</s>
 <s id="1363">The predefined operations on integer types either yield the mathematically correct result or raise the exception NUMERIC_ERROR.</s>
 <s id="1364">A predefined operation that delivers a result of an integer type (other than universal integer) can only raise the exception NUMERIC_ERROR if the mathematical result is not a value of the type.</s>
 <s id="1365">The predefined operations on real types yield results whose accuracy is defined in section 4.5.7.</s>
 <s id="1366">A predefined operation that delivers a result of a real type (other than universal real) can only raise the exception NUMERIC_ERROR if the result is not within the range of the safe numbers of the type, as explained in section 4.5.7.</s>
 <s id="1367">Examples of precedence:</s>
 <s id="1368">The following logical operators are predefined for any boolean type and any one-dimensional array type whose components are of a boolean type;</s>
 <s id="1369">in either case the two operands have the same type.</s>
 <s id="1370">The operations on arrays are performed on a component-by-component basis on matching components, if any (as for equality, see 4.5.2).</s>
 <s id="1371">The bounds of the resulting array are those of the left operand.</s>
 <s id="1372">A check is made that for each component of the left operand there is a matching component of the right operand, and vice versa.</s>
 <s id="1373">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="1374">The short-circuit control forms and then and or else are defined for two operands of a boolean type and deliver a result of the same type.</s>
 <s id="1375">The left operand of a short-circuit control form is always evaluated first.</s>
 <s id="1376">If the left operand of an expression with the control form and then evaluates to FALSE, the right operand is not evaluated and the value of the expression is FALSE.</s>
 <s id="1377">If the left operand of an expression with the control form or else evaluates to TRUE, the right operand is not evaluated and the value of the expression is TRUE.</s>
 <s id="1378">If both operands are evaluated, and then delivers the same result as and, and or else delivers the same result as or.</s>
 <s id="1379">The conventional meaning of the logical operators is given by the fol- lowing truth table:</s>
 <s id="1380">Examples of logical operators:</s>
 <s id="1381">Examples of short-circuit control forms:</s>
 <s id="1382">The equality and inequality operators are predefined for any type that is not limited.</s>
 <s id="1383">The other relational operators are the ordering operators &lt; (less than), &lt;= (less than or equal), &gt; (greater than), and &gt;= (greater than or equal).</s>
 <s id="1384">The ordering operators are predefined for any scalar type, and for any discrete array type, that is, a one-dimensional array type whose components are of a discrete type.</s>
 <s id="1385">The operands of each predefined relational operator have the same type.</s>
 <s id="1386">The result type is the predefined type BOOLEAN.</s>
 <s id="1387">The relational operators have their conventional meaning: the result is equal to TRUE if the corresponding relation is satisfied; the result is FALSE otherwise.</s>
 <s id="1388">The inequality operator gives the complementary result to the equality operator: FALSE if equal, TRUE if not equal.</s>
 <s id="1389">Equality for the discrete types is equality of the values.</s>
 <s id="1390">For real operands whose values are nearly equal, the results of the predefined relational operators are given in section 4.5.7.</s>
 <s id="1391">Two access values are equal either if they designate the same object, or if both are equal to the null value of the access type.</s>
 <s id="1392">For two array values or two record values of the same type, the left operand is equal to the right operand if and only if for each component of the left operand there is a matching component of the right operand and vice versa;</s>
 <s id="1393">and the values of matching components are equal, as given by the predefined equality operator for the component type.</s>
 <s id="1394">In particular, two null arrays of the same type are always equal; two null records of the same type are always equal.</s>
 <s id="1395">For comparing two records of the same type, matching components are those which have the same component identifier.</s>
 <s id="1396">For comparing two one-dimensional arrays of the same type, matching components are those (if any) whose index values match in the following sense: the lower bounds of the index ranges are defined to match, and the successors of matching indices are defined to match.</s>
 <s id="1397">For comparing two multidimensional arrays, matching components are those whose index values match in successive index positions.</s>
 <s id="1398">If equality is explicitly defined for a limited type, it does not extend to composite types having subcomponents of the limited type</s>
 <s id="1399">(explicit definition of equality is allowed for such composite types).</s>
 <s id="1400">The ordering operators &lt;, &lt;=, &gt;, and &gt;= that are defined for discrete array types correspond to lexicographic order using the predefined order relation of the component type.</s>
 <s id="1401">A null array is lexicographically less than any array having at least one component.</s>
 <s id="1402">In the case of nonnull arrays, the left operand is lexicographically less than the right operand if the first component of the left operand is less than that of the right; otherwise the left operand is lexicographically less than the right operand only if their first components are equal and the tail of the left operand is lexicographically less than that of the right</s>
 <s id="1403">(the tail consists of the remaining components beyond the first and can be null).</s>
 <s id="1404">The membership tests in and not in are predefined for all types.</s>
 <s id="1405">The result type is the predefined type BOOLEAN.</s>
 <s id="1406">For a membership test with a range, the simple expression and the bounds of the range must be of the same scalar type;</s>
 <s id="1407">for a membership test with a type mark, the type of the simple expression must be the base type of the type mark.</s>
 <s id="1408">The evaluation of the membership test in yields the result TRUE if the value of the simple expression is within the given range, or if this value belongs to the subtype denoted by the given type mark;</s>
 <s id="1409">otherwise this evaluation yields the result FALSE (for a value of a real type, see 4.5.7).</s>
 <s id="1410">The membership test not in gives the complementary result to the membership test in.</s>
 <s id="1411">No exception is ever raised by a predefined relational operator or by a membership test, but an exception can be raised by the evaluation of the operands.</s>
 <s id="1412">If a record type has components that depend on discriminants, two values of this type have matching components if and only if their discriminants are equal.</s>
 <s id="1413">Two nonnull arrays have matching components if and only if the value of the attribute LENGTH(N) for each index position N is the same for both.</s>
 <s id="1414">The binary adding operators + and - are predefined for any numeric type and have their conventional meaning.</s>
 <s id="1415">The catenation operators &amp; are predefined for any one-dimensional array type that is not limited.</s>
 <s id="1416">For real types, the accuracy of the result is determined by the operand type (see 4.5.7).</s>
 <s id="1417">If both operands are one-dimensional arrays, the result of the catenation is a one-dimensional array whose length is the sum of the lengths of its operands, and whose components comprise the components of the left operand followed by the components of the right operand.</s>
 <s id="1418">The lower bound of this result is the lower bound of the left operand, unless the left operand is a null array, in which case the result of the catenation is the right operand.</s>
 <s id="1419">If either operand is of the component type of an array type, the result of the catenation is given by the above rules, using in place of this operand an array having this operand as its only component and having the lower bound of the index subtype of the array type as its lower bound.</s>
 <s id="1420">The exception CONSTRAINT_ERROR is raised by catenation if the upper bound of the result exceeds the range of the index subtype, unless the result is a null array.</s>
 <s id="1421">This exception is also raised if any operand is of the component type but has a value that does not belong to the component subtype.</s>
 <s id="1422">The unary adding operators + and - are predefined for any numeric type and have their conventional meaning.</s>
 <s id="1423">For each of these operators, the operand and the result have the same type.</s>
 <s id="1424">The operators * and / are predefined for any integer and any floating point type and have their conventional meaning;</s>
 <s id="1425">the operators mod and rem are predefined for any integer type.</s>
 <s id="1426">For each of these operators, the operands and the result have the same base type.</s>
 <s id="1427">For floating point types, the accuracy of the result is determined by the operand type (see 4.5.7).</s>
 <s id="1428">Integer division and remainder are defined by the relation</s>
 <s id="1429">where (A rem B) has the sign of A and an absolute value less than the absolute value of B.</s>
 <s id="1430">Integer division satisfies the identity</s>
 <s id="1431">The result of the modulus operation is such that (A mod B) has the sign of B and an absolute value less than the absolute value of B; in addition, for some integer value N, this result must satisfy the relation</s>
 <s id="1432">For each fixed point type, the following multiplication and division operators, with an operand of the predefined type INTEGER, are predefined.</s>
 <s id="1433">Integer multiplication of fixed point values is equivalent to repeated addition.</s>
 <s id="1434">Division of a fixed point value by an integer does not involve a change in type but is approximate (see 4.5.7).</s>
 <s id="1435">Finally, the following multiplication and division operators are declared in the predefined package STANDARD.</s>
 <s id="1436">These two special operators apply to operands of all fixed point types</s>
 <s id="1437">(it is a consequence of other rules that they cannot be renamed or given as generic actual parameters).</s>
 <s id="1438">Multiplication of operands of the same or of different fixed point types is exact and delivers a result of the anonymous predefined fixed point type universal fixed whose delta is arbitrarily small.</s>
 <s id="1439">The result of any such multiplication must always be explicitly converted to some numeric type.</s>
 <s id="1440">This ensures explicit control of the accuracy of the computation.</s>
 <s id="1441">The same considerations apply to division of a fixed point value by another fixed point value.</s>
 <s id="1442">No other operators are defined for the type universal fixed.</s>
 <s id="1443">The exception NUMERIC_ERROR is raised by integer division, rem, and mod if the right operand is zero.</s>
 <s id="1444">For positive A and B, A/B is the quotient and A rem B is the remainder when A is divided by B.</s>
 <s id="1445">The following relations are satisfied by the rem operator:</s>
 <s id="1446">For any integer K, the following identity holds:</s>
 <s id="1447">The relations between integer division, remainder, and modulus are illustrated by the following table:</s>
 <s id="1448">The highest precedence unary operator abs is predefined for any numeric type.</s>
 <s id="1449">The highest precedence unary operator not is predefined for any boolean type and any one-dimensional array type whose components have a boolean type.</s>
 <s id="1450">The operator not that applies to a one-dimensional array of boolean components yields a one-dimensional boolean array with the same bounds;</s>
 <s id="1451">each component of the result is obtained by logical negation of the corresponding component of the operand</s>
 <s id="1452">(that is, the component that has the same index value).</s>
 <s id="1453">The highest precedence exponentiating operator ** is predefined for each integer type and for each floating point type.</s>
 <s id="1454">In either case the right operand, called the exponent, is of the predefined type INTEGER.</s>
 <s id="1455">Exponentiation with a positive exponent is equivalent to repeated multiplication of the left operand by itself, as indicated by the exponent and from left to right.</s>
 <s id="1456">For an operand of a floating point type, the exponent can be negative, in which case the value is the reciprocal of the value with the positive exponent.</s>
 <s id="1457">Exponentiation by a zero exponent delivers the value one.</s>
 <s id="1458">Exponentiation of a value of a floating point type is approximate (see 4.5.7).</s>
 <s id="1459">Exponentiation of an integer raises the exception CONSTRAINT_ERROR for a negative exponent.</s>
 <s id="1460">A real subtype specifies a set of model numbers.</s>
 <s id="1461">Both the accuracy required from any basic or predefined operation giving a real result, and the result of any predefined relation between real operands are defined in terms of these model numbers.</s>
 <s id="1462">A model interval of a subtype is any interval whose bounds are model numbers of the subtype.</s>
 <s id="1463">The model interval associated with a value that belongs to a real subtype is the smallest model interval (of the subtype) that includes the value.</s>
 <s id="1464">(The model interval associated with a model number of a subtype consists of that number only.)</s>
 <s id="1465">For any basic operation or predefined operator that yields a result of a real subtype, the required bounds on the result are given by a model interval defined as follows:</s>
 <s id="1466">The result model interval is the smallest model interval (of the result subtype) that includes the minimum and the maximum of all the values obtained by applying the (exact) mathematical operation, when each operand is given any value of the model interval (of the operand subtype) defined for the operand.</s>
 <s id="1467">The model interval of an operand that is itself the result of an operation, other than an implicit conversion, is the result model interval of this operation.</s>
 <s id="1468">The model interval of an operand whose value is obtained by implicit conversion of a universal expression is the model interval associated with this value within the operand subtype.</s>
 <s id="1469">The result model interval is undefined if the absolute value of one of the above mathematical results exceeds the largest safe number of the result type.</s>
 <s id="1470">Whenever the result model interval is undefined, it is highly desirable that the exception NUMERIC_ERROR be raised if the implementation cannot produce an actual result that is in the range of safe numbers.</s>
 <s id="1471">This is, however, not required by the language rules, in recognition of the fact that certain target machines do not permit easy detection of overflow situations.</s>
 <s id="1472">The value of the attribute MACHINE_OVERFLOWS indicates whether the target machine raises the exception NUMERIC_ERROR in overflow situations (see 13.7.3).</s>
 <s id="1473">The safe numbers of a real type are defined (see 3.5.6) as a superset of the model numbers, for which error bounds follow the same rules as for model numbers.</s>
 <s id="1474">Any definition given in this section in terms of model intervals can therefore be extended to safe intervals of safe numbers.</s>
 <s id="1475">A consequence of this extension is that an implementation is not allowed to raise the exception NUMERIC_ERROR when the result interval is a safe interval.</s>
 <s id="1476">For the result of exponentiation, the model interval defining the bounds on the result is obtained by applying the above rules to the sequence of multiplications defined by the exponent, and to the final division in the case of a negative exponent.</s>
 <s id="1477">For the result of a relation between two real operands, consider for each operand the model interval (of the operand subtype) defined for the operand;</s>
 <s id="1478">the result can be any value obtained by applying the mathematical comparison to values arbitrarily chosen in the corresponding operand model intervals.</s>
 <s id="1479">If either or both of the operand model intervals is undefined (and if neither of the operand evaluations raises an exception) then the result of the comparison is allowed to be any possible value (that is, either TRUE or FALSE).</s>
 <s id="1480">The result of a membership test is defined in terms of comparisons of the operand value with the lower and upper bounds of the given range or type mark</s>
 <s id="1481">(the usual rules apply to these comparisons).</s>
 <s id="1482">For a floating point type the numbers 15.0, 3.0, and 5.0 are always model numbers.</s>
 <s id="1483">Hence X/Y where X equals 15.0 and Y equals 3.0 yields exactly 5.0 according to the above rules.</s>
 <s id="1484">In the general case, division does not yield model numbers and in consequence one cannot assume that (1.0/X)*X = 1.0.</s>
 <s id="1485">The evaluation of an explicit type conversion evaluates the expression given as the operand, and converts the resulting value to a specified target type.</s>
 <s id="1486">Explicit type conversions are allowed between closely related types as defined below.</s>
 <s id="1487">The target type of a type conversion is the base type of the type mark.</s>
 <s id="1488">The type of the operand of a type conversion must be determinable independently of the context</s>
 <s id="1489">(in particular, independently of the target type).</s>
 <s id="1490">Furthermore, the operand of a type conversion is not allowed to be a literal null, an allocator, an aggregate, or a string literal;</s>
 <s id="1491">an expression enclosed by parentheses is allowed as the operand of a type conversion only if the expression alone is allowed.</s>
 <s id="1492">A conversion to a subtype consists of a conversion to the target type followed by a check that the result of the conversion belongs to the subtype.</s>
 <s id="1493">A conversion of an operand of a given type to the type itself is allowed.</s>
 <s id="1494">The other allowed explicit type conversions correspond to the following three cases:</s>
 <s id="1495">Numeric types</s>
 <s id="1496">The operand can be of any numeric type; the value of the operand is converted to the target type which must also be a numeric type.</s>
 <s id="1497">For conversions involving real types, the result is within the accuracy of the specified subtype (see 4.5.7).</s>
 <s id="1498">The conversion of a real value to an integer type rounds to the nearest integer;</s>
 <s id="1499">if the operand is halfway between two integers (within the accuracy of the real subtype) rounding may be either up or down.</s>
 <s id="1500">Derived types</s>
 <s id="1501">The conversion is allowed if one of the target type and the operand type is derived from the other, directly or indirectly, or if there exists a third type from which both types are derived, directly or indirectly.</s>
 <s id="1502">Array types</s>
 <s id="1503">The conversion is allowed if the operand type and the target type are array types that satisfy the following conditions: both types must have the same dimensionality;</s>
 <s id="1504">for each index position the index types must either be the same or be convertible to each other;</s>
 <s id="1505">the component types must be the same;</s>
 <s id="1506">finally, if the component type is a type with discriminants or an access type, the component subtypes must be either both constrained or both unconstrained.</s>
 <s id="1507">If the type mark denotes an unconstrained array type, then, for each index position, the bounds of the result are obtained by converting the bounds of the operand to the corresponding index type of the target type.</s>
 <s id="1508">If the type mark denotes a constrained array subtype, then the bounds of the result are those imposed by the type mark.</s>
 <s id="1509">In either case, the value of each component of the result is that of the matching component of the operand (see 4.5.2).</s>
 <s id="1510">In the case of conversions of numeric types and derived types, the exception CONSTRAINT_ERROR is raised by the evaluation of a type conversion if the result of the conversion fails to satisfy a constraint imposed by the type mark.</s>
 <s id="1511">In the case of array types, a check is made that any constraint on the component subtype is the same for the operand array type as for the target array type.</s>
 <s id="1512">If the type mark denotes an unconstrained array type and if the operand is not a null array, then, for each index position, a check is made that the bounds of the result belong to the corresponding index subtype of the target type.</s>
 <s id="1513">If the type mark denotes a constrained array subtype, a check is made that for each component of the operand there is a matching component of the target subtype, and vice versa.</s>
 <s id="1514">The exception CONSTRAINT_ERROR is raised if any of these checks fails.</s>
 <s id="1515">If a conversion is allowed from one type to another, the reverse conversion is also allowed.</s>
 <s id="1516">This reverse conversion is used where an actual parameter of mode in out or out has the form of a type conversion of a (variable) name as explained in section 6.4.1.</s>
 <s id="1517">Apart from the explicit type conversions, the only allowed form of type conversion is the implicit conversion of a value of the type universal integer or universal real into another numeric type.</s>
 <s id="1518">An implicit conversion of an operand of type universal integer to another integer type, or of an operand of type universal real to another real type, can only be applied if the operand is either a numeric literal, a named number, or an attribute;</s>
 <s id="1519">such an operand is called a convertible universal operand in this section.</s>
 <s id="1520">An implicit conversion of a convertible universal operand is applied if and only if the innermost complete context (see 8.7) determines a unique (numeric) target type for the implicit conversion, and there is no legal interpretation of this context without this conversion.</s>
 <s id="1521">The rules for implicit conversions imply that no implicit conversion is ever applied to the operand of an explicit type conversion.</s>
 <s id="1522">Similarly, implicit conversions are not applied if both operands of a predefined relational operator are convertible universal operands.</s>
 <s id="1523">The language allows implicit subtype conversions in the case of array types (see 5.2.1).</s>
 <s id="1524">An explicit type conversion can have the effect of a change of representation (in particular see 13.6).</s>
 <s id="1525">Explicit conversions are also used for actual parameters (see 6.4).</s>
 <s id="1526">Examples of numeric type conversion:</s>
 <s id="1527">Example of conversion between derived types:</s>
 <s id="1528">Examples of conversions between array types:</s>
 <s id="1529">Examples of implicit conversions:</s>
 <s id="1530">A qualified expression is used to state explicitly the type, and possibly the subtype, of an operand that is the given expression or aggregate.</s>
 <s id="1531">The operand must have the same type as the base type of the type mark.</s>
 <s id="1532">The value of a qualified expression is the value of the operand.</s>
 <s id="1533">The evaluation of a qualified expression evaluates the operand and checks that its value belongs to the subtype denoted by the type mark.</s>
 <s id="1534">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="1535">Whenever the type of an enumeration literal or aggregate is not known from the context, a qualified expression can be used to state the type explicitly.</s>
 <s id="1536">For example, an overloaded enumeration literal must be qualified in the following cases: when given as a parameter in a subprogram call to an overloaded subprogram that cannot otherwise be identified on the basis of remaining parameter or result types, in a relational expression where both operands are overloaded enumeration literals, or in an array or loop parameter range where both bounds are overloaded enumeration literals.</s>
 <s id="1537">Explicit qualification is also used to specify which one of a set of overloaded parameterless functions is meant, or to constrain a value to a given subtype.</s>
 <s id="1538">The evaluation of an allocator creates an object and yields an access value that designates the object.</s>
 <s id="1539">The type of the object created by an allocator is the base type of the type mark given in either the subtype indication or the qualified expression.</s>
 <s id="1540">For an allocator with a qualified expression, this expression defines the initial value of the created object.</s>
 <s id="1541">The type of the access value returned by an allocator must be determinable solely from the context, but using the fact that the value returned is of an access type having the named designated type.</s>
 <s id="1542">The only allowed forms of constraint in the subtype indication of an allocator are index and discriminant constraints.</s>
 <s id="1543">If an allocator includes a subtype indication and if the type of the object created is an array type or a type with discriminants that do not have default expressions, then the subtype indication must either denote a constrained subtype, or include an explicit index or discriminant constraint.</s>
 <s id="1544">If the type of the created object is an array type or a type with discriminants, then the created object is always constrained.</s>
 <s id="1545">If the allocator includes a subtype indication, the created object is constrained either by the subtype or by the default discriminant values.</s>
 <s id="1546">If the allocator includes a qualified expression, the created object is constrained by the bounds or discriminants of the initial value.</s>
 <s id="1547">For other types, the subtype of the created object is the subtype defined by the subtype indication of the access type definition.</s>
 <s id="1548">For the evaluation of an allocator, the elaboration of the subtype indication or the evaluation of the qualified expression is performed first.</s>
 <s id="1549">The new object is then created.</s>
 <s id="1550">Initializations are then performed as for a declared object (see 3.2.1); the initialization is considered explicit in the case of a qualified expression; any initializations are implicit in the case of a subtype indication.</s>
 <s id="1551">Finally, an access value that designates the created object is returned.</s>
 <s id="1552">An implementation must guarantee that any object created by the evaluation of an allocator remains allocated for as long as this object or one of its subcomponents is accessible directly or indirectly, that is, as long as it can be denoted by some name.</s>
 <s id="1553">Moreover, if an object or one of its subcomponents belongs to a task type, it is considered to be accessible as long as the task is not terminated.</s>
 <s id="1554">An implementation may (but need not) reclaim the storage occupied by an object created by an allocator, once this object has become inaccessible.</s>
 <s id="1555">When an application needs closer control over storage allocation for objects designated by values of an access type, such control may be achieved by one or more of the following means:</s>
 <s id="1556">The total amount of storage available for the collection of objects of an access type can be set by means of a length clause (see 13.2).</s>
 <s id="1557">The pragma CONTROLLED informs the implementation that automatic storage reclamation must not be performed for objects designated by values of the access type, except upon leaving the innermost block statement, subprogram body, or task body that encloses the access type declaration, or after leaving the main program.</s>
 <s id="1558">A pragma CONTROLLED for a given access type is allowed at the same places as a representation clause for the type (see 13.1).</s>
 <s id="1559">This pragma is not allowed for a derived type.</s>
 <s id="1560">The explicit deallocation of the object designated by an access value can be achieved by calling a procedure obtained by instantiation of the predefined generic library procedure UNCHECKED_DEALLOCATION (see 13.10.1).</s>
 <s id="1561">The exception STORAGE_ERROR is raised by an allocator if there is not enough storage.</s>
 <s id="1562">Note also that the exception CONSTRAINT_ERROR can be raised by the evaluation of the qualified expression, by the elaboration of the subtype indication, or by the initialization.</s>
 <s id="1563">Examples (for access types declared in section 3.8):</s>
 <s id="1564">Certain expressions of a scalar type are said to be static.</s>
 <s id="1565">Similarly, certain discrete ranges are said to be static, and the type marks of certain scalar subtypes are said to denote static subtypes.</s>
 <s id="1566">An expression of a scalar type is said to be static if and only if every primary is one of those listed in (a) through (h) below, every operator denotes a predefined operator, and the evaluation of the expression delivers a value (that is, it does not raise an exception):</s>
 <s id="1567">An enumeration literal (including a character literal).</s>
 <s id="1568">A numeric literal.</s>
 <s id="1569">A named number.</s>
 <s id="1570">A constant explicitly declared by a constant declaration with a static subtype, and initialized with a static expression.</s>
 <s id="1571">A function call whose function name is an operator symbol that denotes a predefined operator, including a function name that is an expanded name;</s>
 <s id="1572">each actual parameter must also be a static expression.</s>
 <s id="1573">A language-defined attribute of a static subtype;</s>
 <s id="1574">for an attribute that is a function, the actual parameter must also be a static expression.</s>
 <s id="1575">A qualified expression whose type mark denotes a static subtype and whose operand is a static expression.</s>
 <s id="1576">A static expression enclosed in parentheses.</s>
 <s id="1577">A static range is a range whose bounds are static expressions.</s>
 <s id="1578">A static range constraint is a range constraint whose range is static.</s>
 <s id="1579">A static subtype is either a scalar base type, other than a generic formal type; or a scalar subtype formed by imposing on a static subtype either a static range constraint, or a floating or fixed point constraint whose range constraint, if any, is static.</s>
 <s id="1580">A static discrete range is either a static subtype or a static range.</s>
 <s id="1581">A static index constraint is an index constraint for which each index subtype of the corresponding array type is static, and in which each discrete range is static.</s>
 <s id="1582">A static discriminant constraint is a discriminant constraint for which the subtype of each discriminant is static, and in which each expression is static.</s>
 <s id="1583">The accuracy of the evaluation of a static expression having a real type is defined by the rules given in section 4.5.7.</s>
 <s id="1584">If the result is not a model number (or a safe number) of the type, the value obtained by this evaluation at compilation time need not be the same as the value that would be obtained by an evaluation at run time.</s>
 <s id="1585">Array attributes are not static: in particular, the RANGE attribute is not static.</s>
 <s id="1586">A universal expression is either an expression that delivers a result of type universal integer or one that delivers a result of type universal real.</s>
 <s id="1587">The same operations are predefined for the type universal integer as for any integer type.</s>
 <s id="1588">The same operations are predefined for the type universal real as for any floating point type.</s>
 <s id="1589">In addition, these operations include the following multiplication and division operators:</s>
 <s id="1590">The accuracy of the evaluation of a universal expression of type universal real is at least as good as that of the most accurate predefined floating point type supported by the implementation, apart from universal real itself.</s>
 <s id="1591">Furthermore, if a universal expression is a static expression, then the evaluation must be exact.</s>
 <s id="1592">For the evaluation of an operation of a nonstatic universal expression, an implementation is allowed to raise the exception NUMERIC_ERROR only if the result of the operation is a real value whose absolute value exceeds the largest safe number of the most accurate predefined floating point type (excluding universal real), or an integer value greater than SYSTEM.MAX_INT or less than SYSTEM.MIN_INT.</s>
 <s id="1593">It is a consequence of the above rules that the type of a universal expression is universal integer if every primary contained in the expression is of this type (excluding actual parameters of attributes that are functions, and excluding right operands of exponentiation operators) and that otherwise the type is universal real.</s>
 <s id="1594">A statement defines an action to be performed;</s>
 <s id="1595">the process by which a statement achieves its action is called execution of the statement.</s>
 <s id="1596">This chapter describes the general rules applicable to all statements.</s>
 <s id="1597">Some specific statements are discussed in later chapters.</s>
 <s id="1598">Procedure call statements are described in Chapter 6 on subprograms.</s>
 <s id="1599">Entry call, delay, accept, select, and abort statements are described in Chapter 9 on tasks.</s>
 <s id="1600">Raise statements are described in Chapter 11 on exceptions, and code statements in Chapter 13.</s>
 <s id="1601">The remaining forms of statements are presented in this chapter.</s>
 <s id="1602">A statement is either simple or compound.</s>
 <s id="1603">A simple statement encloses no other statement.</s>
 <s id="1604">A compound statement can enclose simple statements and other compound statements.</s>
 <s id="1605">A statement is said to be labeled by the label name of any label of the statement.</s>
 <s id="1606">A label name, and similarly a loop or block name, is implicitly declared at the end of the declarative part of the innermost block statement, subprogram body, package body, task body, or generic body that encloses the labeled statement, the named loop statement, or the named block statement, as the case may be.</s>
 <s id="1607">For a block statement without a declarative part, an implicit declarative part (and preceding declare) is assumed.</s>
 <s id="1608">The implicit declarations for different label names, loop names, and block names occur in the same order as the beginnings of the corresponding labeled statements, loop statements, and block statements.</s>
 <s id="1609">Distinct identifiers must be used for all label, loop, and block names that are implicitly declared within the body of a program unit, including within block statements enclosed by this body, but excluding within other enclosed program units (a program unit is either a subprogram, a package, a task unit, or a generic unit).</s>
 <s id="1610">Execution of a null statement has no other effect than to pass to the next action.</s>
 <s id="1611">The execution of a sequence of statements consists of the execution of the individual statements in succession until the sequence is completed, or a transfer of control takes place.</s>
 <s id="1612">A transfer of control is caused either by the execution of an exit, return, or goto statement; by the selection of a terminate alternative; by the raising of an exception; or (indirectly) by the execution of an abort statement.</s>
 <s id="1613">Examples of labeled statements:</s>
 <s id="1614">The scope of a declaration starts at the place of the declaration itself (see 8.2).</s>
 <s id="1615">In the case of a label, loop, or block name, it follows from this rule that the scope of the implicit declaration starts before the first explicit occurrence of the corresponding name, since this occurrence is either in a statement label, a loop statement, a block statement, or a goto statement.</s>
 <s id="1616">An implicit declaration in a block statement may hide a declaration given in an outer program unit or block statement (according to the usual rules of hiding explained in section 8.3).</s>
 <s id="1617">An assignment statement replaces the current value of a variable with a new value specified by an expression.</s>
 <s id="1618">The named variable and the right-hand side expression must be of the same type; this type must not be a limited type.</s>
 <s id="1619">For the execution of an assignment statement, the variable name and the expression are first evaluated, in some order that is not defined by the language.</s>
 <s id="1620">A check is then made that the value of the expression belongs to the subtype of the variable, except in the case of a variable that is an array</s>
 <s id="1621">(the assignment then involves a subtype conversion as described in section 5.2.1).</s>
 <s id="1622">Finally, the value of the expression becomes the new value of the variable.</s>
 <s id="1623">The exception CONSTRAINT_ERROR is raised if the above-mentioned subtype check fails; in such a case the current value of the variable is left unchanged.</s>
 <s id="1624">If the variable is a subcomponent that depends on discriminants of an unconstrained record variable, then the execution of the assignment is erroneous if the value of any of these discriminants is changed by this execution.</s>
 <s id="1625">Examples of constraint checks:</s>
 <s id="1626">The values of the discriminants of an object designated by an access value cannot be changed (not even by assigning a complete value to the object itself) since such objects, created by allocators, are always constrained (see 4.8);</s>
 <s id="1627">however, subcomponents of such objects may be unconstrained.</s>
 <s id="1628">If the right-hand side expression is either a numeric literal or named number, or an attribute that yields a result of type universal integer or universal real, then an implicit type conversion is performed, as described in section 4.6.</s>
 <s id="1629">The determination of the type of the variable of an assignment statement may require consideration of the expression if the variable name can be interpreted as the name of a variable designated by the access value returned by a function call, and similarly, as a component or slice of such a variable</s>
 <s id="1630">(see section 8.7 for the context of overload resolution).</s>
 <s id="1631">If the variable of an assignment statement is an array variable (including a slice variable), the value of the expression is implicitly converted to the subtype of the array variable; the result of this subtype conversion becomes the new value of the array variable.</s>
 <s id="1632">This means that the new value of each component of the array variable is specified by the matching component in the array value obtained by evaluation of the expression (see 4.5.2 for the definition of matching components).</s>
 <s id="1633">The subtype conversion checks that for each component of the array variable there is a matching component in the array value, and vice versa.</s>
 <s id="1634">The exception CONSTRAINT_ERROR is raised if this check fails; in such a case the value of each component of the array variable is left unchanged.</s>
 <s id="1635">Array assignment is defined even in the case of overlapping slices, because the expression on the right-hand side is evaluated before performing any component assignment.</s>
 <p id="p1636">
  <s id="1636.1">In the above example, an implementation yielding A(1 ..</s>
  <s id="1636.2">12) = "tartartartar" would be incorrect.</s>
 </p>
 <s id="1637">The implicit subtype conversion described above for assignment to an array variable is performed only for the value of the right-hand side expression as a whole; it is not performed for subcomponents that are array values.</s>
 <s id="1638">An if statement selects for execution one or none of the enclosed sequences of statements, depending on the (truth) value of one or more corresponding conditions.</s>
 <s id="1639">An expression specifying a condition must be of a boolean type.</s>
 <s id="1640">For the execution of an if statement, the condition specified after if, and any conditions specified after elsif, are evaluated in succession (treating a final else as elsif TRUE then), until one evaluates to TRUE or all conditions are evaluated and yield FALSE.</s>
 <s id="1641">If one condition evaluates to TRUE, then the corresponding sequence of statements is executed; otherwise none of the sequences of statements is executed.</s>
 <s id="1642">A case statement selects for execution one of a number of alternative sequences of statements;</s>
 <s id="1643">the chosen alternative is defined by the value of an expression.</s>
 <s id="1644">The expression must be of a discrete type which must be determinable independently of the context in which the expression occurs, but using the fact that the expression must be of a discrete type.</s>
 <s id="1645">Moreover, the type of this expression must not be a generic formal type.</s>
 <s id="1646">Each choice in a case statement alternative must be of the same type as the expression;</s>
 <s id="1647">the list of choices specifies for which values of the expression the alternative is chosen.</s>
 <s id="1648">If the expression is the name of an object whose subtype is static, then each value of this subtype must be represented once and only once in the set of choices of the case statement, and no other value is allowed;</s>
 <s id="1649">this rule is likewise applied if the expression is a qualified expression or type conversion whose type mark denotes a static subtype.</s>
 <s id="1650">Otherwise, for other forms of expression, each value of the (base) type of the expression must be represented once and only once in the set of choices, and no other value is allowed.</s>
 <s id="1651">The simple expressions and discrete ranges given as choices in a case statement must be static.</s>
 <s id="1652">A choice defined by a discrete range stands for all values in the corresponding range (none if a null range).</s>
 <s id="1653">The choice others is only allowed for the last alternative and as its only choice; it stands for all values (possibly none) not given in the choices of previous alternatives.</s>
 <s id="1654">A component simple name is not allowed as a choice of a case statement alternative.</s>
 <s id="1655">The execution of a case statement consists of the evaluation of the expression followed by the execution of the chosen sequence of statements.</s>
 <s id="1656">The execution of a case statement chooses one and only one alternative, since the choices are exhaustive and mutually exclusive.</s>
 <s id="1657">Qualification of the expression of a case statement by a static subtype can often be used to limit the number of choices that need be given explicitly.</s>
 <s id="1658">An others choice is required in a case statement if the type of the expression is the type universal integer (for example, if the expression is an integer literal), since this is the only way to cover all values of the type universal integer.</s>
 <s id="1659">A loop statement includes a sequence of statements that is to be executed repeatedly, zero or more times.</s>
 <s id="1660">If a loop statement has a loop simple name, this simple name must be given both at the beginning and at the end.</s>
 <s id="1661">A loop statement without an iteration scheme specifies repeated execution of the sequence of statements.</s>
 <s id="1662">Execution of the loop statement is complete when the loop is left as a consequence of the execution of an exit statement, or as a consequence of some other transfer of control (see 5.1).</s>
 <s id="1663">For a loop statement with a while iteration scheme, the condition is evaluated before each execution of the sequence of statements;</s>
 <s id="1664">if the value of the condition is TRUE, the sequence of statements is executed, if FALSE the execution of the loop statement is complete.</s>
 <s id="1665">For a loop statement with a for iteration scheme, the loop parameter specification is the declaration of the loop parameter with the given identifier.</s>
 <s id="1666">The loop parameter is an object whose type is the base type of the discrete range (see 3.6.1).</s>
 <s id="1667">Within the sequence of statements, the loop parameter is a constant.</s>
 <s id="1668">Hence a loop parameter is not allowed as the (left-hand side) variable of an assignment statement.</s>
 <s id="1669">Similarly the loop parameter must not be given as an out or in out parameter of a procedure or entry call statement, or as an in out parameter of a generic instantiation.</s>
 <s id="1670">For the execution of a loop statement with a for iteration scheme, the loop parameter specification is first elaborated.</s>
 <s id="1671">This elaboration creates the loop parameter and evaluates the discrete range.</s>
 <s id="1672">If the discrete range is a null range, the execution of the loop statement is complete.</s>
 <s id="1673">Otherwise, the sequence of statements is executed once for each value of the discrete range</s>
 <s id="1674">(subject to the loop not being left as a consequence of the execution of an exit statement or as a consequence of some other transfer of control).</s>
 <s id="1675">Prior to each such iteration, the corresponding value of the discrete range is assigned to the loop parameter.</s>
 <s id="1676">These values are assigned in increasing order unless the reserved word reverse is present, in which case the values are assigned in decreasing order.</s>
 <s id="1677">Example of a loop statement without an iteration scheme:</s>
 <s id="1678">Example of a loop statement with a while iteration scheme:</s>
 <s id="1679">Example of a loop statement with a for iteration scheme:</s>
 <s id="1680">Example of a loop statement with a loop simple name:</s>
 <s id="1681">The scope of a loop parameter extends from the loop parameter specification to the end of the loop statement, and the visibility rules are such that a loop parameter is only visible within the sequence of statements of the loop.</s>
 <s id="1682">The discrete range of a for loop is evaluated just once.</s>
 <s id="1683">Use of the reserved word reverse does not alter the discrete range, so that the following iteration schemes are not equivalent; the first has a null range.</s>
 <s id="1684">Loop names are also used in exit statements, and in expanded names (in a prefix of the loop parameter).</s>
 <s id="1685">A block statement encloses a sequence of statements optionally preceded by a declarative part and optionally followed by exception handlers.</s>
 <s id="1686">If a block statement has a block simple name, this simple name must be given both at the beginning and at the end.</s>
 <s id="1687">The execution of a block statement consists of the elaboration of its declarative part (if any) followed by the execution of the sequence of statements.</s>
 <s id="1688">If the block statement has exception handlers, these service corresponding exceptions that are raised during the execution of the sequence of statements (see 11.2).</s>
 <s id="1689">If task objects are declared within a block statement whose execution is completed, the block statement is not left until all its dependent tasks are terminated (see 9.4).</s>
 <s id="1690">This rule applies also to a completion caused by an exit, return, or goto statement; or by the raising of an exception.</s>
 <s id="1691">Within a block statement, the block name can be used in expanded names denoting local entities such as SWAP.TEMP in the above example (see 4.1.3 (f)).</s>
 <s id="1692">An exit statement is used to complete the execution of an enclosing loop statement (called the loop in what follows);</s>
 <s id="1693">the completion is conditional if the exit statement includes a condition.</s>
 <s id="1694">An exit statement with a loop name is only allowed within the named loop, and applies to that loop;</s>
 <s id="1695">an exit statement without a loop name is only allowed within a loop, and applies to the innermost enclosing loop (whether named or not).</s>
 <s id="1696">Furthermore, an exit statement that applies to a given loop must not appear within a subprogram body, package body, task body, generic body, or accept statement, if this construct is itself enclosed by the given loop.</s>
 <s id="1697">For the execution of an exit statement, the condition, if present, is first evaluated.</s>
 <s id="1698">Exit from the loop then takes place if the value is TRUE or if there is no condition.</s>
 <s id="1699">Several nested loops can be exited by an exit statement that names the outer loop.</s>
 <s id="1700">A return statement is used to complete the execution of the innermost enclosing function, procedure, or accept statement.</s>
 <s id="1701">A return statement is only allowed within the body of a subprogram or generic subprogram, or within an accept statement, and applies to the innermost (enclosing) such construct;</s>
 <s id="1702">a return statement is not allowed within the body of a task unit, package, or generic package enclosed by this construct</s>
 <s id="1703">(on the other hand, it is allowed within a compound statement enclosed by this construct and, in particular, in a block statement).</s>
 <s id="1704">A return statement for an accept statement or for the body of a procedure or generic procedure must not include an expression.</s>
 <s id="1705">A return statement for the body of a function or generic function must include an expression.</s>
 <s id="1706">The value of the expression defines the result returned by the function.</s>
 <s id="1707">The type of this expression must be the base type of the type mark given after the reserved word return in the specification of the function or generic function</s>
 <s id="1708">(this type mark defines the result subtype).</s>
 <s id="1709">For the execution of a return statement, the expression (if any) is first evaluated and a check is made that the value belongs to the result subtype.</s>
 <s id="1710">The execution of the return statement is thereby completed if the check succeeds; so also is the execution of the subprogram or of the accept statement.</s>
 <s id="1711">The exception CONSTRAINT_ERROR is raised at the place of the return statement if the check fails.</s>
 <s id="1712">If the expression is either a numeric literal or named number, or an attribute that yields a result of type universal integer or universal real, then an implicit conversion of the result is performed as described in section 4.6.</s>
 <s id="1713">A goto statement specifies an explicit transfer of control from this statement to a target statement named by a label.</s>
 <s id="1714">The innermost sequence of statements that encloses the target statement must also enclose the goto statement</s>
 <s id="1715">(note that the goto statement can be a statement of an inner sequence).</s>
 <s id="1716">Furthermore, if a goto statement is enclosed by an accept statement or the body of a program unit, then the target statement must not be outside this enclosing construct; conversely, it follows from the previous rule that if the target statement is enclosed by such a construct, then the goto statement cannot be outside.</s>
 <s id="1717">The execution of a goto statement transfers control to the named target statement.</s>
 <s id="1718">The above rules allow transfer of control to a statement of an enclosing sequence of statements but not the reverse.</s>
 <s id="1719">Similarly, they prohibit transfers of control such as between alternatives of a case statement, if statement, or select statement; between exception handlers; or from an exception handler of a frame back to the sequence of statements of this frame.</s>
 <s id="1720">Subprograms are one of the four forms of program unit, of which programs can be composed.</s>
 <s id="1721">The other forms are packages, task units, and generic units.</s>
 <s id="1722">A subprogram is a program unit whose execution is invoked by a subprogram call.</s>
 <s id="1723">There are two forms of subprogram: procedures and functions.</s>
 <s id="1724">A procedure call is a statement;</s>
 <s id="1725">a function call is an expression and returns a value.</s>
 <s id="1726">The definition of a subprogram can be given in two parts: a subprogram declaration defining its calling conventions, and a subprogram body defining its execution.</s>
 <s id="1727">A subprogram declaration declares a procedure or a function, as indicated by the initial reserved word.</s>
 <s id="1728">The specification of a procedure specifies its identifier and its formal parameters (if any).</s>
 <s id="1729">The specification of a function specifies its designator, its formal parameters (if any) and the subtype of the returned value (the result subtype).</s>
 <s id="1730">A designator that is an operator symbol is used for the overloading of an operator.</s>
 <s id="1731">The sequence of characters represented by an operator symbol must be an operator belonging to one of the six classes of overloadable operators defined in section 4.5</s>
 <s id="1732">(extra spaces are not allowed and the case of letters is not significant).</s>
 <s id="1733">A parameter specification with several identifiers is equivalent to a sequence of single parameter specifications, as explained in section 3.2.</s>
 <s id="1734">Each single parameter specification declares a formal parameter.</s>
 <s id="1735">If no mode is explicitly given, the mode in is assumed.</s>
 <s id="1736">If a parameter specification ends with an expression, the expression is the default expression of the formal parameter.</s>
 <s id="1737">A default expression is only allowed in a parameter specification if the mode is in</s>
 <s id="1738">(whether this mode is indicated explicitly or implicitly).</s>
 <s id="1739">The type of a default expression must be that of the corresponding formal parameter.</s>
 <s id="1740">The use of a name that denotes a formal parameter is not allowed in default expressions of a formal part if the specification of the parameter is itself given in this formal part.</s>
 <s id="1741">The elaboration of a subprogram declaration elaborates the corresponding formal part.</s>
 <s id="1742">The elaboration of a formal part has no other effect.</s>
 <s id="1743">Examples of subprogram declarations:</s>
 <s id="1744">Examples of in parameters with default expressions:</s>
 <s id="1745">The evaluation of default expressions is caused by certain subprogram calls, as described in section 6.4.2</s>
 <s id="1746">(default expressions are not evaluated during the elaboration of the subprogram declaration).</s>
 <s id="1747">All subprograms can be called recursively and are reentrant.</s>
 <s id="1748">The value of an object is said to be read when this value is evaluated;</s>
 <s id="1749">it is also said to be read when one of its subcomponents is read.</s>
 <s id="1750">The value of a variable is said to be updated when an assignment is performed to the variable, and also (indirectly) when the variable is used as actual parameter of a subprogram call or entry call statement that updates its value;</s>
 <s id="1751">it is also said to be updated when one of its subcomponents is updated.</s>
 <s id="1752">A formal parameter of a subprogram has one of the three following modes:</s>
 <s id="1753">The formal parameter is a constant and permits only reading of the value of the associated actual parameter.</s>
 <s id="1754">The formal parameter is a variable and permits both reading and updating of the value of the associated actual parameter.</s>
 <s id="1755">The formal parameter is a variable and permits updating of the value of the associated actual parameter.</s>
 <s id="1756">The value of a scalar parameter that is not updated by the call is undefined upon return;</s>
 <s id="1757">the same holds for the value of a scalar subcomponent, other than a discriminant.</s>
 <s id="1758">Reading the bounds and discriminants of the formal parameter and of its subcomponents is allowed, but no other reading.</s>
 <s id="1759">For a scalar parameter, the above effects are achieved by copy: at the start of each call, if the mode is in or in out, the value of the actual parameter is copied into the associated formal parameter;</s>
 <s id="1760">then after normal completion of the subprogram body, if the mode is in out or out, the value of the formal parameter is copied back into the associated actual parameter.</s>
 <s id="1761">For a parameter whose type is an access type, copy-in is used for all three modes, and copy-back for the modes in out and out.</s>
 <s id="1762">For a parameter whose type is an array, record, or task type, an implementation may likewise achieve the above effects by copy, as for scalar types.</s>
 <s id="1763">In addition, if copy is used for a parameter of mode out, then copy-in is required at least for the bounds and discriminants of the actual parameter and of its subcomponents, and also for each subcomponent whose type is an access type.</s>
 <s id="1764">Alternatively, an implementation may achieve these effects by reference, that is, by arranging that every use of the formal parameter (to read or to update its value) be treated as a use of the associated actual parameter, throughout the execution of the subprogram call.</s>
 <s id="1765">The language does not define which of these two mechanisms is to be adopted for parameter passing, nor whether different calls to the same subprogram are to use the same mechanism.</s>
 <s id="1766">The execution of a program is erroneous if its effect depends on which mechanism is selected by the implementation.</s>
 <s id="1767">For a parameter whose type is a private type, the above effects are achieved according to the rule that applies to the corresponding full type declaration.</s>
 <s id="1768">Within the body of a subprogram, a formal parameter is subject to any constraint resulting from the type mark given in its parameter specification.</s>
 <s id="1769">For a formal parameter of an unconstrained array type, the bounds are obtained from the actual parameter, and the formal parameter is constrained by these bounds (see 3.6.1).</s>
 <s id="1770">For a formal parameter whose declaration specifies an unconstrained (private or record) type with discriminants, the discriminants of the formal parameter are initialized with the values of the corresponding discriminants of the actual parameter;</s>
 <s id="1771">the formal parameter is unconstrained if and only if the mode is in out or out and the variable name given for the actual parameter denotes an unconstrained variable (see 3.7.1 and 6.4.1).</s>
 <s id="1772">If the actual parameter of a subprogram call is a subcomponent that depends on discriminants of an unconstrained record variable, then the execution of the call is erroneous if the value of any of the discriminants of the variable is changed by this execution;</s>
 <s id="1773">this rule does not apply if the mode is in and the type of the subcomponent is a scalar type or an access type.</s>
 <s id="1774">For parameters of array and record types, the parameter passing rules have these consequences:</s>
 <s id="1775">If the execution of a subprogram is abandoned as a result of an exception, the final value of an actual parameter of such a type can be either its value before the call or a value assigned to the formal parameter during the execution of the subprogram.</s>
 <s id="1776">If no actual parameter of such a type is accessible by more than one path, then the effect of a subprogram call (unless abandoned) is the same whether or not the implementation uses copying for parameter passing.</s>
 <s id="1777">If, however, there are multiple access paths to such a parameter</s>
 <s id="1778">(for example, if a global variable, or another formal parameter, refers to the same actual parameter),</s>
 <s id="1779">then the value of the formal is undefined after updating the actual other than by updating the formal.</s>
 <s id="1780">A program using such an undefined value is erroneous.</s>
 <s id="1781">The same parameter modes are defined for formal parameters of entries (see 9.5) with the same meaning as for subprograms.</s>
 <s id="1782">Different parameter modes are defined for generic formal parameters (see 12.1.1).</s>
 <s id="1783">For all modes, if an actual parameter designates a task, the associated formal parameter designates the same task;</s>
 <s id="1784">the same holds for a subcomponent of an actual parameter and the corresponding subcomponent of the associated formal parameter.</s>
 <s id="1785">A subprogram body specifies the execution of a subprogram.</s>
 <s id="1786">The declaration of a subprogram is optional.</s>
 <s id="1787">In the absence of such a declaration, the subprogram specification of the subprogram body (or body stub) acts as the declaration.</s>
 <s id="1788">For each subprogram declaration, there must be a corresponding body</s>
 <s id="1789">(except for a subprogram written in another language, as explained in section 13.9).</s>
 <s id="1790">If both a declaration and a body are given, the subprogram specification of the body must conform to the subprogram specification of the declaration (see section 6.3.1 for conformance rules).</s>
 <s id="1791">If a designator appears at the end of a subprogram body, it must repeat the designator of the subprogram specification.</s>
 <s id="1792">The elaboration of a subprogram body has no other effect than to establish that the body can from then on be used for the execution of calls of the subprogram.</s>
 <s id="1793">The execution of a subprogram body is invoked by a subprogram call (see 6.4).</s>
 <s id="1794">For this execution, after establishing the association between formal parameters and actual parameters, the declarative part of the body is elaborated, and the sequence of statements of the body is then executed.</s>
 <s id="1795">Upon completion of the body, return is made to the caller</s>
 <s id="1796">(and any necessary copying back of formal to actual parameters occurs (see 6.2)).</s>
 <s id="1797">The optional exception handlers at the end of a subprogram body handle exceptions raised during the execution of the sequence of statements of the subprogram body (see 11.4).</s>
 <s id="1798">It follows from the visibility rules that if a subprogram declared in a package is to be visible outside the package, a subprogram specification must be given in the visible part of the package.</s>
 <s id="1799">The same rules dictate that a subprogram declaration must be given if a call of the subprogram occurs textually before the subprogram body</s>
 <s id="1800">(the declaration must then occur earlier than the call in the program text).</s>
 <s id="1801">The rules given in sections 3.9 and 7.1 imply that a subprogram declaration and the corresponding body must both occur immediately within the same declarative region.</s>
 <s id="1802">Example of subprogram body:</s>
 <s id="1803">Whenever the language rules require or allow the specification of a given subprogram to be provided in more than one place, the following variations are allowed at each place:</s>
 <s id="1804">A numeric literal can be replaced by a different numeric literal if and only if both have the same value.</s>
 <s id="1805">A simple name can be replaced by an expanded name in which this simple name is the selector, if and only if at both places the meaning of the simple name is given by the same declaration.</s>
 <s id="1806">A string literal given as an operator symbol can be replaced by a different string literal if and only if both represent the same operator.</s>
 <s id="1807">Two subprogram specifications are said to conform if, apart from comments and the above allowed variations, both specifications are formed by the same sequence of lexical elements, and corresponding lexical elements are given the same meaning by the visibility and overloading rules.</s>
 <s id="1808">Conformance is likewise defined for formal parts, discriminant parts, and type marks</s>
 <s id="1809">(for deferred constants and for actual parameters that have the form of a type conversion (see 6.4.1)).</s>
 <s id="1810">A simple name can be replaced by an expanded name even if the simple name is itself the prefix of a selected component.</s>
 <s id="1811">For example, Q.R can be replaced by P.Q.R if Q is declared immediately within P.</s>
 <s id="1812">The following specifications do not conform since they are not formed by the same sequence of lexical elements:</s>
 <s id="1813">The pragma INLINE is used to indicate that inline expansion of the subprogram body is desired for every call of each of the named subprograms.</s>
 <s id="1814">The form of this pragma is as follows:</s>
 <s id="1815">Each name is either the name of a subprogram or the name of a generic subprogram.</s>
 <s id="1816">The pragma INLINE is only allowed at the place of a declarative item in a declarative part or package specification, or after a library unit in a compilation, but before any subsequent compilation unit.</s>
 <s id="1817">If the pragma appears at the place of a declarative item, each name must denote a subprogram or a generic subprogram declared by an earlier declarative item of the same declarative part or package specification.</s>
 <s id="1818">If several (overloaded) subprograms satisfy this requirement, the pragma applies to all of them.</s>
 <s id="1819">If the pragma appears after a given library unit, the only name allowed is the name of this unit.</s>
 <s id="1820">If the name of a generic subprogram is mentioned in the pragma, this indicates that inline expansion is desired for calls of all subprograms obtained by instantiation of the named generic unit.</s>
 <s id="1821">The meaning of a subprogram is not changed by the pragma INLINE.</s>
 <s id="1822">For each call of the named subprograms, an implementation is free to follow or to ignore the recommendation expressed by the pragma.</s>
 <s id="1823">(Note, in particular, that the recommendation cannot generally be followed for a recursive subprogram.)</s>
 <s id="1824">A subprogram call is either a procedure call statement or a function call;</s>
 <s id="1825">it invokes the execution of the corresponding subprogram body.</s>
 <s id="1826">The call specifies the association of the actual parameters, if any, with formal parameters of the subprogram.</s>
 <s id="1827">Each parameter association associates an actual parameter with a corresponding formal parameter.</s>
 <s id="1828">A parameter association is said to be named if the formal parameter is named explicitly; it is otherwise said to be positional.</s>
 <s id="1829">For a positional association, the actual parameter corresponds to the formal parameter with the same position in the formal part.</s>
 <s id="1830">Named associations can be given in any order, but if both positional and named associations are used in the same call, positional associations must occur first, at their normal position.</s>
 <s id="1831">Hence once a named association is used, the rest of the call must use only named associations.</s>
 <s id="1832">For each formal parameter of a subprogram, a subprogram call must specify exactly one corresponding actual parameter.</s>
 <s id="1833">This actual parameter is specified either explicitly, by a parameter association, or, in the absence of such an association, by a default expression (see 6.4.2).</s>
 <s id="1834">The parameter associations of a subprogram call are evaluated in some order that is not defined by the language.</s>
 <s id="1835">Similarly, the language rules do not define in which order the values of in out or out parameters are copied back into the corresponding actual parameters (when this is done).</s>
 <s id="1836">Examples of procedure calls:</s>
 <s id="1837">Examples of function calls:</s>
 <s id="1838">Each actual parameter must have the same type as the corresponding formal parameter.</s>
 <s id="1839">An actual parameter associated with a formal parameter of mode in must be an expression;</s>
 <s id="1840">it is evaluated before the call.</s>
 <s id="1841">An actual parameter associated with a formal parameter of mode in out or out must be either the name of a variable, or of the form of a type conversion whose argument is the name of a variable.</s>
 <s id="1842">In either case, for the mode in out, the variable must not be a formal parameter of mode out or a subcomponent thereof.</s>
 <s id="1843">For an actual parameter that has the form of a type conversion, the type mark must conform (see 6.3.1) to the type mark of he formal parameter;</s>
 <s id="1844">the allowed operand and target types are the same as for type conversions (see 4.6).</s>
 <s id="1845">The variable name given for an actual parameter of mode in out or out is evaluated before the call.</s>
 <s id="1846">If the actual parameter has the form of a type conversion, then before the call, for a parameter of mode in out, the variable is converted to the specified type;</s>
 <s id="1847">after (normal) completion of the subprogram body, for a parameter of mode in out or out, the formal parameter is converted back to the type of the variable.</s>
 <s id="1848">(The type specified in the conversion must be that of the formal parameter.)</s>
 <s id="1849">The following constraint checks are performed for parameters of scalar and access types:</s>
 <s id="1850">Before the call: for a parameter of mode in or in out, it is checked that the value of the actual parameter belongs to the subtype of the formal parameter.</s>
 <s id="1851">After (normal) completion of the subprogram body: for a parameter of mode in out or out, it is checked that the value of the formal parameter belongs to the subtype of the actual variable.</s>
 <s id="1852">In the case of a type conversion, the value of the formal parameter is converted back and the check applies to the result of the conversion.</s>
 <s id="1853">In each of the above cases, the execution of the program is erroneous if the checked value is undefined.</s>
 <s id="1854">For other types, for all modes, a check is made before the call as for scalar and access types;</s>
 <s id="1855">no check is made upon return.</s>
 <s id="1856">The exception CONSTRAINT_ERROR is raised at the place of the subprogram call if either of these checks fails.</s>
 <s id="1857">For array types and for types with discriminants, the check before the call is sufficient (a check upon return would be redundant) if the type mark of the formal parameter denotes a constrained subtype, since neither array bounds nor discriminants can then vary.</s>
 <s id="1858">If this type mark denotes an unconstrained array type, the formal parameter is constrained with the bounds of the corresponding actual parameter and no check (neither before the call nor upon return) is needed (see 3.6.1).</s>
 <s id="1859">Similarly, no check is needed if the type mark denotes an unconstrained type with discriminants, since the formal parameter is then constrained exactly as the corresponding actual parameter (see 3.7.1).</s>
 <s id="1860">If a parameter specification includes a default expression for a parameter of mode in, then corresponding subprogram calls need not include a parameter association for the parameter.</s>
 <s id="1861">If a parameter association is thus omitted from a call, then the rest of the call, following any initial positional associations, must use only named associations.</s>
 <s id="1862">For any omitted parameter association, the default expression is evaluated before the call and the resulting value is used as an implicit actual parameter.</s>
 <s id="1863">Examples of procedures with default values:</s>
 <s id="1864">Examples of their calls:</s>
 <s id="1865">If a default expression is used for two or more parameters in a multiple parameter specification, the default expression is evaluated once for each omitted parameter.</s>
 <s id="1866">Hence in the above examples, the two calls of PAIR are equivalent.</s>
 <s id="1867">A function is a subprogram that returns a value (the result of the function call).</s>
 <s id="1868">The specification of a function starts with the reserved word function, and the parameters, if any, must have the mode in</s>
 <s id="1869">(whether this mode is specified explicitly or implicitly).</s>
 <s id="1870">The statements of the function body (excluding statements of program units that are inner to the function body) must include one or more return statements specifying the returned value.</s>
 <s id="1871">The exception PROGRAM_ERROR is raised if a function body is left otherwise than by a return statement.</s>
 <s id="1872">This does not apply if the execution of the function is abandoned as a result of an exception.</s>
 <s id="1873">Two formal parts are said to have the same parameter type profile if and only if they have the same number of parameters, and at each parameter position corresponding parameters have the same base type.</s>
 <s id="1874">A subprogram or entry has the same parameter and result type profile as another subprogram or entry if and only if both have the same parameter type profile, and either both are functions with the same result base type, or neither of the two is a function.</s>
 <s id="1875">The same subprogram identifier or operator symbol can be used in several subprogram specifications.</s>
 <s id="1876">The identifier or operator symbol is then said to be overloaded;</s>
 <s id="1877">the subprograms that have this identifier or operator symbol are also said to be overloaded and to overload each other.</s>
 <s id="1878">As explained in section 8.3, if two subprograms overload each other, one of them can hide the other only if both subprograms have the same parameter and result type profile</s>
 <s id="1879">(see section 8.3 for the other requirements that must be met for hiding).</s>
 <s id="1880">A call to an overloaded subprogram is ambiguous (and therefore illegal) if the name of the subprogram, the number of parameter associations, the types and the order of the actual parameters, the names of the formal parameters (if named associations are used), and the result type (for functions) are not sufficient to determine exactly one (overloaded) subprogram specification.</s>
 <s id="1881">Examples of overloaded subprograms:</s>
 <s id="1882">Examples of calls:</s>
 <s id="1883">The notion of parameter and result type profile does not include parameter names, parameter modes, parameter subtypes, default expressions and their presence or absence.</s>
 <s id="1884">Ambiguities may (but need not) arise when actual parameters of the call of an overloaded subprogram are themselves overloaded function calls, literals, or aggregates.</s>
 <s id="1885">Ambiguities may also (but need not) arise when several overloaded subprograms belonging to different packages are visible.</s>
 <s id="1886">These ambiguities can usually be resolved in several ways: qualified expressions can be used for some or all actual parameters, and for the result, if any;</s>
 <s id="1887">the name of the subprogram can be expressed more explicitly as an expanded name;</s>
 <s id="1888">finally, the subprogram can be renamed.</s>
 <s id="1889">The declaration of a function whose designator is an operator symbol is used to overload an operator.</s>
 <s id="1890">The sequence of characters of the operator symbol must be either a logical, a relational, a binary adding, a unary adding, a multiplying, or a highest precedence operator (see 4.5).</s>
 <s id="1891">Neither membership tests nor the short-circuit control forms are allowed as function designators.</s>
 <s id="1892">The subprogram specification of a unary operator must have a single parameter.</s>
 <s id="1893">The subprogram specification of a binary operator must have two parameters;</s>
 <s id="1894">for each use of this operator, the first parameter takes the left operand as actual parameter, the second parameter takes the right operand.</s>
 <s id="1895">Similarly, a generic function instantiation whose designator is an operator symbol is only allowed if the specification of the generic function has the corresponding number of parameters.</s>
 <s id="1896">Default expressions are not allowed for the parameters of an operator</s>
 <s id="1897">(whether the operator is declared with an explicit subprogram specification or by a generic instantiation).</s>
 <s id="1898">For each of the operators "+" and "-", overloading is allowed both as a unary and as a binary operator.</s>
 <s id="1899">The explicit declaration of a function that overloads the equality operator "=", other than by a renaming declaration, is only allowed if both parameters are of the same limited type.</s>
 <s id="1900">An overloading of equality must deliver a result of the predefined type BOOLEAN;</s>
 <s id="1901">it also implicitly overloads the inequality operator "/=" so that this still gives the complementary result to the equality operator.</s>
 <s id="1902">Explicit overloading of the inequality operator is not allowed.</s>
 <s id="1903">A renaming declaration whose designator is the equality operator is only allowed to rename another equality operator.</s>
 <s id="1904">(For example, such a renaming declaration can be used when equality is visible by selection but not directly visible.)</s>
 <s id="1905">Overloading of relational operators does not affect basic comparisons such as testing for membership in a range or the choices in a case statement.</s>
 <s id="1906">Packages are one of the four forms of program unit, of which programs can be composed.</s>
 <s id="1907">The other forms are subprograms, task units, and generic units.</s>
 <s id="1908">Packages allow the specification of groups of logically related entities.</s>
 <s id="1909">In their simplest form packages specify pools of common object and type declarations.</s>
 <s id="1910">More generally, packages can be used to specify groups of related entities including also subprograms that can be called from outside the package, while their inner workings remain concealed and protected from outside users.</s>
 <s id="1911">A package is generally provided in two parts: a package specification and a package body.</s>
 <s id="1912">Every package has a package specification, but not all packages have a package body.</s>
 <s id="1913">The simple name at the start of a package body must repeat the package identifier.</s>
 <s id="1914">Similarly if a simple name appears at the end of the package specification or body, it must repeat the package identifier.</s>
 <s id="1915">If a subprogram declaration, a package declaration, a task declaration, or a generic declaration is a declarative item of a given package specification, then the body (if there is one) of the program unit declared by the declarative item must itself be a declarative item of the declarative part of the body of the given package.</s>
 <s id="1916">A simple form of package, specifying a pool of objects and types, does not require a package body.</s>
 <s id="1917">One of the possible uses of the sequence of statements of a package body is to initialize such objects.</s>
 <s id="1918">For each subprogram declaration there must be a corresponding body</s>
 <s id="1919">(except for a subprogram written in another language, as explained in section 13.9).</s>
 <s id="1920">If the body of a program unit is a body stub, then a separately compiled subunit containing the corresponding proper body is required for the program unit (see 10.2).</s>
 <s id="1921">A body is not a basic declarative item and so cannot appear in a package specification.</s>
 <s id="1922">A package declaration is either a library package (see 10.2) or a declarative item declared within another program unit.</s>
 <s id="1923">The first list of declarative items of a package specification is called the visible part of the package.</s>
 <s id="1924">The optional list of declarative items after the reserved word private is called the private part of the package.</s>
 <s id="1925">An entity declared in the private part of a package is not visible outside the package itself</s>
 <s id="1926">(a name denoting such an entity is only possible within the package).</s>
 <s id="1927">In contrast, expanded names denoting entities declared in the visible part can be used even outside the package;</s>
 <s id="1928">furthermore, direct visibility of such entities can be achieved by means of use clauses (see 4.1.3 and 8.4).</s>
 <s id="1929">The elaboration of a package declaration consists of the elaboration of its basic declarative items in the given order.</s>
 <s id="1930">The visible part of a package contains all the information that another program unit is able to know about the package.</s>
 <s id="1931">A package consisting of only a package specification (that is, without a package body) can be used to represent a group of common constants or variables, or a common pool of objects and types, as in the examples below.</s>
 <s id="1932">Example of a package describing a group of common variables:</s>
 <s id="1933">Example of a package describing a common pool of objects and types:</s>
 <s id="1934">In contrast to the entities declared in the visible part of a package specification, the entities declared in the package body are only visible within the package body itself.</s>
 <s id="1935">As a consequence, a package with a package body can be used for the construction of a group of related subprograms (a package in the usual sense), in which the logical operations available to the users are clearly isolated from the internal entities.</s>
 <s id="1936">For the elaboration of a package body, its declarative part is first elaborated, and its sequence of statements (if any) is then executed.</s>
 <s id="1937">The optional exception handlers at the end of a package body service exceptions raised during the execution of the sequence of statements of the package body.</s>
 <s id="1938">A variable declared in the body of a package is only visible within this body and, consequently, its value can only be changed within the package body.</s>
 <s id="1939">In the absence of local tasks, the value of such a variable remains unchanged between calls issued from outside the package to subprograms declared in the visible part.</s>
 <s id="1940">The properties of such a variable are similar to those of an "own" variable of Algol 60.</s>
 <s id="1941">The elaboration of the body of a subprogram declared in the visible part of a package is caused by the elaboration of the body of the package.</s>
 <s id="1942">Hence a call of such a subprogram by an outside program unit raises the exception PROGRAM_ERROR if the call takes place before the elaboration of the package body (see 3.9).</s>
 <s id="1943">Example of a package:</s>
 <s id="1944">The declaration of a type as a private type in the visible part of a package serves to separate the characteristics that can be used directly by outside program units (that is, the logical properties) from other characteristics whose direct use is confined to the package (the details of the definition of the type itself).</s>
 <s id="1945">Deferred constant declarations declare constants of private types.</s>
 <s id="1946">A private type declaration is only allowed as a declarative item of the visible part of a package, or as the generic parameter declaration for a generic formal type in a generic formal part.</s>
 <s id="1947">The type mark of a deferred constant declaration must denote a private type or a subtype of a private type;</s>
 <s id="1948">a deferred constant declaration and the declaration of the corresponding private type must both be declarative items of the visible part of the same package.</s>
 <s id="1949">A deferred constant declaration with several identifiers is equivalent to a sequence of single deferred constant declarations as explained in section 3.2.</s>
 <s id="1950">Examples of private type declarations:</s>
 <s id="1951">Example of deferred constant declaration:</s>
 <s id="1952">If a private type declaration is given in the visible part of a package, then a corresponding declaration of a type with the same identifier must appear as a declarative item of the private part of the package.</s>
 <s id="1953">The corresponding declaration must be either a full type declaration or the declaration of a task type.</s>
 <s id="1954">In the rest of this section explanations are given in terms of full type declarations;</s>
 <s id="1955">the same rules apply also to declarations of task types.</s>
 <s id="1956">A private type declaration and the corresponding full type declaration define a single type.</s>
 <s id="1957">The private type declaration, together with the visible part, define the operations that are available to outside program units (see section 7.4.2 on the operations that are available for private types).</s>
 <s id="1958">On the other hand, the full type declaration defines other operations whose direct use is only possible within the package itself.</s>
 <s id="1959">If the private type declaration includes a discriminant part, the full declaration must include a discriminant part that conforms (see 6.3.1 for the conformance rules) and its type definition must be a record type definition.</s>
 <s id="1960">Conversely, if the private type declaration does not include a discriminant part, the type declared by the full type declaration (the full type) must not be an unconstrained type with discriminants.</s>
 <s id="1961">The full type must not be an unconstrained array type.</s>
 <s id="1962">A limited type (in particular a task type) is allowed for the full type only if the reserved word limited appears in the private type declaration (see 7.4.4).</s>
 <s id="1963">Within the specification of the package that declares a private type and before the end of the corresponding full type declaration, a restriction applies to the use of a name that denotes the private type or a subtype of the private type and, likewise, to the use of a name that denotes any type or subtype that has a subcomponent of the private type.</s>
 <s id="1964">The only allowed occurrences of such a name are in a deferred constant declaration, a type or subtype declaration, a subprogram specification, or an entry declaration;</s>
 <s id="1965">moreover, occurrences within derived type definitions or within simple expressions are not allowed.</s>
 <s id="1966">The elaboration of a private type declaration creates a private type.</s>
 <s id="1967">If the private type declaration has a discriminant part, this elaboration includes that of the discriminant part.</s>
 <s id="1968">The elaboration of the full type declaration consists of the elaboration of the type definition;</s>
 <s id="1969">the discriminant part, if any, is not elaborated</s>
 <s id="1970">(since the conforming discriminant part of the private type declaration has already been elaborated).</s>
 <s id="1971">It follows from the given rules that neither the declaration of a variable of a private type, nor the creation by an allocator of an object of the private type are allowed before the full declaration of the type.</s>
 <s id="1972">Similarly before the full declaration, the name of the private type cannot be used in a generic instantiation or in a representation clause.</s>
 <s id="1973">The operations that are implicitly declared by a private type declaration include basic operations.</s>
 <s id="1974">These are the operations involved in assignment (unless the reserved word limited appears in the declaration), membership tests, selected components for the selection of any discriminant, qualification, and explicit conversions.</s>
 <s id="1975">For a private type T, the basic operations also include the attributes T'BASE (see 3.3.3) and T'SIZE (see 13.7.2).</s>
 <s id="1976">For an object A of a private type, the basic operations include the attribute A'CONSTRAINED if the private type has discriminants (see 3.7.4), and in any case, the attributes A'SIZE and A'ADDRESS (see 13.7.2).</s>
 <s id="1977">Finally, the operations implicitly declared by a private type declaration include the predefined comparison for equality and inequality unless the reserved word limited appears in the private type declaration.</s>
 <s id="1978">The above operations, together with subprograms that have a parameter or result of the private type and that are declared in the visible part of the package, are the only operations from the package that are available outside the package for the private type.</s>
 <s id="1979">Within the package that declares the private type, the additional operations implicitly declared by the full type declaration are also available.</s>
 <s id="1980">However, the redefinition of these implicitly declared operations is allowed within the same declarative region, including between the private type declaration and the corresponding full declaration.</s>
 <s id="1981">An explicitly declared subprogram hides an implicitly declared operation that has the same parameter and result type profile</s>
 <s id="1982">(this is only possible if the implicitly declared operation is a derived subprogram or a predefined operator).</s>
 <s id="1983">If a composite type has subcomponents of a private type and is declared outside the package that declares the private type, then the operations that are implicitly declared by the declaration of the composite type include all operations that only depend on the characteristics that result from the private type declaration alone.</s>
 <s id="1984">(For example the operator &lt; is not included for a one-dimensional array type.)</s>
 <s id="1985">If the composite type is itself declared within the package that declares the private type (including within an inner package or generic package), then additional operations that depend on the characteristics of the full type are implicitly declared, as required by the rules applicable to the composite type</s>
 <s id="1986">(for example the operator &lt; is declared for a one-dimensional array type if the full type is discrete).</s>
 <s id="1987">These additional operations are implicitly declared at the earliest place within the immediate scope of the composite type and after the full type declaration.</s>
 <s id="1988">The same rules apply to the operations that are implicitly declared for an access type whose designated type is a private type or a type declared by an incomplete type declaration.</s>
 <s id="1989">For every private type or subtype T the following attribute is defined:</s>
 <s id="1990">Yields the value FALSE if T denotes an unconstrained nonformal private type with discriminants;</s>
 <s id="1991">also yields the value FALSE if T denotes a generic formal private type, and the associated actual subtype is either an unconstrained type with discriminants or an unconstrained array type;</s>
 <s id="1992">yields the value TRUE otherwise.</s>
 <s id="1993">The value of this attribute is of the predefined type BOOLEAN.</s>
 <s id="1994">A private type declaration and the corresponding full type declaration define two different views of one and the same type.</s>
 <s id="1995">Outside of the defining package the characteristics of the type are those defined by the visible part.</s>
 <s id="1996">Within these outside program units the type is just a private type and any language rule that applies only to another class of types does not apply.</s>
 <s id="1997">The fact that the full declaration might implement the private type with a type of a particular class (for example, as an array type) is only relevant within the package itself.</s>
 <s id="1998">The consequences of this actual implementation are, however, valid everywhere.</s>
 <s id="1999">For example: any default initialization of components takes place;</s>
 <s id="2000">the attribute SIZE provides the size of the full type;</s>
 <s id="2001">task dependence rules still apply to components that are task objects.</s>
 <s id="2002">Notes on the example:</s>
 <s id="2003">Outside of the package KEY_MANAGER, the operations available for objects of type KEY include assignment, the comparison for equality or inequality, the procedure GET_KEY and the operator "&lt;";</s>
 <s id="2004">they do not include other relational operators such as "&gt;=", or arithmetic operators.</s>
 <s id="2005">The explicitly declared operator "&lt;" hides the predefined operator "&lt;" implicitly declared by the full type declaration.</s>
 <s id="2006">Within the body of the function, an explicit conversion of X and Y to the type INTEGER is necessary to invoke the "&lt;" operator of this type.</s>
 <s id="2007">Alternatively, the result of the function could be written as not (X &gt;= Y), since the operator "&gt;=" is not redefined.</s>
 <s id="2008">The value of the variable LAST_KEY, declared in the package body, remains unchanged between calls of the procedure GET_KEY.</s>
 <s id="2009">(See also the Notes of section 7.3.)</s>
 <s id="2010">If a deferred constant declaration is given in the visible part of a package then a constant declaration (that is, an object declaration declaring a constant object, with an explicit initialization) with the same identifier must appear as a declarative item of the private part of the package.</s>
 <s id="2011">This object declaration is called the full declaration of the deferred constant.</s>
 <s id="2012">The type mark given in the full declaration must conform to that given in the deferred constant declaration (see 6.3.1).</s>
 <s id="2013">Multiple or single declarations are allowed for the deferred and the full declarations, provided that the equivalent single declarations conform.</s>
 <s id="2014">Within the specification of the package that declares a deferred constant and before the end of the corresponding full declaration, the use of a name that denotes the deferred constant is only allowed in the default expression for a record component or for a formal parameter (not for a generic formal parameter).</s>
 <s id="2015">The elaboration of a deferred constant declaration has no other effect.</s>
 <s id="2016">The execution of a program is erroneous if it attempts to use the value of a deferred constant before the elaboration of the corresponding full declaration.</s>
 <s id="2017">The full declaration for a deferred constant that has a given private type must not appear before the corresponding full type declaration.</s>
 <s id="2018">This is a consequence of the rules defining the allowed uses of a name that denotes a private type (see 7.4.1).</s>
 <s id="2019">A limited type is a type for which neither assignment nor the predefined comparison for equality and inequality is implicitly declared.</s>
 <s id="2020">A private type declaration that includes the reserved word limited declares a limited type.</s>
 <s id="2021">A task type is a limited type.</s>
 <s id="2022">A type derived from a limited type is itself a limited type.</s>
 <s id="2023">Finally, a composite type is limited if the type of any of its subcomponents is limited.</s>
 <s id="2024">The operations available for a private type that is limited are as given in section 7.4.2 for private types except for the absence of assignment and of a predefined comparison for equality and inequality.</s>
 <s id="2025">For a formal parameter whose type is limited and whose declaration occurs in an explicit subprogram declaration, the mode out is only allowed if this type is private and the subprogram declaration occurs within the visible part of the package that declares the private type.</s>
 <s id="2026">The same holds for formal parameters of entry declarations and of generic procedure declarations.</s>
 <s id="2027">The corresponding full type must not be limited if the mode out is used for any such formal parameter.</s>
 <s id="2028">Otherwise, the corresponding full type is allowed (but not required) to be a limited type</s>
 <s id="2029">(in particular, it is allowed to be a task type).</s>
 <s id="2030">If the full type corresponding to a limited private type is not itself limited, then assignment for the type is available within the package, but not outside.</s>
 <s id="2031">The following are consequences of the rules for limited types:</s>
 <s id="2032">An explicit initialization is not allowed in an object declaration if the type of the object is limited.</s>
 <s id="2033">A default expression is not allowed in a component declaration if the type of the record component is limited.</s>
 <s id="2034">An explicit initial value is not allowed in an allocator if the designated type is limited.</s>
 <s id="2035">A generic formal parameter of mode in must not be of a limited type.</s>
 <s id="2036">The above rules do not exclude a default expression for a formal parameter of a limited type;</s>
 <s id="2037">they do not exclude a deferred constant of a limited type if the full type is not limited.</s>
 <s id="2038">An explicit declaration of an equality operator is allowed for a limited type (see 6.7).</s>
 <s id="2039">Aggregates are not available for a limited composite type (see 3.6.2 and 3.7.4).</s>
 <s id="2040">Catenation is not available for a limited array type (see 3.6.2).</s>
 <s id="2041">Notes on the example:</s>
 <s id="2042">In the example above, an outside subprogram making use of I_O_PACKAGE may obtain a file name by calling OPEN and later use it in calls to READ and WRITE.</s>
 <s id="2043">Thus, outside the package, a file name obtained from OPEN acts as a kind of password;</s>
 <s id="2044">its internal properties (such as containing a numeric value) are not known and no other operations (such as addition or comparison of internal names) can be performed on a file name.</s>
 <s id="2045">This example is characteristic of any case where complete control over the operations of a type is desired.</s>
 <s id="2046">Such packages serve a dual purpose.</s>
 <s id="2047">They prevent a user from making use of the internal structure of the type.</s>
 <s id="2048">They also implement the notion of an encapsulated data type where the only operations on the type are those given in the package specification.</s>
 <s id="2049">The following example illustrates the use of packages in providing high level procedures with a simple interface to the user.</s>
 <s id="2050">The problem is to define a table management package for inserting and retrieving items.</s>
 <s id="2051">The items are inserted into the table as they are supplied.</s>
 <s id="2052">Each inserted item has an order number.</s>
 <s id="2053">The items are retrieved according to their order number, where the item with the lowest order number is retrieved first.</s>
 <s id="2054">From the user's point of view, the package is quite simple.</s>
 <s id="2055">There is a type called ITEM designating table items, a procedure INSERT for inserting items, and a procedure RETRIEVE for obtaining the item with the lowest order number.</s>
 <s id="2056">There is a special item NULL_ITEM that is returned when the table is empty, and an exception TABLE_FULL which is raised by INSERT if the table is already full.</s>
 <s id="2057">A sketch of such a package is given below.</s>
 <s id="2058">Only the specification of the package is exposed to the user.</s>
 <s id="2059">The details of implementing such packages can be quite complex;</s>
 <s id="2060">in this case they involve a two-way linked table of internal items.</s>
 <s id="2061">A local housekeeping procedure EXCHANGE is used to move an internal item between the busy and the free lists.</s>
 <s id="2062">The initial table linkages are established by the initialization part.</s>
 <s id="2063">The package body need not be shown to the users of the package.</s>
 <s id="2064">This example illustrates a simple text handling package.</s>
 <s id="2065">The users only have access to the visible part;</s>
 <s id="2066">the implementation is hidden from them in the private part and the package body (not shown).</s>
 <s id="2067">From a user's point of view, a TEXT is a variable-length string.</s>
 <s id="2068">Each text object has a maximum length, which must be given when the object is declared, and a current value, which is a string of some length between zero and the maximum.</s>
 <s id="2069">The maximum possible length of a text object is an implementation-defined constant.</s>
 <s id="2070">The package defines first the necessary types, then functions that return some characteristics of objects of the type, then the conversion functions between texts and the predefined CHARACTER and STRING types, and finally some of the standard operations on varying strings.</s>
 <s id="2071">Most operations are overloaded on strings and characters as well as on the type TEXT, in order to minimize the number of explicit conversions the user has to write.</s>
 <s id="2072">Example of use of the text handling package:</s>
 <s id="2073">A program opens an output file, whose name is supplied by the string NAME.</s>
 <s id="2074">This string has the form</s>
 <s id="2075">There are standard defaults for device, filename, and extension.</s>
 <s id="2076">The user-supplied name is passed to EXPAND_FILE_NAME as a parameter, and the result is the expanded version, with any necessary defaults added.</s>
 <s id="2077">The rules defining the scope of declarations and the rules defining which identifiers are visible at various points in the text of the program are described in this chapter.</s>
 <s id="2078">The formulation of these rules uses the notion of a declarative region.</s>
 <s id="2079">A declarative region is a portion of the program text.</s>
 <s id="2080">A single declarative region is formed by the text of each of the following:</s>
 <s id="2081">A subprogram declaration, a package declaration, a task declaration, or a generic declaration, together with the corresponding body, if any.</s>
 <s id="2082">If the body is a body stub, the declarative region also includes the corresponding subunit.</s>
 <s id="2083">If the program unit has subunits, they are also included.</s>
 <s id="2084">An entry declaration together with the corresponding accept statements.</s>
 <s id="2085">A record type declaration, together with a corresponding private or incomplete type declaration if any, and together with a corresponding record representation clause if any.</s>
 <s id="2086">A renaming declaration that includes a formal part, or a generic parameter declaration that includes either a formal part or a discriminant part.</s>
 <s id="2087">A block statement or a loop statement.</s>
 <s id="2088">In each of the above cases, the declarative region is said to be associated with the corresponding declaration or statement.</s>
 <s id="2089">A declaration is said to occur immediately within a declarative region if this region is the innermost region that encloses the declaration, not counting the declarative region (if any) associated with the declaration itself.</s>
 <s id="2090">A declaration that occurs immediately within a declarative region is said to be local to the region.</s>
 <s id="2091">Declarations in outer (enclosing) regions are said to be global to an inner (enclosed) declarative region.</s>
 <s id="2092">A local entity is one declared by a local declaration;</s>
 <s id="2093">a global entity is one declared by a global declaration.</s>
 <s id="2094">Some of the above forms of declarative region include several disjoint parts</s>
 <s id="2095">(for example, other declarative items can be between the declaration of a package and its body).</s>
 <s id="2096">Each declarative region is nevertheless considered as a (logically) continuous portion of the program text.</s>
 <s id="2097">Hence if any rule defines a portion of text as the text that extends from some specific point of a declarative region to the end of this region, then this portion is the corresponding subset of the declarative region</s>
 <s id="2098">(for example it does not include intermediate declarative items between the two parts of a package).</s>
 <s id="2099">As defined in section 3.1, the term declaration includes basic declarations, implicit declarations, and those declarations that are part of basic declarations, for example, discriminant and parameter specifications.</s>
 <s id="2100">It follows from the definition of a declarative region that a discriminant specification occurs immediately within the region associated with the enclosing record type declaration.</s>
 <s id="2101">Similarly, a parameter specification occurs immediately within the region associated with the enclosing subprogram body or accept statement.</s>
 <s id="2102">The package STANDARD forms a declarative region which encloses all library units: the implicit declaration of each library unit is assumed to occur immediately within this package (see sections 8.6 and 10.1.1).</s>
 <s id="2103">Declarative regions can be nested within other declarative regions.</s>
 <s id="2104">For example, subprograms, packages, task units, generic units, and block statements can be nested within each other, and can contain record type declarations, loop statements, and accept statements.</s>
 <s id="2105">For each form of declaration, the language rules define a certain portion of the program text called the scope of the declaration.</s>
 <s id="2106">The scope of a declaration is also called the scope of any entity declared by the declaration.</s>
 <s id="2107">Furthermore, if the declaration associates some notation with a declared entity, this portion of the text is also called the scope of this notation</s>
 <s id="2108">(either an identifier, a character literal, an operator symbol, or the notation for a basic operation).</s>
 <s id="2109">Within the scope of an entity, and only there, there are places where it is legal to use the associated notation in order to refer to the declared entity.</s>
 <s id="2110">These places are defined by the rules of visibility and overloading.</s>
 <s id="2111">The scope of a declaration that occurs immediately within a declarative region extends from the beginning of the declaration to the end of the declarative region;</s>
 <s id="2112">this part of the scope of a declaration is called the immediate scope.</s>
 <s id="2113">Furthermore, for any of the declarations listed below, the scope of the declaration extends beyond the immediate scope:</s>
 <s id="2114">A declaration that occurs immediately within the visible part of a package declaration.</s>
 <s id="2115">An entry declaration.</s>
 <s id="2116">A component declaration.</s>
 <s id="2117">A discriminant specification.</s>
 <s id="2118">A parameter specification.</s>
 <s id="2119">A generic parameter declaration.</s>
 <s id="2120">In each of these cases, the given declaration occurs immediately within some enclosing declaration, and the scope of the given declaration extends to the end of the scope of the enclosing declaration.</s>
 <s id="2121">In the absence of a subprogram declaration, the subprogram specification given in the subprogram body or in the body stub acts as the declaration and rule (e) applies also in such a case.</s>
 <s id="2122">The above scope rules apply to all forms of declaration defined by section 3.1;</s>
 <s id="2123">in particular, they apply also to implicit declarations.</s>
 <s id="2124">Rule (a) applies to a package declaration and thus not to the package specification of a generic declaration.</s>
 <s id="2125">For nested declarations, the rules (a) through (f) apply at each level.</s>
 <s id="2126">For example, if a task unit is declared in the visible part of a package, the scope of an entry of the task unit extends to the end of the scope of the task unit, that is, to the end of the scope of the enclosing package.</s>
 <s id="2127">The scope of a use clause is defined in section 8.4.</s>
 <s id="2128">The meaning of the occurrence of an identifier at a given place in the text is defined by the visibility rules and also, in the case of overloaded declarations, by the overloading rules.</s>
 <s id="2129">The identifiers considered in this chapter include any identifier other than a reserved word, an attribute designator, a pragma identifier, the identifier of a pragma argument, or an identifier given as a pragma argument.</s>
 <s id="2130">The places considered in this chapter are those where a lexical element (such as an identifier) occurs.</s>
 <s id="2131">The overloaded declarations considered in this chapter are those for subprograms, enumeration literals, and single entries.</s>
 <s id="2132">For each identifier and at each place in the text, the visibility rules determine a set of declarations (with this identifier) that define possible meanings of an occurrence of the identifier.</s>
 <s id="2133">A declaration is said to be visible at a given place in the text when, according to the visibility rules, the declaration defines a possible meaning of this occurrence.</s>
 <s id="2134">Two cases arise.</s>
 <s id="2135">The visibility rules determine at most one possible meaning.</s>
 <s id="2136">In such a case the visibility rules are sufficient to determine the declaration defining the meaning of the occurrence of the identifier, or in the absence of such a declaration, to determine that the occurrence is not legal at the given point.</s>
 <s id="2137">The visibility rules determine more than one possible meaning.</s>
 <s id="2138">In such a case the occurrence of the identifier is legal at this point if and only if exactly one visible declaration is acceptable for the overloading rules in the given context</s>
 <s id="2139">(see section 6.6 for the rules of overloading and section 8.7 for the context used for overload resolution).</s>
 <s id="2140">A declaration is only visible within a certain part of its scope;</s>
 <s id="2141">this part starts at the end of the declaration except in a package specification, in which case it starts at the reserved word is given after the identifier of the package specification.</s>
 <s id="2142">(This rule applies, in particular, for implicit declarations.)</s>
 <s id="2143">Visibility is either by selection or direct.</s>
 <s id="2144">A declaration is visible by selection at places that are defined as follows.</s>
 <s id="2145">For a declaration given in the visible part of a package declaration: at the place of the selector after the dot of an expanded name whose prefix denotes the package.</s>
 <s id="2146">For an entry declaration of a given task type: at the place of the selector after the dot of a selected component whose prefix is appropriate for the task type.</s>
 <s id="2147">For a component declaration of a given record type declaration: at the place of the selector after the dot of a selected component whose prefix is appropriate for the type; also at the place of a component simple name (before the compound delimiter =&gt;) in a named component association of an aggregate of the type.</s>
 <s id="2148">For a discriminant specification of a given type declaration: at the same places as for a component declaration; also at the place of a discriminant simple name (before the compound delimiter =&gt;) in a named discriminant association of a discriminant constraint for the type.</s>
 <s id="2149">For a parameter specification of a given subprogram specification or entry declaration: at the place of the formal parameter (before the compound delimiter =&gt;) in a named parameter association of a corresponding subprogram or entry call.</s>
 <s id="2150">For a generic parameter declaration of a given generic unit: at the place of the generic formal parameter (before the compound delimiter =&gt;) in a named generic association of a corresponding generic instantiation.</s>
 <s id="2151">Finally, within the declarative region associated with a construct other than a record type declaration, any declaration that occurs immediately within the region is visible by selection at the place of the selector after the dot of an expanded name whose prefix denotes the construct.</s>
 <s id="2152">Where it is not visible by selection, a visible declaration is said to be directly visible.</s>
 <s id="2153">A declaration is directly visible within a certain part of its immediate scope;</s>
 <s id="2154">this part extends to the end of the immediate scope of the declaration, but excludes places where the declaration is hidden as explained below.</s>
 <s id="2155">In addition, a declaration occurring immediately within the visible part of a package can be made directly visible by means of a use clause according to the rules described in section 8.4.</s>
 <s id="2156">(See also section 8.6 for the visibility of library units.)</s>
 <s id="2157">A declaration is said to be hidden within (part of) an inner declarative region if the inner region contains a homograph of this declaration;</s>
 <s id="2158">the outer declaration is then hidden within the immediate scope of the inner homograph.</s>
 <s id="2159">Each of two declarations is said to be a homograph of the other if both declarations have the same identifier and overloading is allowed for at most one of the two.</s>
 <s id="2160">If overloading is allowed for both declarations, then each of the two is a homograph of the other if they have the same identifier, operator symbol, or character literal, as well as the same parameter and result type profile (see 6.6).</s>
 <s id="2161">Within the specification of a subprogram, every declaration with the same designator as the subprogram is hidden; the same holds within a generic instantiation that declares a subprogram, and within an entry declaration or the formal part of an accept statement;</s>
 <s id="2162">where hidden in this manner, a declaration is visible neither by selection nor directly.</s>
 <s id="2163">Two declarations that occur immediately within the same declarative region must not be homographs, unless either or both of the following requirements are met:</s>
 <s id="2164">(a) exactly one of them is the implicit declaration of a predefined operation;</s>
 <s id="2165">(b) exactly one of them is the implicit declaration of a derived subprogram.</s>
 <s id="2166">In such cases, a predefined operation is always hidden by the other homograph;</s>
 <s id="2167">a derived subprogram hides a predefined operation, but is hidden by any other homograph.</s>
 <s id="2168">Where hidden in this manner, an implicit declaration is hidden within the entire scope of the other declaration</s>
 <s id="2169">(regardless of which declaration occurs first);</s>
 <s id="2170">the implicit declaration is visible neither by selection nor directly.</s>
 <s id="2171">Whenever a declaration with a certain identifier is visible from a given point, the identifier and the declared entity (if any) are also said to be visible from that point.</s>
 <s id="2172">Direct visibility and visibility by selection are likewise defined for character literals and operator symbols.</s>
 <s id="2173">An operator is directly visible if and only if the corresponding operator declaration is directly visible.</s>
 <s id="2174">Finally, the notation associated with a basic operation is directly visible within the entire scope of this operation.</s>
 <s id="2175">Note on the visibility of library units:</s>
 <s id="2176">The visibility of library units is determined by with clauses (see 10.1.1) and by the fact that library units are implicitly declared in the package STANDARD (see 8.6).</s>
 <s id="2177">Note on homographs:</s>
 <s id="2178">The same identifier may occur in different declarations and may thus be associated with different entities, even if the scopes of these declarations overlap.</s>
 <s id="2179">Overlap of the scopes of declarations with the same identifier can result from overloading of subprograms and of enumeration literals.</s>
 <s id="2180">Such overlaps can also occur for entities declared in package visible parts and for entries, record components, and parameters, where there is overlap of the scopes of the enclosing package declarations, task declarations, record type declarations, subprogram declarations, renaming declarations, or generic declarations.</s>
 <s id="2181">Finally overlapping scopes can result from nesting.</s>
 <s id="2182">Note on immediate scope, hiding, and visibility:</s>
 <s id="2183">The rules defining immediate scope, hiding, and visibility imply that a reference to an identifier within its own declaration is illegal</s>
 <s id="2184">(except for packages and generic packages).</s>
 <s id="2185">The identifier hides outer homographs within its immediate scope, that is, from the start of the declaration;</s>
 <s id="2186">on the other hand, the identifier is visible only after the end of the declaration.</s>
 <s id="2187">For this reason, all but the last of the following declarations are illegal:</s>
 <s id="2188">A use clause achieves direct visibility of declarations that appear in the visible parts of named packages.</s>
 <s id="2189">For each use clause, there is a certain region of text called the scope of the use clause.</s>
 <s id="2190">This region starts immediately after the use clause.</s>
 <s id="2191">If a use clause is a declarative item of some declarative region, the scope of the clause extends to the end of the declarative region.</s>
 <s id="2192">If a use clause occurs within a context clause of a compilation unit, the scope of the use clause extends to the end of the declarative region associated with the compilation unit.</s>
 <s id="2193">In order to define which declarations are made directly visible at a given place by use clauses, consider the set of packages named by all use clauses whose scopes enclose this place, omitting from this set any packages that enclose this place.</s>
 <s id="2194">A declaration that can be made directly visible by a use clause (a potentially visible declaration) is any declaration that occurs immediately within the visible part of a package of the set.</s>
 <s id="2195">A potentially visible declaration is actually made directly visible except in the following two cases:</s>
 <s id="2196">A potentially visible declaration is not made directly visible if the place considered is within the immediate scope of a homograph of the declaration.</s>
 <s id="2197">Potentially visible declarations that have the same identifier are not made directly visible unless each of them is either an enumeration literal specification or the declaration of a subprogram</s>
 <s id="2198">(by a subprogram declaration, a renaming declaration, a generic instantiation, or an implicit declaration).</s>
 <s id="2199">The elaboration of a use clause has no other effect.</s>
 <s id="2200">The above rules guarantee that a declaration that is made directly visible by a use clause cannot hide an otherwise directly visible declaration.</s>
 <s id="2201">The above rules are formulated in terms of the set of packages named by use clauses.</s>
 <s id="2202">Consequently, the following lines of text all have the same effect (assuming only one package P).</s>
 <s id="2203">Example of conflicting names in two packages:</s>
 <s id="2204">Example of name identification with a use clause:</s>
 <s id="2205">A renaming declaration declares another name for an entity.</s>
 <s id="2206">The elaboration of a renaming declaration evaluates the name that follows the reserved word renames and thereby determines the entity denoted by this name (the renamed entity).</s>
 <s id="2207">At any point where a renaming declaration is visible, the identifier, or operator symbol of this declaration denotes the renamed entity.</s>
 <s id="2208">The first form of renaming declaration is used for the renaming of objects.</s>
 <s id="2209">The renamed entity must be an object of the base type of the type mark.</s>
 <s id="2210">The properties of the renamed object are not affected by the renaming declaration.</s>
 <s id="2211">In particular, its value and whether or not it is a constant are unaffected;</s>
 <s id="2212">similarly, the constraints that apply to an object are not affected by renaming</s>
 <s id="2213">(any constraint implied by the type mark of the renaming declaration is ignored).</s>
 <s id="2214">The renaming declaration is legal only if exactly one object has this type and can be denoted by the object name.</s>
 <s id="2215">The following restrictions apply to the renaming of a subcomponent that depends on discriminants of a variable.</s>
 <s id="2216">The renaming is not allowed if the subtype of the variable, as defined in a corresponding object declaration, component declaration, or component subtype indication, is an unconstrained type; or if the variable is a generic formal object (of mode in out).</s>
 <s id="2217">Similarly if the variable is a formal parameter, the renaming is not allowed if the type mark given in the parameter specification denotes an nconstrained type whose discriminants have default expressions.</s>
 <s id="2218">The second form of renaming declaration is used for the renaming of exceptions;</s>
 <s id="2219">the third form, for the renaming of packages.</s>
 <s id="2220">The last form of renaming declaration is used for the renaming of subprograms and entries.</s>
 <s id="2221">The renamed subprogram or entry and the subprogram specification given in the renaming declaration must have the same parameter and result type profile (see 6.6).</s>
 <s id="2222">The renaming declaration is legal only if exactly one visible subprogram or entry satisfies the above requirements and can be denoted by the given subprogram or entry name.</s>
 <s id="2223">In addition, parameter modes must be identical for formal parameters that are at the same parameter position.</s>
 <s id="2224">The subtypes of the parameters and result (if any) of a renamed subprogram or entry are not affected by renaming.</s>
 <s id="2225">These subtypes are those given in the original subprogram declaration, generic instantiation, or entry declaration (not those of the renaming declaration); even for calls that use the new name.</s>
 <s id="2226">On the other hand, a renaming declaration can introduce parameter names and default expressions that differ from those of the renamed subprogram;</s>
 <s id="2227">named associations of calls with the new subprogram name must use the new parameter name;</s>
 <s id="2228">calls with the old subprogram name must use the old parameter names.</s>
 <s id="2229">A procedure can only be renamed as a procedure.</s>
 <s id="2230">Either of a function or operator can be renamed as either of a function or operator;</s>
 <s id="2231">for renaming as an operator, the subprogram specification given in the renaming declaration is subject to the rules given in section 6.7 for operator declarations.</s>
 <s id="2232">Enumeration literals can be renamed as functions;</s>
 <s id="2233">similarly, attributes defined as functions (such as SUCC and PRED) can be renamed as functions.</s>
 <s id="2234">An entry can only be renamed as a procedure;</s>
 <s id="2235">the new name is only allowed to appear in contexts that allow a procedure name.</s>
 <s id="2236">An entry of a family can be renamed, but an entry family cannot be renamed as a whole.</s>
 <s id="2237">Example of a renaming declaration with new parameter names:</s>
 <s id="2238">Example of a renaming declaration with a new default expression:</s>
 <s id="2239">Renaming may be used to resolve name conflicts and to act as a shorthand.</s>
 <s id="2240">Renaming with a different identifier or operator symbol does not hide the old name;</s>
 <s id="2241">the new name and the old name need not be visible at the same points.</s>
 <s id="2242">The attributes POS and VAL cannot be renamed since the corresponding specifications cannot be written;</s>
 <s id="2243">the same holds for the predefined multiplying operators with a universal fixed result.</s>
 <s id="2244">Calls with the new name of a renamed entry are procedure call statements and are not allowed at places where the syntax requires an entry call statement in conditional and timed entry calls;</s>
 <s id="2245">similarly, the COUNT attribute is not available for the new name.</s>
 <s id="2246">A task object that is declared by an object declaration can be renamed as an object.</s>
 <s id="2247">However, a single task cannot be renamed since the corresponding task type is anonymous.</s>
 <s id="2248">For similar reasons, an object of an anonymous array type cannot be renamed.</s>
 <s id="2249">No syntactic form exists for renaming a generic unit.</s>
 <s id="2250">A subtype can be used to achieve the effect of renaming a type (including a task type) as in</s>
 <s id="2251">The predefined types (for example the types BOOLEAN, CHARACTER and INTEGER) are the types that are declared in a predefined package called STANDARD;</s>
 <s id="2252">this package also includes the declarations of their predefined operations.</s>
 <s id="2253">The package STANDARD is described in Annex C.</s>
 <s id="2254">Apart from the predefined numeric types, the specification of the package STANDARD must be the same for all implementations of the language.</s>
 <s id="2255">The package STANDARD forms a declarative region which encloses every library unit and consequently the main program;</s>
 <s id="2256">the declaration of every library unit is assumed to occur immediately within this package.</s>
 <s id="2257">The implicit declarations of library units are assumed to be ordered in such a way that the scope of a given library unit includes any compilation unit that mentions the given library unit in a with clause.</s>
 <s id="2258">However, the only library units that are visible within a given compilation unit are as follows: they include the library units named by all with clauses that apply to the given unit, and moreover, if the given unit is a secondary unit of some library unit, they include this library unit.</s>
 <s id="2259">If all block statements of a program are named, then the name of each program unit can always be written as an expanded name starting with STANDARD</s>
 <s id="2260">(unless this package is itself hidden).</s>
 <s id="2261">If a type is declared in the visible part of a library package, then it is a consequence of the visibility rules that a basic operation (such as assignment) for this type is directly visible at places where the type itself is not visible (whether by selection or directly).</s>
 <s id="2262">However this operation can only be applied to operands that are visible and the declaration of these operands requires the visibility of either the type or one of its subtypes.</s>
 <s id="2263">Overloading is defined for subprograms, enumeration literals, operators, and single entries, and also for the operations that are inherent in several basic operations such as assignment, membership tests, allocators, the literal null, aggregates, and string literals.</s>
 <s id="2264">For overloaded entities, overload resolution determines the actual meaning that an occurrence of an identifier has, whenever the visibility rules have determined that more than one meaning is acceptable at the place of this occurrence;</s>
 <s id="2265">overload resolution likewise determines the actual meaning of an occurrence of an operator or some basic operation.</s>
 <s id="2266">At such a place all visible declarations are considered.</s>
 <s id="2267">The occurrence is only legal if there is exactly one interpretation of each constituent of the innermost complete context;</s>
 <s id="2268">a complete context is one of the following: a declaration, a statement, a representation clause.</s>
 <s id="2269">When considering possible interpretations of a complete context, the only rules considered are the syntax rules, the scope and visibility rules, and the rules of the form described below.</s>
 <s id="2270">Any rule that requires a name or expression to have a certain type, or to have the same type as another name or expression.</s>
 <s id="2271">Any rule that requires the type of a name or expression to be a type of a certain class; similarly, any rule that requires a certain type to be a discrete, integer, real, universal, character, boolean, or nonlimited type.</s>
 <s id="2272">Any rule that requires a prefix to be appropriate for a certain type.</s>
 <s id="2273">Any rule that specifies a certain type as the result type of a basic operation, and any rule that specifies that this type is of a certain class.</s>
 <s id="2274">The rules that require the type of an aggregate or string literal to be determinable solely from the enclosing complete context (see 4.3 and 4.2).</s>
 <s id="2275">Similarly, the rules that require the type of the prefix of an attribute, the type of the expression of a case statement, or the type of the operand of a type conversion, to be determinable independently of the context (see 4.1.4, 5.4, 4.6, and 6.4.1).</s>
 <s id="2276">The rules given in section 6.6, for the resolution of overloaded subprogram calls; in section 4.6, for the implicit conversions of universal expressions; in section 3.6.1, for the interpretation of discrete ranges with bounds having a universal type; and in section 4.1.3, for the interpretation of an expanded name whose prefix denotes a subprogram or an accept statement.</s>
 <s id="2277">Subprogram names used as pragma arguments follow a different rule: the pragma can apply to several overloaded subprograms, as explained in section 6.3.2 for the pragma INLINE, in section 11.7 for the pragma SUPPRESS, and in section 13.9 for the pragma INTERFACE.</s>
 <s id="2278">Similarly, the simple names given in context clauses (see 10.1.1) and in address clauses (see 13.5) follow different rules.</s>
 <s id="2279">If there is only one possible interpretation, the identifier denotes the corresponding entity.</s>
 <s id="2280">However, this does not mean that the occurrence is necessarily legal since other requirements exist which are not considered for overload resolution; for example, the fact that an expression is static, the parameter modes, whether an object is constant, conformance rules, forcing occurrences for a representation clause, order of elaboration, and so on.</s>
 <s id="2281">Similarly, subtypes are not considered for overload resolution.</s>
 <s id="2282">(the violation of a constraint does not make a program illegal but raises an exception during program execution).</s>
 <s id="2283">A loop parameter specification is a declaration, and hence a complete context.</s>
 <s id="2284">Rules that require certain constructs to have the same parameter and result type profile fall under the category (a);</s>
 <s id="2285">the same holds for rules that require conformance of two constructs since conformance requires that corresponding names be given the same meaning by the visibility and overloading rules.</s>
 <s id="2286">Rules of the form (a): address clause 13.5, assignment 5.2, choice 3.7.3 4.3.2 5.4, component association 4.3.1 4.3.2, conformance rules 9.5, default expression 3.7 3.7.1 6.1 12.1.1, delay statement 9.6, discrete range 3.6.1 5.5 9.5, discriminant constraint 3.7.2, enumeration representation clause 13.3, generic parameter association 12.3.1, index constraint 3.6.1, index expression 4.1.1 4.1.2 9.5, initial value 3.2.1, membership test 4.5.2, parameter association 6.4.1, parameter and result type profile 8.5 12.3.6, qualified expression 4.7, range constraint 3.5, renaming of an object 8.5, result expression 5.8</s>
 <s id="2287">Rules of the form (b): abort statement 9.10, assignment 5.2, case expression 5.4, condition 5.3 5.5 5.7 9.7.1, discrete range 3.6.1 5.5 9.5, fixed point type declaration 3.5.9, floating point type declaration 3.5.7, integer type declaration 3.5.4, length clause 13.2, membership test 4.4, number declaration 3.2.2, record representation clause 13.4, selected component 4.1.3, short-circuit control form 4.4, val attribute 3.5.5</s>
 <s id="2288">Rules of the form (c): indexed component 4.1.1, selected component 4.1.3, slice 4.1.2</s>
 <s id="2289">Rules of the form (d): aggregate 4.3, allocator 4.8, membership test 4.4, null literal 4.2, numeric literal 2.4, short-circuit control form 4.4, string literal 4.2</s>
 <s id="2290">The execution of a program that does not contain a task is defined in terms of a sequential execution of its actions, according to the rules described in other chapters of this manual.</s>
 <s id="2291">These actions can be considered to be executed by a single logical processor.</s>
 <s id="2292">Tasks are entities whose executions proceed in parallel in the following sense.</s>
 <s id="2293">Each task can be considered to be executed by a logical processor of its own.</s>
 <s id="2294">Different tasks (different logical processors) proceed independently, except at points where they synchronize.</s>
 <s id="2295">Some tasks have entries.</s>
 <s id="2296">An entry of a task can be called by other tasks.</s>
 <s id="2297">A task accepts a call of one of its entries by executing an accept statement for the entry.</s>
 <s id="2298">Synchronization is achieved by rendezvous between a task issuing an entry call and a task accepting the call.</s>
 <s id="2299">Some entries have parameters;</s>
 <s id="2300">entry calls and accept statements for such entries are the principal means of communicating values between tasks.</s>
 <s id="2301">The properties of each task are defined by a corresponding task unit which consists of a task specification and a task body.</s>
 <s id="2302">Task units are one of the four forms of program unit of which programs can be composed.</s>
 <s id="2303">The other forms are subprograms, packages and generic units.</s>
 <s id="2304">The properties of task units, tasks, and entries, and the statements that affect the interaction between tasks (that is, entry call statements, accept statements, delay statements, select statements, and abort statements) are described in this chapter.</s>
 <s id="2305">Parallel tasks (parallel logical processors) may be implemented on multicomputers, multiprocessors, or with interleaved execution on a single physical processor.</s>
 <s id="2306">On the other hand, whenever an implementation can detect that the same effect can be guaranteed if parts of the actions of a given task are executed by different physical processors acting in parallel, it may choose to execute them in this way;</s>
 <s id="2307">in such a case, several physical processors implement a single logical processor.</s>
 <s id="2308">A task unit consists of a task specification and a task body.</s>
 <s id="2309">A task specification that starts with the reserved words task type declares a task type.</s>
 <s id="2310">The value of an object of a task type designates a task having the entries, if any, that are declared in the task specification;</s>
 <s id="2311">these entries are also called entries of this object.</s>
 <s id="2312">The execution of the task is defined by the corresponding task body.</s>
 <s id="2313">A task specification without the reserved word type defines a single task.</s>
 <s id="2314">A task declaration with this form of specification is equivalent to the declaration of an anonymous task type immediately followed by the declaration of an object of the task type, and the task unit identifier names the object.</s>
 <s id="2315">In the remainder of this chapter, explanations are given in terms of task type declarations;</s>
 <s id="2316">the corresponding explanations for single task declarations follow from the stated equivalence.</s>
 <s id="2317">The simple name at the start of a task body must repeat the task unit identifier.</s>
 <s id="2318">Similarly if a simple name appears at the end of the task specification or body, it must repeat the task unit identifier.</s>
 <s id="2319">Within a task body, the name of the corresponding task unit can also be used to refer to the task object that designates the task currently executing the body;</s>
 <s id="2320">furthermore, the use of this name as a type mark is not allowed within the task unit itself.</s>
 <s id="2321">For the elaboration of a task specification, entry declarations and representation clauses, if any, are elaborated in the order given.</s>
 <s id="2322">Such representation clauses only apply to the entries declared in the task specification (see 13.5).</s>
 <s id="2323">The elaboration of a task body has no other effect than to establish that the body can from then on be used for the execution of tasks designated by objects of the corresponding task type.</s>
 <s id="2324">The execution of a task body is invoked by the activation of a task object of the corresponding type (see 9.3).</s>
 <s id="2325">The optional exception handlers at the end of a task body handle exceptions raised during the execution of the sequence of statements of the task body (see 11.4).</s>
 <s id="2326">Examples of specifications of task types:</s>
 <s id="2327">Examples of specifications of single tasks:</s>
 <s id="2328">Example of task specification and corresponding body:</s>
 <s id="2329">A task specification specifies the interface of tasks of the task type with other tasks of the same or of different types, and also with the main program.</s>
 <s id="2330">A task type is a limited type (see 7.4.4).</s>
 <s id="2331">Hence neither assignment nor the predefined comparison for equality and inequality are defined for objects of task types;</s>
 <s id="2332">moreover, the mode out is not allowed for a formal parameter whose type is a task type.</s>
 <s id="2333">A task object is an object whose type is a task type.</s>
 <s id="2334">The value of a task object designates a task that has the entries of the corresponding task type, and whose execution is specified by the corresponding task body.</s>
 <s id="2335">If a task object is the object, or a subcomponent of the object, declared by an object declaration, then the value of the task object is defined by the elaboration of the object declaration.</s>
 <s id="2336">If a task object is the object, or a subcomponent of the object, created by the evaluation of an allocator, then the value of the task object is defined by the evaluation of the allocator.</s>
 <s id="2337">For all parameter modes, if an actual parameter designates a task, the associated formal parameter designates the same task;</s>
 <s id="2338">the same holds for a subcomponent of an actual parameter and the corresponding subcomponent of the associated formal parameter;</s>
 <s id="2339">finally, the same holds for generic parameters.</s>
 <s id="2340">Example of access type designating task objects:</s>
 <s id="2341">Since a task type is a limited type, it can appear as the definition of a limited private type in a private part, and as a generic actual parameter associated with a formal parameter whose type is a limited type.</s>
 <s id="2342">On the other hand, the type of a generic formal parameter of mode in must not be a limited type and hence cannot be a task type.</s>
 <s id="2343">Task objects behave as constants (a task object always designates the same task) since their values are implicitly defined either at declaration or allocation, or by a parameter association, and since no assignment is available.</s>
 <s id="2344">However the reserved word constant is not allowed in the declaration of a task object since this would require an explicit initialization.</s>
 <s id="2345">A task object that is a formal parameter of mode in is a constant (as is any formal parameter of this mode).</s>
 <s id="2346">If an application needs to store and exchange task identities, it can do so by defining an access type designating the corresponding task objects and by using access values for identification purposes (see above example).</s>
 <s id="2347">Assignment is available for such an access type as for any access type.</s>
 <s id="2348">Subtype declarations are allowed for task types as for other types, but there are no constraints applicable to task types.</s>
 <s id="2349">A task body defines the execution of any task that is designated by a task object of the corresponding task type.</s>
 <s id="2350">The initial part of this execution is called the activation of the task object, and also that of the designated task;</s>
 <s id="2351">it consists of the elaboration of the declarative part, if any, of the task body.</s>
 <s id="2352">The execution of different tasks, in particular their activation, proceeds in parallel.</s>
 <s id="2353">If an object declaration that declares a task object occurs immediately within a declarative part, then the activation of the task object starts after the elaboration of the declarative part</s>
 <s id="2354">(that is, after passing the reserved word begin following the declarative part);</s>
 <s id="2355">similarly if such a declaration occurs immediately within a package specification, the activation starts after the elaboration of the declarative part of the package body.</s>
 <s id="2356">The same holds for the activation of a task object that is a subcomponent of an object declared immediately within a declarative part or package specification.</s>
 <s id="2357">The first statement following the declarative part is executed only after conclusion of the activation of these task objects.</s>
 <s id="2358">Should an exception be raised by the activation of one of these tasks, that task becomes a completed task (see 9.4);</s>
 <s id="2359">other tasks are not directly affected.</s>
 <s id="2360">Should one of these tasks thus become completed during its activation, the exception TASKING_ERROR is raised upon conclusion of the activation of all of these tasks (whether successfully or not);</s>
 <s id="2361">the exception is raised at a place that is immediately before the first statement following the declarative part</s>
 <s id="2362">(immediately after the reserved word begin).</s>
 <s id="2363">Should several of these tasks thus become completed during their activation, the exception TASKING_ERROR is raised only once.</s>
 <s id="2364">Should an exception be raised by the elaboration of a declarative part or package specification, then any task that is created (directly or indirectly) by this elaboration and that is not yet activated becomes terminated and is therefore never activated</s>
 <s id="2365">(see section 9.4 for the definition of a terminated task).</s>
 <s id="2366">For the above rules, in any package body without statements, a null statement is assumed.</s>
 <s id="2367">For any package without a package body, an implicit package body containing a single null statement is assumed.</s>
 <s id="2368">If a package without a package body is declared immediately within some program unit or block statement, the implicit package body occurs at the end of the declarative part of the program unit or block statement;</s>
 <s id="2369">if there are several such packages, the order of the implicit package bodies is undefined.</s>
 <s id="2370">A task object that is the object, or a subcomponent of the object, created by the evaluation of an allocator is activated by this evaluation.</s>
 <s id="2371">The activation starts after any initialization for the object created by the allocator;</s>
 <s id="2372">if several subcomponents are task objects, they are activated in parallel.</s>
 <s id="2373">The access value designating such an object is returned by the allocator only after the conclusion of these activations.</s>
 <s id="2374">Should an exception be raised by the activation of one of these tasks, that task becomes a completed task;</s>
 <s id="2375">other tasks are not directly affected.</s>
 <s id="2376">Should one of these tasks thus become completed during its activation, the exception TASKING_ERROR is raised upon conclusion of the activation of all of these tasks (whether successfully or not);</s>
 <s id="2377">the exception is raised at the place where the allocator is evaluated.</s>
 <s id="2378">Should several of these tasks thus become completed during their activation, the exception TASKING_ERROR is raised only once.</s>
 <s id="2379">Should an exception be raised by the initialization of the object created by an allocator (hence before the start of any activation), any task designated by a subcomponent of this object becomes terminated and is therefore never activated.</s>
 <s id="2380">An entry of a task can be called before the task has been activated.</s>
 <s id="2381">If several tasks are activated in parallel, the execution of any of these tasks need not await the end of the activation of the other tasks.</s>
 <s id="2382">A task may become completed during its activation either because of an exception or because it is aborted (see 9.10).</s>
 <s id="2383">Each task depends on at least one master.</s>
 <s id="2384">A master is a construct that is either a task, a currently executing block statement or subprogram, or a library package</s>
 <s id="2385">(a package declared within another program unit is not a master).</s>
 <s id="2386">The dependence on a master is a direct dependence in the following two cases:</s>
 <s id="2387">The task designated by a task object that is the object, or a subcomponent of the object, created by the evaluation of an allocator depends on the master that elaborates the corresponding access type definition.</s>
 <s id="2388">The task designated by any other task object depends on the master whose execution creates the task object.</s>
 <s id="2389">Furthermore, if a task depends on a given master that is a block statement executed by another master, then the task depends also on this other master, in an indirect manner;</s>
 <s id="2390">the same holds if the given master is a subprogram called by another master, and if the given master is a task that depends (directly or indirectly) on another master.</s>
 <s id="2391">Dependences exist for objects of a private type whose full declaration is in terms of a task type.</s>
 <s id="2392">A task is said to have completed its execution when it has finished the execution of the sequence of statements that appears after the reserved word begin in the corresponding body.</s>
 <s id="2393">Similarly a block or a subprogram is said to have completed its execution when it has finished the execution of the corresponding sequence of statements.</s>
 <s id="2394">For a block statement, the execution is also said to be completed when it reaches an exit, return, or goto statement transferring control out of the block.</s>
 <s id="2395">For a procedure, the execution is also said to be completed when a corresponding return statement is reached.</s>
 <s id="2396">For a function, the execution is also said to be completed after the evaluation of the result expression of a return statement.</s>
 <s id="2397">Finally the execution of a task, block statement, or subprogram is completed if an exception is raised by the execution of its sequence of statements and there is no corresponding handler, or, if there is one, when it has finished the execution of the corresponding handler.</s>
 <s id="2398">If a task has no dependent task, its termination takes place when it has completed its execution.</s>
 <s id="2399">After its termination, a task is said to be terminated.</s>
 <s id="2400">If a task has dependent tasks, its termination takes place when the execution of the task is completed and all dependent tasks are terminated.</s>
 <s id="2401">A block statement or subprogram body whose execution is completed is not left until all of its dependent tasks are terminated.</s>
 <s id="2402">Termination of a task otherwise takes place if and only if its execution has reached an open terminate alternative in a select statement (see 9.7.1), and the following conditions are satisfied:</s>
 <s id="2403">The task depends on some master whose execution is completed (hence not a library package).</s>
 <s id="2404">Each task that depends on the master considered is either already terminated or similarly waiting on an open terminate alternative of a select statement.</s>
 <s id="2405">When both conditions are satisfied, the task considered becomes terminated, together with all tasks that depend on the master considered.</s>
 <s id="2406">The rules given for termination imply that all tasks that depend (directly or indirectly) on a given master and that are not already terminated, can be terminated (collectively) if and only if each of them is waiting on an open terminate alternative of a select statement and the execution of the given master is completed.</s>
 <s id="2407">The usual rules apply to the main program.</s>
 <s id="2408">Consequently, termination of the main program awaits termination of any dependent task even if the corresponding task type is declared in a library package.</s>
 <s id="2409">On the other hand, termination of the main program does not await termination of tasks that depend on library packages;</s>
 <s id="2410">the language does not define whether such tasks are required to terminate.</s>
 <s id="2411">For an access type derived from another access type, the corresponding access type definition is that of the parent type;</s>
 <s id="2412">the dependence is on the master that elaborates the ultimate parent access type definition.</s>
 <s id="2413">A renaming declaration defines a new name for an existing entity and hence creates no further dependence.</s>
 <s id="2414">Entry calls and accept statements are the primary means of synchronization of tasks, and of communicating values between tasks.</s>
 <s id="2415">An entry declaration is similar to a subprogram declaration and is only allowed in a task specification.</s>
 <s id="2416">The actions to be performed when an entry is called are specified by corresponding accept statements.</s>
 <s id="2417">An entry declaration that includes a discrete range (see 3.6.1) declares a family of distinct entries having the same formal part (if any); that is, one such entry for each value of the discrete range.</s>
 <s id="2418">The term single entry is used in the definition of any rule that applies to any entry other than one of a family.</s>
 <s id="2419">The task designated by an object of a task type has (or owns) the entries declared in the specification of the task type.</s>
 <s id="2420">Within the body of a task, each of its single entries or entry families can be named by the corresponding simple name.</s>
 <s id="2421">The name of an entry of a family takes the form of an indexed component, the family simple name being followed by the index in parentheses;</s>
 <s id="2422">the type of this index must be the same as that of the discrete range in the corresponding entry family declaration.</s>
 <s id="2423">Outside the body of a task an entry name has the form of a selected component, whose prefix denotes the task object, and whose selector is the simple name of one of its single entries or entry families.</s>
 <s id="2424">A single entry overloads a subprogram, an enumeration literal, or another single entry if they have the same identifier.</s>
 <s id="2425">Overloading is not defined for entry families.</s>
 <s id="2426">A single entry or an entry of an entry family can be renamed as a procedure as explained in section 8.5.</s>
 <s id="2427">The parameter modes defined for parameters of the formal part of an entry declaration are the same as for a subprogram declaration and have the same meaning (see 6.2).</s>
 <s id="2428">The syntax of an entry call statement is similar to that of a procedure call statement, and the rules for parameter associations are the same as for subprogram calls (see 6.4.1 and 6.4.2).</s>
 <s id="2429">An accept statement specifies the actions to be performed at a call of a named entry</s>
 <s id="2430">(it can be an entry of a family).</s>
 <s id="2431">The formal part of an accept statement must conform to the formal part given in the declaration of the single entry or entry family named by the accept statement</s>
 <s id="2432">(see section 6.3.1 for the conformance rules).</s>
 <s id="2433">If a simple name appears at the end of an accept statement, it must repeat that given at the start.</s>
 <s id="2434">An accept statement for an entry of a given task is only allowed within the corresponding task body; excluding within the body of any program unit that is, itself, inner to the task body; and excluding within another accept statement for either the same single entry or an entry of the same family.</s>
 <s id="2435">(One consequence of this rule is that a task can execute accept statements only for its own entries.)</s>
 <s id="2436">A task body can contain more than one accept statement for the same entry.</s>
 <s id="2437">For the elaboration of an entry declaration, the discrete range, if any, is evaluated and the formal part, if any, is then elaborated as for a subprogram declaration.</s>
 <s id="2438">Execution of an accept statement starts with the evaluation of the entry index (in the case of an entry of a family).</s>
 <s id="2439">Execution of an entry call statement starts with the evaluation of the entry name; this is followed by any evaluations required for actual parameters in the same manner as for a subprogram call (see 6.4).</s>
 <s id="2440">Further execution of an accept statement and of a corresponding entry call statement are synchronized.</s>
 <s id="2441">If a given entry is called by only one task, there are two possibilities:</s>
 <s id="2442">If the calling task issues an entry call statement before a corresponding accept statement is reached by the task owning the entry, the execution of the calling task is suspended.</s>
 <s id="2443">If a task reaches an accept statement prior to any call of that entry, the execution of the task is suspended until such a call is received.</s>
 <s id="2444">When an entry has been called and a corresponding accept statement has been reached, the sequence of statements, if any, of the accept statement is executed by the called task</s>
 <s id="2445">(while the calling task remains suspended).</s>
 <s id="2446">This interaction is called a rendezvous.</s>
 <s id="2447">Thereafter, the calling task and the task owning the entry continue their execution in parallel.</s>
 <s id="2448">If several tasks call the same entry before a corresponding accept statement is reached, the calls are queued;</s>
 <s id="2449">there is one queue associated with each entry.</s>
 <s id="2450">Each execution of an accept statement removes one call from the queue.</s>
 <s id="2451">The calls are processed in the order of arrival.</s>
 <s id="2452">An attempt to call an entry of a task that has completed its execution raises the exception TASKING_ERROR at the point of the call, in the calling task;</s>
 <s id="2453">similarly, this exception is raised at the point of the call if the called task completes its execution before accepting the call</s>
 <s id="2454">(see also 9.10 for the case when the called task becomes abnormal).</s>
 <s id="2455">The exception CONSTRAINT_ERROR is raised if the index of an entry of a family is not within the specified discrete range.</s>
 <s id="2456">Examples of entry declarations:</s>
 <s id="2457">Examples of entry calls:</s>
 <s id="2458">Examples of accept statements:</s>
 <s id="2459">The formal part given in an accept statement is not elaborated;</s>
 <s id="2460">it is only used to identify the corresponding entry.</s>
 <s id="2461">An accept statement can call subprograms that issue entry calls.</s>
 <s id="2462">An accept statement need not have a sequence of statements even if the corresponding entry has parameters.</s>
 <s id="2463">Equally, it can have a sequence of statements even if the corresponding entry has no parameters.</s>
 <s id="2464">The sequence of statements of an accept statement can include return statements.</s>
 <s id="2465">A task can call its own entries but it will, of course, deadlock.</s>
 <s id="2466">The language permits conditional and timed entry calls (see 9.7.2 and 9.7.3).</s>
 <s id="2467">The language rules ensure that a task can only be in one entry queue at a given time.</s>
 <s id="2468">If the bounds of the discrete range of an entry family are integer literals, the index (in an entry name or accept statement) must be of the predefined type INTEGER (see 3.6.1).</s>
 <s id="2469">The execution of a delay statement evaluates the simple expression, and suspends further execution of the task that executes the delay statement, for at least the duration specified by the resulting value.</s>
 <s id="2470">The simple expression must be of the predefined fixed point type DURATION;</s>
 <s id="2471">its value is expressed in seconds;</s>
 <s id="2472">a delay statement with a negative value is equivalent to a delay statement with a zero value.</s>
 <s id="2473">Any implementation of the type DURATION must allow representation of durations (both positive and negative) up to at least 86400 seconds (one day);</s>
 <s id="2474">the smallest representable duration, DURATION'SMALL must not be greater than twenty milliseconds</s>
 <s id="2475">(whenever possible, a value not greater than fifty microseconds should be chosen).</s>
 <s id="2476">Note that DURATION'SMALL need not correspond to the basic clock cycle, the named number SYSTEM.TICK (see 13.7).</s>
 <s id="2477">The definition of the type TIME is provided in the predefined library package CALENDAR.</s>
 <s id="2478">The function CLOCK returns the current value of TIME at the time it is called.</s>
 <s id="2479">The functions YEAR, MONTH, DAY and SECONDS return the corresponding values for a given value of the type TIME; the procedure SPLIT returns all four corresponding values.</s>
 <s id="2480">Conversely, the function TIME_OF combines a year number, a month number, a day number, and a duration, into a value of type TIME.</s>
 <s id="2481">The operators "+" and "-" for addition and subtraction of times and durations, and the relational operators for times, have the conventional meaning.</s>
 <s id="2482">The exception TIME_ERROR is raised by the function TIME_OF if the actual parameters do not form a proper date.</s>
 <s id="2483">This exception is also raised by the operators "+" and "-" if, for the given operands, these operators cannot return a date whose year number is in the range of the corresponding subtype, or if the operator "-" cannot return a result that is in the range of the type DURATION.</s>
 <s id="2484">The second example causes the loop to be repeated every INTERVAL seconds on average.</s>
 <s id="2485">This interval between two successive iterations is only approximate.</s>
 <s id="2486">However, there will be no cumulative drift as long as the duration of each iteration is (sufficiently) less than INTERVAL.</s>
 <s id="2487">There are three forms of select statements.</s>
 <s id="2488">One form provides a selective wait for one or more alternatives.</s>
 <s id="2489">The other two provide conditional and timed entry calls.</s>
 <s id="2490">This form of the select statement allows a combination of waiting for, and selecting from, one or more alternatives.</s>
 <s id="2491">The selection can depend on conditions associated with each alternative of the selective wait.</s>
 <s id="2492">A selective wait must contain at least one accept alternative.</s>
 <s id="2493">In addition a selective wait can contain either a terminate alternative (only one), or one or more delay alternatives, or an else part;</s>
 <s id="2494">these three possibilities are mutually exclusive.</s>
 <s id="2495">A select alternative is said to be open if it does not start with when and a condition, or if the condition is TRUE.</s>
 <s id="2496">It is said to be closed otherwise.</s>
 <s id="2497">For the execution of a selective wait, any conditions specified after when are evaluated in some order that is not defined by the language;</s>
 <s id="2498">open alternatives are thus determined.</s>
 <s id="2499">For an open delay alternative, the delay expression is also evaluated.</s>
 <s id="2500">Similarly, for an open accept alternative for an entry of a family, the entry index is also evaluated.</s>
 <s id="2501">Selection and execution of one open alternative, or of the else part, then completes the execution of the selective wait;</s>
 <s id="2502">the rules for this selection are described below.</s>
 <s id="2503">Open accept alternatives are first considered.</s>
 <s id="2504">Selection of one such alternative takes place immediately if a corresponding rendezvous is possible, that is, if there is a corresponding entry call issued by another task and waiting to be accepted.</s>
 <s id="2505">If several alternatives can thus be selected, one of them is selected arbitrarily</s>
 <s id="2506">(that is, the language does not define which one).</s>
 <s id="2507">When such an alternative is selected, the corresponding accept statement and possible subsequent statements are executed.</s>
 <s id="2508">If no rendezvous is immediately possible and there is no else part, the task waits until an open selective wait alternative can be selected.</s>
 <s id="2509">Selection of the other forms of alternative or of an else part is performed as follows:</s>
 <s id="2510">An open delay alternative will be selected if no accept alternative can be selected before the specified delay has elapsed</s>
 <s id="2511">(immediately, for a negative or zero delay in the absence of queued entry calls);</s>
 <s id="2512">any subsequent statements of the alternative are then executed.</s>
 <s id="2513">If several delay alternatives can thus be selected (that is, if they have the same delay), one of them is selected arbitrarily.</s>
 <s id="2514">The else part is selected and its statements are executed if no accept alternative can be immediately selected, in particular, if all alternatives are closed.</s>
 <s id="2515">An open terminate alternative is selected if the conditions stated in section 9.4 are satisfied.</s>
 <s id="2516">It is a consequence of other rules that a terminate alternative cannot be selected while there is a queued entry call for any entry of the task.</s>
 <s id="2517">The exception PROGRAM_ERROR is raised if all alternatives are closed and there is no else part.</s>
 <s id="2518">Examples of a select statement:</s>
 <s id="2519">Example of a task body with a select statement:</s>
 <s id="2520">A selective wait is allowed to have several open delay alternatives.</s>
 <s id="2521">A selective wait is allowed to have several open accept alternatives for the same entry.</s>
 <s id="2522">A conditional entry call issues an entry call that is then canceled if a rendezvous is not immediately possible.</s>
 <s id="2523">For the execution of a conditional entry call, the entry name is first evaluated.</s>
 <s id="2524">This is followed by any evaluations required for actual parameters as in the case of a subprogram call (see 6.4).</s>
 <s id="2525">The entry call is canceled if the execution of the called task has not reached a point where it is ready to accept the call</s>
 <s id="2526">(that is, either an accept statement for the corresponding entry, or a select statement with an open accept alternative for the entry),</s>
 <s id="2527">or if there are prior queued entry calls for this entry.</s>
 <s id="2528">If the called task has reached a select statement, the entry call is canceled if an accept alternative for this entry is not selected.</s>
 <s id="2529">If the entry call is canceled, the statements of the else part are executed.</s>
 <s id="2530">Otherwise, the rendezvous takes place; and the optional sequence of statements after the entry call is then executed.</s>
 <s id="2531">The execution of a conditional entry call raises the exception TASKING_ERROR if the called task has already completed its execution</s>
 <s id="2532">(see also 9.10 for the case when the called task becomes abnormal).</s>
 <s id="2533">A timed entry call issues an entry call that is canceled if a rendezvous is not started within a given delay.</s>
 <s id="2534">For the execution of a timed entry call, the entry name is first evaluated.</s>
 <s id="2535">This is followed by any evaluations required for actual parameters as in the case of a subprogram call (see 6.4).</s>
 <s id="2536">The expression stating the delay is then evaluated, and the entry call is finally issued.</s>
 <s id="2537">If a rendezvous can be started within the specified duration</s>
 <s id="2538">(or immediately, as for a conditional entry call, for a negative or zero delay),</s>
 <s id="2539">it is performed and the optional sequence of statements after the entry call is then executed.</s>
 <s id="2540">Otherwise, the entry call is canceled when the specified duration has expired, and the optional sequence of statements of the delay alternative is executed.</s>
 <s id="2541">The execution of a timed entry call raises the exception TASKING_ERROR if the called task completes its execution before accepting the call</s>
 <s id="2542">(see also 9.10 for the case when the called task becomes abnormal).</s>
 <s id="2543">Each task may (but need not) have a priority, which is a value of the subtype PRIORITY (of the type INTEGER) declared in the predefined library package SYSTEM (see 13.7).</s>
 <s id="2544">A lower value indicates a lower degree of urgency;</s>
 <s id="2545">the range of priorities is implementation-defined.</s>
 <s id="2546">A priority is associated with a task if a pragma</s>
 <s id="2547">appears in the corresponding task specification; the priority is given by the value of the expression.</s>
 <s id="2548">A priority is associated with the main program if such a pragma appears in its outermost declarative part.</s>
 <s id="2549">At most one such pragma can appear within a given task specification or for a subprogram that is a library unit, and these are the only allowed places for this pragma.</s>
 <s id="2550">A pragma PRIORITY has no effect if it occurs in a subprogram other than the main program.</s>
 <s id="2551">The specification of a priority is an indication given to assist the implementation in the allocation of processing resources to parallel tasks when there are more tasks eligible for execution than can be supported simultaneously by the available processing resources.</s>
 <s id="2552">The effect of priorities on scheduling is defined by the following rule:</s>
 <s id="2553">If two tasks with different priorities are both eligible for execution and could sensibly be executed using the same physical processors and the same other processing resources, then it cannot be the case that the task with the lower priority is executing while the task with the higher priority is not.</s>
 <s id="2554">For tasks of the same priority, the scheduling order is not defined by the language.</s>
 <s id="2555">For tasks without explicit priority, the scheduling rules are not defined, except when such tasks are engaged in a rendezvous.</s>
 <s id="2556">If the priorities of both tasks engaged in a rendezvous are defined, the rendezvous is executed with the higher of the two priorities.</s>
 <s id="2557">If only one of the two priorities is defined, the rendezvous is executed with at least that priority.</s>
 <s id="2558">If neither is defined, the priority of the rendezvous is undefined.</s>
 <s id="2559">The priority of a task is static and therefore fixed.</s>
 <s id="2560">However, the priority during a rendezvous is not necessarily static since it also depends on the priority of the task calling the entry.</s>
 <s id="2561">Priorities should be used only to indicate relative degrees of urgency;</s>
 <s id="2562">they should not be used for task synchronization.</s>
 <s id="2563">For a task object or value T the following attributes are defined:</s>
 <s id="2564">Yields the value FALSE when the execution of the task designated by T is either completed or terminated, or when the task is abnormal.</s>
 <s id="2565">Yields the value TRUE otherwise.</s>
 <s id="2566">The value of this attribute is of the predefined type BOOLEAN.</s>
 <s id="2567">Yields the value TRUE if the task designated by T is terminated.</s>
 <s id="2568">Yields the value FALSE otherwise.</s>
 <s id="2569">The value of this attribute is of the predefined type BOOLEAN.</s>
 <s id="2570">In addition, the representation attributes STORAGE_SIZE, SIZE, and ADDRESS are defined for a task object T or a task type T (see 13.7.2).</s>
 <s id="2571">The attribute COUNT is defined for an entry E of a task unit T.</s>
 <s id="2572">The entry can be either a single entry or an entry of a family</s>
 <s id="2573">(in either case the name of the single entry or entry family can be either a simple or an expanded name).</s>
 <s id="2574">This attribute is only allowed within the body of T, but excluding within any program unit that is, itself, inner to the body of T.</s>
 <s id="2575">Yields the number of entry calls presently queued on the entry E</s>
 <s id="2576">(if the attribute is evaluated by the execution of an accept statement for the entry E, the count does not include the calling task).</s>
 <s id="2577">The value of this attribute is of the type universal integer.</s>
 <s id="2578">Algorithms interrogating the attribute E'COUNT should take precautions to allow for the increase of the value of this attribute for incoming entry calls, and its decrease, for example with timed entry calls.</s>
 <s id="2579">An abort statement causes one or more tasks to become abnormal, thus preventing any further rendezvous with such tasks.</s>
 <s id="2580">The determination of the type of each task name uses the fact that the type of the name is a task type.</s>
 <s id="2581">For the execution of an abort statement, the given task names are evaluated in some order that is not defined by the language.</s>
 <s id="2582">Each named task then becomes abnormal unless it is already terminated;</s>
 <s id="2583">similarly, any task that depends on a named task becomes abnormal unless it is already terminated.</s>
 <s id="2584">Any abnormal task whose execution is suspended at an accept statement, a select statement, or a delay statement becomes completed;</s>
 <s id="2585">any abnormal task whose execution is suspended at an entry call, and that is not yet in a corresponding rendezvous, becomes completed and is removed from the entry queue;</s>
 <s id="2586">any abnormal task that has not yet started its activation becomes completed (and hence also terminated).</s>
 <s id="2587">This completes the execution of the abort statement.</s>
 <s id="2588">The completion of any other abnormal task need not happen before completion of the abort statement.</s>
 <s id="2589">It must happen no later than when the abnormal task reaches a synchronization point that is one of the following: the end of its activation; a point where it causes the activation of another task; an entry call; the start or the end of an accept statement; a select statement; a delay statement; an exception handler; or an abort statement.</s>
 <s id="2590">If a task that calls an entry becomes abnormal while in a rendezvous, its termination does not take place before the completion of the rendezvous (see 11.5).</s>
 <s id="2591">The call of an entry of an abnormal task raises the exception TASKING_ERROR at the place of the call.</s>
 <s id="2592">Similarly, the exception TASKING_ERROR is raised for any task that has called an entry of an abnormal task, if the entry call is still queued or if the rendezvous is not yet finished</s>
 <s id="2593">(whether the entry call is an entry call statement, or a conditional or timed entry call);</s>
 <s id="2594">the exception is raised no later than the completion of the abnormal task.</s>
 <s id="2595">The value of the attribute CALLABLE is FALSE for any task that is abnormal (or completed).</s>
 <s id="2596">If the abnormal completion of a task takes place while the task updates a variable, then the value of this variable is undefined.</s>
 <s id="2597">An abort statement should be used only in extremely severe situations requiring unconditional termination.</s>
 <s id="2598">A task is allowed to abort any task, including itself.</s>
 <s id="2599">The normal means of communicating values between tasks is by entry calls and accept statements.</s>
 <s id="2600">If two tasks read or update a shared variable (that is, a variable accessible by both), then neither of them may assume anything about the order in which the other performs its operations, except at the points where they synchronize.</s>
 <s id="2601">Two tasks are synchronized at the start and at the end of their rendezvous.</s>
 <s id="2602">At the start and at the end of its activation, a task is synchronized with the task that causes this activation.</s>
 <s id="2603">A task that has completed its execution is synchronized with any other task.</s>
 <s id="2604">For the actions performed by a program that uses shared variables, the following assumptions can always be made:</s>
 <s id="2605">If between two synchronization points of a task, this task reads a shared variable whose type is a scalar or access type, then the variable is not updated by any other task at any time between these two points.</s>
 <s id="2606">If between two synchronization points of a task, this task updates a shared variable whose type is a scalar or access type, then the variable is neither read nor updated by any other task at any time between these two points.</s>
 <s id="2607">The execution of the program is erroneous if any of these assumptions is violated.</s>
 <s id="2608">If a given task reads the value of a shared variable, the above assumptions allow an implementation to maintain local copies of the value</s>
 <s id="2609">(for example, in registers or in some other form of temporary storage);</s>
 <s id="2610">and for as long as the given task neither reaches a synchronization point nor updates the value of the shared variable, the above assumptions imply that, for the given task, reading a local copy is equivalent to reading the shared variable itself.</s>
 <s id="2611">Similarly, if a given task updates the value of a shared variable, the above assumptions allow an implementation to maintain a local copy of the value, and to defer the effective store of the local copy into the shared variable until a synchronization point, provided that every further read or update of the variable by the given task is treated as a read or update of the local copy.</s>
 <s id="2612">On the other hand, an implementation is not allowed to introduce a store, unless this store would also be executed in the canonical order (see 11.6).</s>
 <s id="2613">The pragma SHARED can be used to specify that every read or update of a variable is a synchronization point for that variable; that is, the above assumptions always hold for the given variable (but not necessarily for other variables).</s>
 <s id="2614">The form of this pragma is as follows:</s>
 <s id="2615">This pragma is allowed only for a variable declared by an object declaration and whose type is a scalar or access type;</s>
 <s id="2616">the variable declaration and the pragma must both occur (in this order) immediately within the same declarative part or package specification;</s>
 <s id="2617">the pragma must appear before any occurrence of the name of the variable, other than in an address clause.</s>
 <s id="2618">An implementation must restrict the objects for which the pragma SHARED is allowed to objects for which each of direct reading and direct updating is implemented as an indivisible operation.</s>
 <s id="2619">The following example defines a buffering task to smooth variations between the speed of output of a producing task and the speed of input of some consuming task.</s>
 <s id="2620">For instance, the producing task may contain the statements</s>
 <s id="2621">and the consuming task may contain the statements</s>
 <s id="2622">The buffering task contains an internal pool of characters processed in a round-robin fashion.</s>
 <s id="2623">The pool has two indices, an IN_INDEX denoting the space for the next input character and an OUT_INDEX denoting the space for the next output character.</s>
 <s id="2624">The overall structure of programs and the facilities for separate compilation are described in this chapter.</s>
 <s id="2625">A program is a collection of one or more compilation units submitted to a compiler in one or more compilations.</s>
 <s id="2626">Each compilation unit specifies the separate compilation of a construct which can be a subprogram declaration or body, a package declaration or body, a generic declaration or body, or a generic instantiation.</s>
 <s id="2627">Alternatively this construct can be a subunit, in which case it includes the body of a subprogram, package, task unit, or generic unit declared within another compilation unit.</s>
 <s id="2628">The text of a program can be submitted to the compiler in one or more compilations.</s>
 <s id="2629">Each compilation is a succession of compilation units.</s>
 <s id="2630">The compilation units of a program are said to belong to a program library.</s>
 <s id="2631">A compilation unit defines either a library unit or a secondary unit.</s>
 <s id="2632">A secondary unit is either the separately compiled proper body of a library unit, or a subunit of another compilation unit.</s>
 <s id="2633">The designator of a separately compiled subprogram (whether a library unit or a subunit) must be an identifier.</s>
 <s id="2634">Within a program library the simple names of all library units must be distinct identifiers.</s>
 <s id="2635">The effect of compiling a library unit is to define (or redefine) this unit as one that belongs to the program library.</s>
 <s id="2636">For the visibility rules, each library unit acts as a declaration that occurs immediately within the package STANDARD.</s>
 <s id="2637">The effect of compiling a secondary unit is to define the body of a library unit, or in the case of a subunit, to define the proper body of a program unit that is declared within another compilation unit.</s>
 <s id="2638">A subprogram body given in a compilation unit is interpreted as a secondary unit if the program library already contains a library unit that is a subprogram with the same name;</s>
 <s id="2639">it is otherwise interpreted both as a library unit and as the corresponding library unit body (that is, as a secondary unit).</s>
 <s id="2640">The compilation units of a compilation are compiled in the given order.</s>
 <s id="2641">A pragma that applies to the whole of a compilation must appear before the first compilation unit of that compilation.</s>
 <s id="2642">A subprogram that is a library unit can be used as a main program in the usual sense.</s>
 <s id="2643">Each main program acts as if called by some environment task; the means by which this execution is initiated are not prescribed by the language definition.</s>
 <s id="2644">An implementation may impose certain requirements on the parameters and on the result, if any, of a main program</s>
 <s id="2645">(these requirements must be stated in Appendix F).</s>
 <s id="2646">In any case, every implementation is required to allow, at least, main programs that are parameterless procedures, and every main program must be a subprogram that is a library unit.</s>
 <s id="2647">A simple program may consist of a single compilation unit.</s>
 <s id="2648">A compilation need not have any compilation units; for example, its text can consist of pragmas.</s>
 <s id="2649">The designator of a library function cannot be an operator symbol, but a renaming declaration is allowed to rename a library function as an operator.</s>
 <s id="2650">Two library subprograms must have distinct simple names and hence cannot overload each other.</s>
 <s id="2651">However, renaming declarations are allowed to define overloaded names for such subprograms, and a locally declared subprogram is allowed to overload a library subprogram.</s>
 <s id="2652">The expanded name STANDARD.L can be used for a library unit L (unless the name STANDARD is hidden) since library units act as declarations that occur immediately within the package STANDARD.</s>
 <s id="2653">A context clause is used to specify the library units whose names are needed within a compilation unit.</s>
 <s id="2654">The names that appear in a context clause must be the simple names of library units.</s>
 <s id="2655">The simple name of any library unit is allowed within a with clause.</s>
 <s id="2656">The only names allowed in a use clause of a context clause are the simple names of library packages mentioned by previous with clauses of the context clause.</s>
 <s id="2657">A simple name declared by a renaming declaration is not allowed in a context clause.</s>
 <s id="2658">The with clauses and use clauses of the context clause of a library unit apply to this library unit and also to the secondary unit that defines the corresponding body</s>
 <s id="2659">(whether such a clause is repeated or not for this unit).</s>
 <s id="2660">Similarly, the with clauses and use clauses of the context clause of a compilation unit apply to this unit and also to its subunits, if any.</s>
 <s id="2661">If a library unit is named by a with clause that applies to a compilation unit, then this library unit is directly visible within the compilation unit, except where hidden;</s>
 <s id="2662">the library unit is visible as if declared immediately within the package STANDARD (see 8.6).</s>
 <s id="2663">Dependences among compilation units are defined by with clauses; that is, a compilation unit that mentions other library units in its with clauses depends on those library units.</s>
 <s id="2664">These dependences between units are taken into account for the determination of the allowed order of compilation (and recompilation) of compilation units, as explained in section 10.3, and for the determination of the allowed order of elaboration of compilation units, as explained in section 10.5.</s>
 <s id="2665">A library unit named by a with clause of a compilation unit is visible (except where hidden) within the compilation unit and hence can be used as a corresponding program unit.</s>
 <s id="2666">Thus within the compilation unit, the name of a library package can be given in use clauses and can be used to form expanded names;</s>
 <s id="2667">a library subprogram can be called;</s>
 <s id="2668">and instances of a library generic unit can be declared.</s>
 <s id="2669">The rules given for with clauses are such that the same effect is obtained whether the name of a library unit is mentioned once or more than once by the applicable with clauses, or even within a given with clause.</s>
 <s id="2670">Example 1 : A main program:</s>
 <s id="2671">The following is an example of a main program consisting of a single compilation unit: a procedure for printing the real roots of a quadratic equation.</s>
 <s id="2672">The predefined package TEXT_IO and a user-defined package REAL_OPERATIONS (containing the definition of the type REAL and of the packages REAL_IO and REAL_FUNCTIONS) are assumed to be already present in the program library.</s>
 <s id="2673">Such packages may be used by other main programs.</s>
 <s id="2674">Notes on the example:</s>
 <s id="2675">The with clauses of a compilation unit need only mention the names of those library subprograms and packages whose visibility is actually necessary within the unit.</s>
 <s id="2676">They need not (and should not) mention other library units that are used in turn by some of the units named in the with clauses, unless these other library units are also used directly by the current compilation unit.</s>
 <s id="2677">For example, the body of the package REAL_OPERATIONS may need elementary operations provided by other packages.</s>
 <s id="2678">The latter packages should not be named by the with clause of QUADRATIC_EQUATION since these elementary operations are not directly called within its body.</s>
 <s id="2679">A compilation unit can be split into a number of compilation units.</s>
 <s id="2680">For example, consider the following program.</s>
 <s id="2681">The following three compilation units define a program with an effect equivalent to the above example</s>
 <s id="2682">(the broken lines between compilation units serve to remind the reader that these units need not be contiguous texts).</s>
 <s id="2683">Example 2 : Several compilation units:</s>
 <s id="2684">Note that in the latter version, the package STOCK has no visibility of outer identifiers other than the predefined identifiers (of the package STANDARD).</s>
 <s id="2685">In particular, STOCK does not use any identifier declared in PROCESSOR such as SMALL or TOTAL;</s>
 <s id="2686">otherwise STOCK could not have been extracted from PROCESSOR in the above manner.</s>
 <s id="2687">The procedure PROCESSOR, on the other hand, depends on STOCK and mentions this package in a with clause.</s>
 <s id="2688">This permits the inner occurrences of STOCK in the expanded name STOCK.RESTART and in the use clause.</s>
 <s id="2689">These three compilation units can be submitted in one or more compilations.</s>
 <s id="2690">For example, it is possible to submit the package specification and the package body together and in this order in a single compilation.</s>
 <s id="2691">A subunit is used for the separate compilation of the proper body of a program unit declared within another compilation unit.</s>
 <s id="2692">This method of splitting a program permits hierarchical program development.</s>
 <s id="2693">A body stub is only allowed as the body of a program unit (a subprogram, a package, a task unit, or a generic unit) if the body stub occurs immediately within either the specification of a library package or the declarative part of another compilation unit.</s>
 <s id="2694">If the body of a program unit is a body stub, a separately compiled subunit containing the corresponding proper body is required.</s>
 <s id="2695">In the case of a subprogram, the subprogram specifications given in the proper body and in the body stub must conform (see 6.3.1).</s>
 <s id="2696">Each subunit mentions the name of its parent unit, that is, the compilation unit where the corresponding body stub is given.</s>
 <s id="2697">If the parent unit is a library unit, it is called the ancestor library unit.</s>
 <s id="2698">If the parent unit is itself a subunit, the parent unit name must be given in full as an expanded name, starting with the simple name of the ancestor library unit.</s>
 <s id="2699">The simple names of all subunits that have the same ancestor library unit must be distinct identifiers.</s>
 <s id="2700">Visibility within the proper body of a subunit is the visibility that would be obtained at the place of the corresponding body stub (within the parent unit) if the with clauses and use clauses of the subunit were appended to the context clause of the parent unit.</s>
 <s id="2701">If the parent unit is itself a subunit, then the same rule is used to define the visibility within the proper body of the parent unit.</s>
 <s id="2702">The effect of the elaboration of a body stub is to elaborate the proper body of the subunit.</s>
 <s id="2703">Two subunits of different library units in the same program library need not have distinct identifiers.</s>
 <s id="2704">In any case, their full expanded names are distinct, since the simple names of library units are distinct and since the simple names of all subunits that have a given library unit as ancestor unit are also distinct.</s>
 <s id="2705">By means of renaming declarations, overloaded subprogram names that rename (distinct) subunits can be introduced.</s>
 <s id="2706">A library unit that is named by the with clause of a subunit can be hidden by a declaration (with the same identifier) given in the proper body of the subunit.</s>
 <s id="2707">Moreover, such a library unit can even be hidden by a declaration given within a parent unit since a library unit acts as if declared in STANDARD;</s>
 <s id="2708">this however does not affect the interpretation of the with clauses themselves, since only names of library units can appear in with clauses.</s>
 <s id="2709">The procedure TOP is first written as a compilation unit without subunits.</s>
 <s id="2710">The body of the package FACILITY and that of the procedure TRANSFORM can be made into separate subunits of TOP.</s>
 <s id="2711">Similarly, the body of the procedure G can be made into a subunit of FACILITY as follows.</s>
 <s id="2712">Example 3:</s>
 <s id="2713">In the above example TRANSFORM and FACILITY are subunits of TOP, and G is a subunit of FACILITY.</s>
 <s id="2714">The visibility in the split version is the same as in the initial version except for one change: since TEXT_IO is only used within G, the corresponding with clause is written for G instead of for TOP.</s>
 <s id="2715">Apart from this change, the same identifiers are visible at corresponding program points in the two versions.</s>
 <s id="2716">For example, all of the following are (directly) visible within the proper body of the subunit G: the procedure TOP, the type REAL, the variables R and S, the package FACILITY and the contained named number PI and subprograms F and G.</s>
 <s id="2717">The rules defining the order in which units can be compiled are direct consequences of the visibility rules and, in particular, of the fact that any library unit that is mentioned by the context clause of a compilation unit is visible in the compilation unit.</s>
 <s id="2718">A compilation unit must be compiled after all library units named by its context clause.</s>
 <s id="2719">A secondary unit that is a subprogram or package body must be compiled after the corresponding library unit.</s>
 <s id="2720">Any subunit of a parent compilation unit must be compiled after the parent compilation unit.</s>
 <s id="2721">If any error is detected while attempting to compile a compilation unit, then the attempted compilation is rejected and it has no effect whatsoever on the program library;</s>
 <s id="2722">the same holds for recompilations</s>
 <s id="2723">(no compilation unit can become obsolete because of such a recompilation).</s>
 <s id="2724">The order in which the compilation units of a program are compiled must be consistent with the partial ordering defined by the above rules.</s>
 <s id="2725">Similar rules apply for recompilations.</s>
 <s id="2726">A compilation unit is potentially affected by a change in any library unit named by its context clause.</s>
 <s id="2727">A secondary unit is potentially affected by a change in the corresponding library unit.</s>
 <s id="2728">The subunits of a parent compilation unit are potentially affected by a change of the parent compilation unit.</s>
 <s id="2729">If a compilation unit is successfully recompiled, the compilation units potentially affected by this change are obsolete and must be recompiled unless they are no longer needed.</s>
 <s id="2730">An implementation may be able to reduce the compilation costs if it can deduce that some of the potentially affected units are not actually affected by the change.</s>
 <s id="2731">The subunits of a unit can be recompiled without affecting the unit itself.</s>
 <s id="2732">Similarly, changes in a subprogram or package body do not affect other compilation units (apart from the subunits of the body) since these compilation units only have access to the subprogram or package specification.</s>
 <s id="2733">An implementation is only allowed to deviate from this rule for inline inclusions, for certain compiler optimizations, and for certain implementations of generic program units, as described below.</s>
 <s id="2734">If a pragma INLINE is applied to a subprogram declaration given in a package specification, inline inclusion will only be achieved if the package body is compiled before units calling the subprogram.</s>
 <s id="2735">In such a case, inline inclusion creates a dependence of the calling unit on the package body, and the compiler must recognize this dependence when deciding on the need for recompilation.</s>
 <s id="2736">If a calling unit is compiled before the package body, the pragma may be ignored by the compiler for such calls</s>
 <s id="2737">(a warning that inline inclusion was not achieved may be issued).</s>
 <s id="2738">Similar considerations apply to a separately compiled subprogram for which an INLINE pragma is specified.</s>
 <s id="2739">For optimization purposes, an implementation may compile several units of a given compilation in a way that creates further dependences among these compilation units.</s>
 <s id="2740">The compiler must then take these dependences into account when deciding on the need for recompilations.</s>
 <s id="2741">An implementation may require that a generic declaration and the corresponding proper body be part of the same compilation, whether the generic unit is itself separately compiled or is local to another compilation unit.</s>
 <s id="2742">An implementation may also require that subunits of a generic unit be part of the same compilation.</s>
 <s id="2743">Examples of Compilation Order:</s>
 <s id="2744">In example 1 (see 10.1.1): The procedure QUADRATIC_EQUATION must be compiled after the library packages TEXT_IO and REAL_OPERATIONS since they appear in its with clause.</s>
 <s id="2745">In example 2 (see 10.1.2): The package body STOCK must be compiled after the corresponding package specification.</s>
 <s id="2746">In example 2 (see 10.1.2): The specification of the package STOCK must be compiled before the procedure PROCESSOR.</s>
 <s id="2747">On the other hand, the procedure PROCESSOR can be compiled either before or after the package body STOCK.</s>
 <s id="2748">In example 3 (see 10.2.1): The procedure G must be compiled after the package TEXT_IO since this package is named by the with clause of G.</s>
 <s id="2749">On the other hand, TEXT_IO can be compiled either before or after TOP.</s>
 <s id="2750">In example 3 (see 10.2.1): The subunits TRANSFORM and FACILITY must be compiled after the main program TOP.</s>
 <s id="2751">Similarly, the subunit G must be compiled after its parent unit FACILITY.</s>
 <s id="2752">For library packages, it follows from the recompilation rules that a package body is made obsolete by the recompilation of the corresponding specification.</s>
 <s id="2753">If the new package specification is such that a package body is not required</s>
 <s id="2754">(that is, if the package specification does not contain the declaration of a program unit),</s>
 <s id="2755">then the recompilation of a body for this package is not required.</s>
 <s id="2756">In any case, the obsolete package body must not be used and can therefore be deleted from the program library.</s>
 <s id="2757">Compilers are required to enforce the language rules in the same manner for a program consisting of several compilation units (and subunits) as for a program submitted as a single compilation.</s>
 <s id="2758">Consequently, a library file containing information on the compilation units of the program library must be maintained by the compiler or compiling environment.</s>
 <s id="2759">This information may include symbol tables and other information pertaining to the order of previous compilations.</s>
 <s id="2760">A normal submission to the compiler consists of the compilation unit(s) and the library file.</s>
 <s id="2761">The latter is used for checks and is updated for each compilation unit successfully compiled.</s>
 <s id="2762">A single program library is implied for the compilation units of a compilation.</s>
 <s id="2763">The possible existence of different program libraries and the means by which they are named are not concerns of the language definition;</s>
 <s id="2764">they are concerns of the programming environment.</s>
 <s id="2765">There should be commands for creating the program library of a given program or of a given family of programs.</s>
 <s id="2766">These commands may permit the reuse of units of other program libraries.</s>
 <s id="2767">Finally, there should be commands for interrogating the status of the units of a program library.</s>
 <s id="2768">The form of these commands is not specified by the language definition.</s>
 <s id="2769">Before the execution of a main program, all library units needed by the main program are elaborated, as well as the corresponding library unit bodies, if any.</s>
 <s id="2770">The library units needed by the main program are: those named by with clauses applicable to the main program, to its body, and to its subunits; those named by with clauses applicable to these library units themselves, to the corresponding library unit bodies, and to their subunits; and so on, in a transitive manner.</s>
 <s id="2771">The elaboration of these library units and of the corresponding library unit bodies is performed in an order consistent with the partial ordering defined by the with clauses (see 10.3).</s>
 <s id="2772">In addition, a library unit mentioned by the context clause of a subunit must be elaborated before the body of the ancestor library unit of the subunit.</s>
 <s id="2773">An order of elaboration that is consistent with this partial ordering does not always ensure that each library unit body is elaborated before any other compilation unit whose elaboration necessitates that the library unit body be already elaborated.</s>
 <s id="2774">If the prior elaboration of library unit bodies is needed, this can be requested by a pragma ELABORATE.</s>
 <s id="2775">The form of this pragma is as follows:</s>
 <s id="2776">These pragmas are only allowed immediately after the context clause of a compilation unit</s>
 <s id="2777">(before the subsequent library unit or secondary unit).</s>
 <s id="2778">Each argument of such a pragma must be the simple name of a library unit mentioned by the context clause, and this library unit must have a library unit body.</s>
 <s id="2779">Such a pragma specifies that the library unit body must be elaborated before the given compilation unit.</s>
 <s id="2780">If the given compilation unit is a subunit, the library unit body must be elaborated before the body of the ancestor library unit of the subunit.</s>
 <s id="2781">The program is illegal if no consistent order can be found</s>
 <s id="2782">(that is, if a circularity exists).</s>
 <s id="2783">The elaboration of the compilation units of the program is performed in some order that is otherwise not defined by the language.</s>
 <s id="2784">Optimization of the elaboration of declarations and the execution of statements may be performed by compilers.</s>
 <s id="2785">In particular, a compiler may be able to optimize a program by evaluating certain expressions, in addition to those that are static expressions.</s>
 <s id="2786">Should one of these expressions, whether static or not, be such that an exception would be raised by its evaluation, then the code in that path of the program can be replaced by code to raise the exception;</s>
 <p id="p2787">
  <s id="2787.1">the same holds for exceptions raised by the evaluation of names and simple expressions.</s>
  <s id="2787.2">(See also section 11.6.)</s>
 </p>
 <s id="2788">A compiler may find that some statements or subprograms will never be executed, for example, if their execution depends on a condition known to be FALSE.</s>
 <s id="2789">The corresponding object machine code can then be omitted.</s>
 <s id="2790">This rule permits the effect of conditional compilation within the language.</s>
 <s id="2791">An expression whose evaluation is known to raise an exception need not represent an error if it occurs in a statement or subprogram that is never executed.</s>
 <s id="2792">The compiler may warn the programmer of a potential error.</s>
 <s id="2793">This chapter defines the facilities for dealing with errors or other exceptional situations that arise during program execution.</s>
 <s id="2794">Such a situation is called an exception.</s>
 <s id="2795">To raise an exception is to abandon normal program execution so as to draw attention to the fact that the corresponding situation has arisen.</s>
 <s id="2796">Executing some actions, in response to the arising of an exception, is called handling the exception.</s>
 <s id="2797">An exception declaration declares a name for an exception.</s>
 <s id="2798">An exception can be raised by a raise statement, or it can be raised by another statement or operation that propagates the exception.</s>
 <s id="2799">When an exception arises, control can be transferred to a user-provided exception handler at the end of a block statement or at the end of the body of a subprogram, package, or task unit.</s>
 <s id="2800">An exception declaration declares a name for an exception.</s>
 <s id="2801">The name of an exception can only be used in raise statements, exception handlers, and renaming declarations.</s>
 <s id="2802">An exception declaration with several identifiers is equivalent to a sequence of single exception declarations, as explained in section 3.2.</s>
 <s id="2803">Each single exception declaration declares a name for a different exception.</s>
 <s id="2804">In particular, if a generic unit includes an exception declaration, the exception declarations implicitly generated by different instantiations of the generic unit refer to distinct exceptions</s>
 <s id="2805">(but all have the same identifier).</s>
 <s id="2806">The particular exception denoted by an exception name is determined at compilation time and is the same regardless of how many times the exception declaration is elaborated.</s>
 <s id="2807">Hence, if an exception declaration occurs in a recursive subprogram, the exception name denotes the same exception for all invocations of the recursive subprogram.</s>
 <s id="2808">The following exceptions are predefined in the language;</s>
 <s id="2809">they are raised when the situations described are detected.</s>
 <s id="2810">This exception is raised in any of the following situations: upon an attempt to violate a range constraint, an index constraint, or a discriminant constraint;</s>
 <s id="2811">upon an attempt to use a record component that does not exist for the current discriminant values;</s>
 <s id="2812">and upon an attempt to use a selected component, an indexed component, a slice, or an attribute, of an object designated by an access value, if the object does not exist because the access value is null.</s>
 <s id="2813">This exception is raised by the execution of a predefined numeric operation that cannot deliver a correct result</s>
 <s id="2814">(within the declared accuracy for real types);</s>
 <s id="2815">this includes the case where an implementation uses a predefined numeric operation for the execution, evaluation, or elaboration of some construct.</s>
 <s id="2816">The rules given in section 4.5.7 define the cases in which an implementation is not required to raise this exception when such an error situation arises; see also section 11.6.</s>
 <s id="2817">This exception is raised upon an attempt to call a subprogram, to activate a task, or to elaborate a generic instantiation, if the body of the corresponding unit has not yet been elaborated.</s>
 <s id="2818">This exception is also raised if the end of a function is reached (see 6.5); or during the execution of a selective wait that has no else part, if this execution determines that all alternatives are closed (see 9.7.1).</s>
 <s id="2819">Finally, depending on the implementation, this exception may be raised upon an attempt to execute an action that is erroneous, and for incorrect order dependences (see 1.6).</s>
 <s id="2820">This exception is raised in any of the following situations: when the dynamic storage allocated to a task is exceeded; during the evaluation of an allocator, if the space available for the collection of allocated objects is exhausted; or during the elaboration of a declarative item, or during the execution of a subprogram call, if storage is not sufficient.</s>
 <s id="2821">This exception is raised when exceptions arise during intertask communication (see 9 and 11.5).</s>
 <s id="2822">The situations described above can arise without raising the corresponding exceptions, if the pragma SUPPRESS has been used to give permission to omit the corresponding checks (see 11.7).</s>
 <s id="2823">Examples of user-defined exception declarations:</s>
 <s id="2824">Constraint error exception contexts: aggregate 4.3.1 4.3.2, allocator 4.8, assignment statement 5.2 5.2.1, constraint 3.3.2, discrete type attribute 3.5.5, discriminant constraint 3.7.2, elaboration of a generic formal parameter 12.3.1 12.3.2 12.3.4 12.3.5, entry index 9.5, exponentiating operator 4.5.6, index constraint 3.6.1, indexed component 4.1.1, logical operator 4.5.1, null access value 3.8, object declaration 3.2.1, parameter association 6.4.1, qualified expression 4.7, range constraint 3.5, selected component 4.1.3, slice 4.1.2, subtype indication 3.3.2, type conversion 4.6</s>
 <s id="2825">Numeric error exception contexts: discrete type attribute 3.5.5, implicit conversion 3.5.4 3.5.6 4.6, numeric operation 3.5.5 3.5.8 3.5.10, operator of a numeric type 4.5 4.5.7</s>
 <s id="2826">Program error exception contexts: collection 3.8, elaboration 3.9, elaboration check 3.9 7.3 9.3 12.2, erroneous 1.6, incorrect order dependence 1.6, leaving a function 6.5, selective wait 9.7.1</s>
 <s id="2827">Storage error exception contexts: allocator 4.8</s>
 <s id="2828">Tasking error exception contexts: abort statement 9.10, entry call 9.5 9.7.2 9.7.3, exceptions during task communication 11.5, task activation 9.3</s>
 <s id="2829">The response to one or more exceptions is specified by an exception handler.</s>
 <s id="2830">An exception handler occurs in a construct that is either a block statement or the body of a subprogram, package, task unit, or generic unit.</s>
 <s id="2831">Such a construct will be called a frame in this chapter.</s>
 <s id="2832">In each case the syntax of a frame that has exception handlers includes the following part:</s>
 <s id="2833">The exceptions denoted by the exception names given as exception choices of a frame must all be distinct.</s>
 <s id="2834">The exception choice others is only allowed for the last exception handler of a frame and as its only exception choice;</s>
 <s id="2835">it stands for all exceptions not listed in previous handlers of the frame, including exceptions whose names are not visible at the place of the exception handler.</s>
 <s id="2836">The exception handlers of a frame handle exceptions that are raised by the execution of the sequence of statements of the frame.</s>
 <s id="2837">The exceptions handled by a given exception handler are those named by the corresponding exception choices.</s>
 <s id="2838">The same kinds of statement are allowed in the sequence of statements of each exception handler as are allowed in the sequence of statements of the frame.</s>
 <s id="2839">For example, a return statement is allowed in a handler within a function body.</s>
 <s id="2840">A raise statement raises an exception.</s>
 <s id="2841">For the execution of a raise statement with an exception name, the named exception is raised.</s>
 <s id="2842">A raise statement without an exception name is only allowed within an exception handler</s>
 <s id="2843">(but not within the sequence of statements of a subprogram, package, task unit, or generic unit, enclosed by the handler);</s>
 <s id="2844">it raises again the exception that caused transfer to the innermost enclosing handler.</s>
 <s id="2845">When an exception is raised, normal program execution is abandoned and control is transferred to an exception handler.</s>
 <s id="2846">The selection of this handler depends on whether the exception is raised during the execution of statements or during the elaboration of declarations.</s>
 <s id="2847">The handling of an exception raised by the execution of a sequence of statements depends on whether the innermost frame or accept statement that encloses the sequence of statements is a frame or an accept statement.</s>
 <s id="2848">The case where an accept statement is innermost is described in section 11.5.</s>
 <s id="2849">The case where a frame is innermost is presented here.</s>
 <s id="2850">Different actions take place, depending on whether or not this frame has a handler for the exception, and on whether the exception is raised in the sequence of statements of the frame or in that of an exception handler.</s>
 <s id="2851">If an exception is raised in the sequence of statements of a frame that has a handler for the exception, execution of the sequence of statements of the frame is abandoned and control is transferred to the exception handler.</s>
 <s id="2852">The execution of the sequence of statements of the handler completes the execution of the frame</s>
 <s id="2853">(or its elaboration if the frame is a package body).</s>
 <s id="2854">If an exception is raised in the sequence of statements of a frame that does not have a handler for the exception, execution of this sequence of statements is abandoned.</s>
 <s id="2855">The next action depends on the nature of the frame:</s>
 <s id="2856">For a subprogram body, the same exception is raised again at the point of call of the subprogram, unless the subprogram is the main program itself,</s>
 <s id="2857">in which case execution of the main program is abandoned.</s>
 <s id="2858">For a block statement, the same exception is raised again immediately after the block statement</s>
 <s id="2859">(that is, within the innermost enclosing frame or accept statement).</s>
 <s id="2860">For a package body that is a declarative item, the same exception is raised again immediately after this declarative item (within the enclosing declarative part).</s>
 <s id="2861">If the package body is that of a subunit, the exception is raised again at the place of the corresponding body stub.</s>
 <s id="2862">If the package is a library unit, execution of the main program is abandoned.</s>
 <s id="2863">For a task body, the task becomes completed.</s>
 <s id="2864">An exception that is raised again (as in the above cases (a), (b), and (c)) is said to be propagated, either by the execution of the subprogram, the execution of the block statement, or the elaboration of the package body.</s>
 <s id="2865">No propagation takes place in the case of a task body.</s>
 <s id="2866">If the frame is a subprogram or a block statement and if it has dependent tasks, the propagation of an exception takes place only after termination of the dependent tasks.</s>
 <s id="2867">Finally, if an exception is raised in the sequence of statements of an exception handler, execution of this sequence of statements is abandoned.</s>
 <s id="2868">Subsequent actions (including propagation, if any) are as in the cases (a) to (d) above, depending on the nature of the frame.</s>
 <s id="2869">If the multiplication raises NUMERIC_ERROR, then FLOAT'SAFE_LARGE is returned by the handler.</s>
 <s id="2870">This value will cause further NUMERIC_ERROR exceptions to be raised by the evaluation of the expression in each of the remaining invocations of the function,</s>
 <s id="2871">so that for large values of N the function will ultimately return the value FLOAT'SAFE_LARGE.</s>
 <s id="2872">The following situations can arise:</s>
 <s id="2873">If the exception ERROR is raised in the sequence of statements of the outer procedure P, the handler E1 provided within P is used to complete the execution of P.</s>
 <s id="2874">If the exception ERROR is raised in the sequence of statements of Q, the handler E2 provided within Q is used to complete the execution of Q.</s>
 <s id="2875">Control will be returned to the point of call of Q upon completion of the handler.</s>
 <s id="2876">If the exception ERROR is raised in the body of R, called by Q, the execution of R is abandoned and the same exception is raised in the body of Q.</s>
 <s id="2877">The handler E2 is then used to complete the execution of Q, as in situation (2).</s>
 <s id="2878">Note that in the third situation, the exception raised in R results in (indirectly) transferring control to a handler that is part of Q and hence not enclosed by R.</s>
 <s id="2879">Note also that if a handler were provided within R for the exception choice others, situation (3) would cause execution of this handler, rather than direct termination of R.</s>
 <s id="2880">Lastly, if ERROR had been declared in R, rather than in P, the handlers E1 and E2 could not provide an explicit handler for ERROR since this identifier would not be visible within the bodies of P and Q.</s>
 <s id="2881">In situation (3), the exception could however be handled in Q by providing a handler for the exception choice others.</s>
 <s id="2882">The language does not define what happens when the execution of the main program is abandoned after an unhandled exception.</s>
 <s id="2883">The predefined exceptions are those that can be propagated by the basic operations and the predefined operators.</s>
 <s id="2884">The case of a frame that is a generic unit is already covered by the rules for subprogram and package bodies, since the sequence of statements of such a frame is not executed but is the template for the corresponding sequences of statements of the subprograms or packages obtained by generic instantiation.</s>
 <s id="2885">If an exception is raised during the elaboration of the declarative part of a given frame, this elaboration is abandoned.</s>
 <s id="2886">The next action depends on the nature of the frame:</s>
 <s id="2887">For a subprogram body, the same exception is raised again at the point of call of the subprogram, unless the subprogram is the main program itself, in which case execution of the main program is abandoned.</s>
 <s id="2888">For a block statement, the same exception is raised again immediately after the block statement.</s>
 <s id="2889">For a package body that is a declarative item, the same exception is raised again immediately after this declarative item, in the enclosing declarative part.</s>
 <s id="2890">If the package body is that of a subunit, the exception is raised again at the place of the corresponding body stub.</s>
 <s id="2891">If the package is a library unit, execution of the main program is abandoned.</s>
 <s id="2892">For a task body, the task becomes completed, and the exception TASKING_ERROR is raised at the point of activation of the task, as explained in section 9.3.</s>
 <s id="2893">Similarly, if an exception is raised during the elaboration of either a package declaration or a task declaration, this elaboration is abandoned;</s>
 <s id="2894">the next action depends on the nature of the declaration.</s>
 <s id="2895">For a package declaration or a task declaration, that is a declarative item, the exception is raised again immediately after the declarative item in the enclosing declarative part or package specification.</s>
 <s id="2896">For the declaration of a library package, the execution of the main program is abandoned.</s>
 <s id="2897">An exception that is raised again (as in the above cases (a), (b), (c) and (e)) is said to be propagated, either by the execution of the subprogram or block statement, or by the elaboration of the package declaration, task declaration or package body.</s>
 <s id="2898">Example of an exception in the declarative part of a block statement (case (b)):</s>
 <s id="2899">An exception can be propagated to a task communicating, or attempting to communicate, with another task.</s>
 <s id="2900">An exception can also be propagated to a calling task if the exception is raised during a rendezvous.</s>
 <s id="2901">When a task calls an entry of another task, the exception TASKING_ERROR is raised in the calling task, at the place of the call, if the called task is completed before accepting the entry call or is already completed at the time of the call.</s>
 <s id="2902">A rendezvous can be completed abnormally in two cases:</s>
 <s id="2903">When an exception is raised within an accept statement, but not handled within an inner frame.</s>
 <s id="2904">In this case, the execution of the accept statement is abandoned and the same exception is raised again immediately after the accept statement within the called task;</s>
 <s id="2905">the exception is also propagated to the calling task at the point of the entry call.</s>
 <s id="2906">When the task containing the accept statement is completed abnormally as the result of an abort statement.</s>
 <s id="2907">In this case, the exception TASKING_ERROR is raised in the calling task at the point of the entry call.</s>
 <s id="2908">On the other hand, if a task issuing an entry call becomes abnormal (as the result of an abort statement) no exception is raised in the called task.</s>
 <s id="2909">If the rendezvous has not yet started, the entry call is cancelled.</s>
 <s id="2910">If the rendezvous is in progress, it completes normally, and the called task is unaffected.</s>
 <s id="2911">The purpose of this section is to specify the conditions under which an implementation is allowed to perform certain actions either earlier or later than specified by other rules of the language.</s>
 <s id="2912">In general, when the language rules specify an order for certain actions (the canonical order), an implementation may only use an alternative order if it can guarantee that the effect of the program is not changed by the reordering.</s>
 <s id="2913">In particular, no exception should arise for the execution of the reordered program if none arises for the execution of the program in the canonical order.</s>
 <s id="2914">When, on the other hand, the order of certain actions is not defined by the language, any order can be used by the implementation.</s>
 <s id="2915">(For example, the arguments of a predefined operator can be evaluated in any order since the rules given in section 4.5 do not require a specific order of evaluation.)</s>
 <s id="2916">Additional freedom is left to an implementation for reordering actions involving predefined operations that are either predefined operators or basic operations other than assignments.</s>
 <s id="2917">This freedom is left, as defined below, even in the case where the execution of these predefined operations may propagate a (predefined) exception:</s>
 <s id="2918">For the purpose of establishing whether the same effect is obtained by the execution of certain actions in the canonical and in an alternative order, it can be assumed that none of the predefined operations invoked by these actions propagates a (predefined) exception, provided that the two following requirements are met by the alternative order: first, an operation must not be invoked in the alternative order if it is not invoked in the canonical order;</s>
 <s id="2919">second, for each operation, the innermost enclosing frame or accept statement must be the same in the alternative order as in the canonical order, and the same exception handlers must apply.</s>
 <s id="2920">Within an expression, the association of operators with operands is specified by the syntax.</s>
 <s id="2921">However, for a sequence of predefined operators of the same precedence level (and in the absence of parentheses imposing a specific association), any association of operators with operands is allowed if it satisfies the following requirement: an integer result must be equal to that given by the canonical left-to-right order;</s>
 <s id="2922">a real result must belong to the result model interval defined for the canonical left-to-right order (see 4.5.7).</s>
 <s id="2923">Such a reordering is allowed even if it may remove an exception, or introduce a further predefined exception.</s>
 <s id="2924">Similarly, additional freedom is left to an implementation for the evaluation of numeric simple expressions.</s>
 <s id="2925">For the evaluation of a predefined operation, an implementation is allowed to use the operation of a type that has a range wider than that of the base type of the operands, provided that this delivers the exact result (or a result within the declared accuracy, in the case of a real type), even if some intermediate results lie outside the range of the base type.</s>
 <s id="2926">The exception NUMERIC_ERROR need not be raised in such a case.</s>
 <s id="2927">In particular, if the numeric expression is an operand of a predefined relational operator, the exception NUMERIC_ERROR need not be raised by the evaluation of the relation, provided that the correct BOOLEAN result is obtained.</s>
 <s id="2928">A preedefined operation need not be invoked at all, if its only possible effect is to propagate a predefined exception.</s>
 <s id="2929">Similarly, a predefined operation need not be invoked if the removal of subsequent operations by the above rule renders this invocation ineffective.</s>
 <s id="2930">Rule (b) applies to predefined operators but not to the short-circuit control forms.</s>
 <s id="2931">The expression SPEED &lt; 300_000.0 can be replaced by TRUE if the value 300_000.0 lies outside the base type of SPEED, even though the implicit conversion of the numeric literal would raise the exception NUMERIC_ERROR.</s>
 <s id="2932">The evaluation of A(K) may be performed before the loop, and possibly immediately before the assignment statement (1) even if this evaluation can raise an exception.</s>
 <s id="2933">Consequently, within the exception handler, the value of N is either the undefined initial value or a value later assigned.</s>
 <s id="2934">On the other hand, the evaluation of A(K) cannot be moved before begin since an exception would then be handled by a different handler.</s>
 <s id="2935">For this reason, the initialization of N in the declaration itself would exclude the possibility of having an undefined initial value of N in the handler.</s>
 <s id="2936">The presence of a SUPPRESS pragma gives permission to an implementation to omit certain run-time checks.</s>
 <s id="2937">The form of this pragma is as follows:</s>
 <s id="2938">The identifier is that of the check that can be omitted.</s>
 <s id="2939">The name (if present) must be either a simple name or an expanded name and it must denote either an object, a type or subtype, a task unit, or a generic unit;</s>
 <s id="2940">alternatively the name can be a subprogram name, in which case it can stand for several visible overloaded subprograms.</s>
 <s id="2941">A pragma SUPPRESS is only allowed immediately within a declarative part or immediately within a package specification.</s>
 <s id="2942">In the latter case, the only allowed form is with a name that denotes an entity (or several overloaded subprograms) declared immediately within the package specification.</s>
 <s id="2943">The permission to omit the given check extends from the place of the pragma to the end of the declarative region associated with the innermost enclosing block statement or program unit.</s>
 <s id="2944">For a pragma given in a package specification, the permission extends to the end of the scope of the named entity.</s>
 <s id="2945">If the pragma includes a name, the permission to omit the given check is further restricted: it is given only for operations on the named object or on all objects of the base type of a named type or subtype; for calls of a named subprogram; for activations of tasks of the named task type; or for instantiations of the given generic unit.</s>
 <s id="2946">The following checks correspond to situations in which the exception CONSTRAINT_ERROR may be raised;</s>
 <s id="2947">for these checks, the name (if present) must denote either an object or a type.</s>
 <s id="2948">When accessing a selected component, an indexed component, a slice, or an attribute, of an object designated by an access value, check that the access value is not null.</s>
 <s id="2949">Check that a discriminant of a composite value has the value imposed by a discriminant constraint.</s>
 <s id="2950">Also, when accessing a record component, check that it exists for the current discriminant values.</s>
 <s id="2951">Check that the bounds of an array value are equal to the corresponding bounds of an index constraint.</s>
 <s id="2952">Also, when accessing a component of an array object, check for each dimension that the given index value belongs to the range defined by the bounds of the array object.</s>
 <s id="2953">Also, when accessing a slice of an array object, check that the given discrete range is compatible with the range defined by the bounds of the array object.</s>
 <s id="2954">Check that there is a matching component for each component of an array, in the case of array assignments, type conversions, and logical operators for arrays of boolean components.</s>
 <s id="2955">Check that a value satisfies a range constraint.</s>
 <s id="2956">Also, for the elaboration of a subtype indication, check that the constraint (if present) is compatible with the type mark.</s>
 <s id="2957">Also, for an aggregate, check that an index or discriminant value belongs to the corresponding subtype.</s>
 <s id="2958">Finally, check for any constraint checks performed by a generic instantiation.</s>
 <s id="2959">The following checks correspond to situations in which the exception NUMERIC_ERROR is raised.</s>
 <s id="2960">The only allowed names in the corresponding pragmas are names of numeric types.</s>
 <s id="2961">Check that the second operand is not zero for the operations /, rem and mod.</s>
 <s id="2962">Check that the result of a numeric operation does not overflow.</s>
 <s id="2963">The following check corresponds to situations in which the exception PROGRAM_ERROR is raised.</s>
 <s id="2964">The only allowed names in the corresponding pragmas are names denoting task units, generic units, or subprograms.</s>
 <s id="2965">When either a subprogram is called, a task activation is accomplished, or a generic instantiation is elaborated, check that the body of the corresponding unit has already been elaborated.</s>
 <s id="2966">The following check corresponds to situations in which the exception STORAGE_ERROR is raised.</s>
 <s id="2967">The only allowed names in the corresponding pragmas are names denoting access types, task units, or subprograms.</s>
 <s id="2968">Check that execution of an allocator does not require more space than is available for a collection.</s>
 <s id="2969">Check that the space available for a task or subprogram has not been exceeded.</s>
 <s id="2970">If an error situation arises in the absence of the corresponding run-time checks, the execution of the program is erroneous</s>
 <s id="2971">(the results are not defined by the language).</s>
 <s id="2972">For certain implementations, it may be impossible or too costly to suppress certain checks.</s>
 <s id="2973">The corresponding SUPPRESS pragma can be ignored.</s>
 <s id="2974">Hence, the occurrence of such a pragma within a given unit does not guarantee that the corresponding exception will not arise;</s>
 <s id="2975">the exceptions may also be propagated by called units.</s>
 <s id="2976">A generic unit is a program unit that is either a generic subprogram or a generic package.</s>
 <s id="2977">A generic unit is a template, which is parameterized or not, and from which corresponding (nongeneric) subprograms or packages can be obtained.</s>
 <s id="2978">The resulting program units are said to be instances of the original generic unit.</s>
 <s id="2979">A generic unit is declared by a generic declaration.</s>
 <s id="2980">This form of declaration has a generic formal part declaring any generic formal parameters.</s>
 <s id="2981">An instance of a generic unit is obtained as the result of a generic instantiation with appropriate generic actual parameters for the generic formal parameters.</s>
 <s id="2982">An instance of a generic subprogram is a subprogram.</s>
 <s id="2983">An instance of a generic package is a package.</s>
 <s id="2984">Generic units are templates.</s>
 <s id="2985">As templates they do not have the properties that are specific to their nongeneric counterparts.</s>
 <s id="2986">For example, a generic subprogram can be instantiated but it cannot be called.</s>
 <s id="2987">In contrast, the instance of a generic subprogram is a nongeneric subprogram; hence, this instance can be called but it cannot be used to produce further instances.</s>
 <s id="2988">A generic declaration declares a generic unit, which is either a generic subprogram or a generic package.</s>
 <s id="2989">A generic declaration includes a generic formal part declaring any generic formal parameters.</s>
 <s id="2990">A generic formal parameter can be an object;</s>
 <s id="2991">alternatively (unlike a parameter of a subprogram), it can be a type or a subprogram.</s>
 <s id="2992">The terms generic formal object (or simply, formal object), generic formal type (or simply, formal type), and generic formal subprogram (or simply, formal subprogram) are used to refer to corresponding generic formal parameters.</s>
 <s id="2993">The only form of subtype indication allowed within a generic formal part is a type mark</s>
 <s id="2994">(that is, the subtype indication must not include an explicit constraint).</s>
 <s id="2995">The designator of a generic subprogram must be an identifier.</s>
 <s id="2996">Outside the specification and body of a generic unit, the name of this program unit denotes the generic unit.</s>
 <s id="2997">In contrast, within the declarative region associated with a generic subprogram, the name of this program unit denotes the subprogram obtained by the current instantiation of the generic unit.</s>
 <s id="2998">Similarly, within the declarative region associated with a generic package, the name of this program unit denotes the package obtained by the current instantiation.</s>
 <s id="2999">The elaboration of a generic declaration has no other effect.</s>
 <s id="3000">Examples of generic formal parts:</s>
 <s id="3001">Examples of generic declarations declaring generic subprograms:</s>
 <s id="3002">Example of a generic declaration declaring a generic package:</s>
 <s id="3003">Within a generic subprogram, the name of this program unit acts as the name of a subprogram.</s>
 <s id="3004">Hence this name can be overloaded, and it can appear in a recursive call of the current instantiation.</s>
 <s id="3005">For the same reason, this name cannot appear after the reserved word new in a (recursive) generic instantiation.</s>
 <s id="3006">An expression that occurs in a generic formal part is either the default expression for a generic formal object of mode in, or a constituent of an entry name given as default name for a formal subprogram, or the default expression for a parameter of a formal subprogram.</s>
 <s id="3007">Default expressions for generic formal objects and default names for formal subprograms are only evaluated for generic instantiations that use such defaults.</s>
 <s id="3008">Default expressions for parameters of formal subprograms are only evaluated for calls of the formal subprograms that use such defaults.</s>
 <s id="3009">(The usual visibility rules apply to any name used in a default expression: the denoted entity must therefore be visible at the place of the expression.)</s>
 <s id="3010">Neither generic formal parameters nor their attributes are allowed constituents of static expressions (see 4.9).</s>
 <s id="3011">The first form of generic parameter declaration declares generic formal objects.</s>
 <s id="3012">The type of a generic formal object is the base type of the type denoted by the type mark given in the generic parameter declaration.</s>
 <s id="3013">A generic parameter declaration with several identifiers is equivalent to a sequence of single generic parameter declarations, as explained in section 3.2.</s>
 <s id="3014">A generic formal object has a mode that is either in or in out.</s>
 <s id="3015">In the absence of an explicit mode indication in a generic parameter declaration, the mode in is assumed; otherwise the mode is the one indicated.</s>
 <s id="3016">If a generic parameter declaration ends with an expression, the expression is the default expression of the generic formal parameter.</s>
 <s id="3017">A default expression is only allowed if the mode is in</s>
 <s id="3018">(whether this mode is indicated explicitly or implicitly).</s>
 <s id="3019">The type of a default expression must be that of the corresponding generic formal parameter.</s>
 <s id="3020">A generic formal object of mode in is a constant whose value is a copy of the value supplied as the matching generic actual parameter in a generic instantiation, as described in section 12.3.</s>
 <s id="3021">The type of a generic formal object of mode in must not be a limited type;</s>
 <s id="3022">the subtype of such a generic formal object is the subtype denoted by the type mark given in the generic parameter declaration.</s>
 <s id="3023">A generic formal object of mode in out is a variable and denotes the object supplied as the matching generic actual parameter in a generic instantiation, as described in section 12.3.</s>
 <s id="3024">The constraints that apply to the generic formal object are those of the corresponding generic actual parameter.</s>
 <s id="3025">The constraints that apply to a generic formal object of mode in out are those of the corresponding generic actual parameter</s>
 <s id="3026">(not those implied by the type mark that appears in the generic parameter declaration).</s>
 <s id="3027">Whenever possible (to avoid confusion) it is recommended that the name of a base type be used for the declaration of such a formal object.</s>
 <s id="3028">If, however, the base type is anonymous, it is recommended that the subtype name defined by the type declaration for the base type be used.</s>
 <s id="3029">A generic parameter declaration that includes a generic type definition or a private type declaration declares a generic formal type.</s>
 <s id="3030">A generic formal type denotes the subtype supplied as the corresponding actual parameter in a generic instantiation, as described in 12.3(d).</s>
 <s id="3031">However, within a generic unit, a generic formal type is considered as being distinct from all other (formal or nonformal) types.</s>
 <s id="3032">The form of constraint applicable to a formal type in a subtype indication depends on the class of the type as for a nonformal type.</s>
 <s id="3033">The only form of discrete range that is allowed within the declaration of a generic formal (constrained) array type is a type mark.</s>
 <s id="3034">The discriminant part of a generic formal private type must not include a default expression for a discriminant.</s>
 <s id="3035">(Consequently, a variable that is declared by an object declaration must be constrained if its type is a generic formal type with discriminants.)</s>
 <s id="3036">Within the declaration and body of a generic unit, the operations available for values of a generic formal type (apart from any additional operation specified by a generic formal subprogram) are determined by the generic parameter declaration for the formal type:</s>
 <s id="3037">For a private type declaration, the available operations are those defined in section 7.4.2</s>
 <s id="3038">(in particular, assignment, equality, and inequality are available for a private type unless it is limited).</s>
 <s id="3039">For an array type definition, the available operations are those defined in section 3.6.2</s>
 <s id="3040">(for example, they include the formation of indexed components and slices).</s>
 <s id="3041">For an access type definition, the available operations are those defined in section 3.8.2</s>
 <s id="3042">(for example, allocators can be used).</s>
 <s id="3043">The four forms of generic type definition in which a box appears (that is, the compound delimiter &lt;&gt;) correspond to the following major forms of scalar type:</s>
 <s id="3044">Discrete types: (&lt;&gt;)</s>
 <s id="3045">The available operations are the operations common to enumeration and integer types;</s>
 <s id="3046">these are defined in section 3.5.5.</s>
 <s id="3047">Integer types: range &lt;&gt;</s>
 <s id="3048">The available operations are the operations of integer types defined in section 3.5.5.</s>
 <s id="3049">Floating point types: digits &lt;&gt;</s>
 <s id="3050">The available operations are those defined in section 3.5.8.</s>
 <s id="3051">Fixed point types: delta &lt;&gt;</s>
 <s id="3052">The available operations are those defined in section 3.5.10.</s>
 <s id="3053">In all of the above cases (a) through (f), each operation implicitly associated with a formal type (that is, other than an operation specified by a formal subprogram) is implicitly declared at the place of the declaration of the formal type.</s>
 <s id="3054">The same holds for a formal fixed point type, except for the multiplying operators that deliver a result of the type universal fixed (see 4.5.5), since these special operators are declared in the package STANDARD.</s>
 <s id="3055">For an instantiation of the generic unit, each of these operations is the corresponding basic operation or predefined operator of the matching actual type.</s>
 <s id="3056">For an operator, this rule applies even if the operator has been redefined for the actual type or for some parent type of the actual type.</s>
 <s id="3057">Examples of generic formal types:</s>
 <s id="3058">Example of a generic formal part declaring a formal integer type:</s>
 <s id="3059">A generic parameter declaration that includes a subprogram specification declares a generic formal subprogram.</s>
 <s id="3060">Two alternative forms of defaults can be specified in the declaration of a generic formal subprogram.</s>
 <s id="3061">In these forms, the subprogram specification is followed by the reserved word is and either a box or the name of a subprogram or entry.</s>
 <s id="3062">The matching rules for these defaults are explained in section 12.3.6.</s>
 <s id="3063">A generic formal subprogram denotes the subprogram, enumeration literal, or entry supplied as the corresponding generic actual parameter in a generic instantiation, as described in section 12.3(f).</s>
 <s id="3064">Examples of generic formal subprograms:</s>
 <s id="3065">The constraints that apply to a parameter of a formal subprogram are those of the corresponding parameter in the specification of the matching actual subprogram</s>
 <s id="3066">(not those implied by the corresponding type mark in the specification of the formal subprogram).</s>
 <s id="3067">A similar remark applies to the result of a function.</s>
 <s id="3068">Whenever possible (to avoid confusion), it is recommended that the name of a base type be used rather than the name of a subtype in any declaration of a formal subprogram.</s>
 <s id="3069">If, however, the base type is anonymous, it is recommended that the subtype name defined by the type declaration be used.</s>
 <s id="3070">The type specified for a formal parameter of a generic formal subprogram can be any visible type, including a generic formal type of the same generic formal part.</s>
 <s id="3071">The body of a generic subprogram or generic package is a template for the bodies of the corresponding subprograms or packages obtained by generic instantiations.</s>
 <s id="3072">The syntax of a generic body is identical to that of a nongeneric body.</s>
 <s id="3073">For each declaration of a generic subprogram, there must be a corresponding body.</s>
 <s id="3074">The elaboration of a generic body has no other effect than to establish that the body can from then on be used as the template for obtaining the corresponding instances.</s>
 <s id="3075">Example of a generic procedure body:</s>
 <s id="3076">Example of a generic function body:</s>
 <s id="3077">Example of a generic package body:</s>
 <s id="3078">An instance of a generic unit is declared by a generic instantiation.</s>
 <s id="3079">An explicit generic actual parameter must be supplied for each generic formal parameter, unless the corresponding generic parameter declaration specifies that a default can be used.</s>
 <s id="3080">Generic associations can be either positional or named in the same manner as parameter associations of subprogram calls (see 6.4).</s>
 <s id="3081">If two or more formal subprograms have the same designator, then named associations are not allowed for the corresponding generic parameters.</s>
 <s id="3082">Each generic actual parameter must match the corresponding generic formal parameter.</s>
 <s id="3083">An expression can match a formal object of mode in;</s>
 <s id="3084">a variable name can match a formal object of mode in out;</s>
 <s id="3085">a subprogram name or an entry name can match a formal subprogram;</s>
 <s id="3086">a type mark can match a formal type.</s>
 <s id="3087">The detailed rules defining the allowed matches are given in sections 12.3.1 to 12.3.6; these are the only allowed matches.</s>
 <s id="3088">The instance is a copy of the generic unit, apart from the generic formal part;</s>
 <s id="3089">thus the instance of a generic package is a package, that of a generic procedure is a procedure, and that of a generic function is a function.</s>
 <s id="3090">For each occurrence, within the generic unit, of a name that denotes a given entity, the following list defines which entity is denoted by the corresponding occurrence within the instance.</s>
 <s id="3091">For a name that denotes the generic unit: The corresponding occurrence denotes the instance.</s>
 <s id="3092">For a name that denotes a generic formal object of mode in: The corresponding name denotes a constant whose value is a copy of the value of the associated generic actual parameter.</s>
 <s id="3093">For a name that denotes a generic formal object of mode in out: The corresponding name denotes the variable named by the associated generic actual parameter.</s>
 <s id="3094">For a name that denotes a generic formal type: The corresponding name denotes the subtype named by the associated generic actual parameter (the actual subtype).</s>
 <s id="3095">For a name that denotes a discriminant of a generic formal type: The corresponding name denotes the corresponding discriminant (there must be one) of the actual type associated with the generic formal type.</s>
 <s id="3096">For a name that denotes a generic formal subprogram: The corresponding name denotes the subprogram, enumeration literal, or entry named by the associated generic actual parameter (the actual subprogram).</s>
 <s id="3097">For a name that denotes a formal parameter of a generic formal subprogram: The corresponding name denotes the corresponding formal parameter of the actual subprogram associated with the formal subprogram.</s>
 <s id="3098">For a name that denotes a local entity declared within the generic unit: The corresponding name denotes the entity declared by the corresponding local declaration within the instance.</s>
 <s id="3099">For a name that denotes a global entity declared outside of the generic unit: The corresponding name denotes the same global entity.</s>
 <s id="3100">Similar rules apply to operators and basic operations: in particular, formal operators follow a rule similar to rule (f), local operations follow a rule similar to rule (h), and operations for global types follow a rule similar to rule (i).</s>
 <s id="3101">In addition, if within the generic unit a predefined operator or basic operation of a formal type is used, then within the instance the corresponding occurrence refers to the corresponding predefined operation of the actual type associated with the formal type.</s>
 <s id="3102">The above rules apply also to any type mark or (default) expression given within the generic formal part of the generic unit.</s>
 <s id="3103">For the elaboration of a generic instantiation, each expression supplied as an explicit generic actual parameter is first evaluated, as well as each expression that appears as a constituent of a variable name or entry name supplied as an explicit generic actual parameter;</s>
 <s id="3104">these evaluations proceed in some order that is not defined by the language.</s>
 <s id="3105">Then, for each omitted generic association (if any), the corresponding default expression or default name is evaluated;</s>
 <s id="3106">such evaluations are performed in the order of the generic parameter declarations.</s>
 <s id="3107">Finally, the implicitly generated instance is elaborated.</s>
 <s id="3108">The elaboration of a generic instantiation may also involve certain constraint checks as described in later subsections.</s>
 <s id="3109">Recursive generic instantiation is not allowed in the following sense: if a given generic unit includes an instantiation of a second generic unit, then the instance generated by this instantiation must not include an instance of the first generic unit</s>
 <s id="3110">(whether this instance is generated directly, or indirectly by intermediate instantiations).</s>
 <s id="3111">Examples of generic instantiations (see 12.1):</s>
 <s id="3112">Examples of uses of instantiated units:</s>
 <s id="3113">Omission of a generic actual parameter is only allowed if a corresponding default exists.</s>
 <s id="3114">If default expressions or default names (other than simple names) are used, they are evaluated in the order in which the corresponding generic formal parameters are declared.</s>
 <s id="3115">If two overloaded subprograms declared in a generic package specification differ only by the (formal) type of their parameters and results, then there exist legal instantiations for which all calls of these subprograms from outside the instance are ambiguous.</s>
 <s id="3116">For example:</s>
 <s id="3117">A generic formal parameter of mode in of a given type is matched by an expression of the same type.</s>
 <s id="3118">If a generic unit has a generic formal object of mode in, a check is made that the value of the expression belongs to the subtype denoted by the type mark, as for an explicit constant declaration (see 3.2.1).</s>
 <s id="3119">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="3120">A generic formal parameter of mode in out of a given type is matched by the name of a variable of the same type.</s>
 <s id="3121">The variable must not be a formal parameter of mode out or a subcomponent thereof.</s>
 <s id="3122">The name must denote a variable for which renaming is allowed (see 8.5).</s>
 <s id="3123">The type of a generic actual parameter of mode in must not be a limited type.</s>
 <s id="3124">The constraints that apply to a generic formal parameter of mode in out are those of the corresponding generic actual parameter (see 12.1.1).</s>
 <s id="3125">A generic formal private type is matched by any type or subtype (the actual subtype) that satisfies the following conditions:</s>
 <s id="3126">If the formal type is not limited, the actual type must not be a limited type.</s>
 <s id="3127">(If, on the other hand, the formal type is limited, no such condition is imposed on the corresponding actual type, which can be limited or not limited.)</s>
 <s id="3128">If the formal type has a discriminant part, the actual type must be a type with the same number of discriminants;</s>
 <s id="3129">the type of a discriminant that appears at a given position in the discriminant part of the actual type must be the same as the type of the discriminant that appears at the same position in the discriminant part of the formal type;</s>
 <s id="3130">and the actual subtype must be unconstrained.</s>
 <s id="3131">(If, on the other hand, the formal type has no discriminants, the actual type is allowed to have discriminants.)</s>
 <s id="3132">Furthermore, consider any occurrence of the name of the formal type at a place where this name is used as an unconstrained subtype indication.</s>
 <s id="3133">The actual subtype must not be an unconstrained array type or an unconstrained type with discriminants, if any of these occurrences is at a place where either a constraint or default discriminants would be required for an array type or for a type with discriminants (see 3.6.1 and 3.7.2).</s>
 <s id="3134">The same restriction applies to occurrences of the name of a subtype of the formal type, and to occurrences of the name of any type or subtype derived, directly or indirectly, from the formal type.</s>
 <s id="3135">If a generic unit has a formal private type with discriminants, the elaboration of a corresponding generic instantiation checks that the subtype of each discriminant of the actual type is the same as the subtype of the corresponding discriminant of the formal type.</s>
 <s id="3136">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="3137">A generic formal type defined by (&lt;&gt;) is matched by any discrete subtype (that is, any enumeration or integer subtype).</s>
 <s id="3138">A generic formal type defined by range &lt;&gt; is matched by any integer subtype.</s>
 <s id="3139">A generic formal type defined by digits &lt;&gt; is matched by any floating point subtype.</s>
 <s id="3140">A generic formal type defined by delta &lt;&gt; is matched by any fixed point subtype.</s>
 <s id="3141">No other matches are possible for these generic formal types.</s>
 <s id="3142">A formal array type is matched by an actual array subtype that satisfies the following conditions:</s>
 <s id="3143">The formal array type and the actual array type must have the same dimensionality;</s>
 <s id="3144">the formal type and the actual subtype must be either both constrained or both unconstrained.</s>
 <s id="3145">For each index position, the index type must be the same for the actual array type as for the formal array type.</s>
 <s id="3146">The component type must be the same for the actual array type as for the formal array type.</s>
 <s id="3147">If the component type is other than a scalar type, then the component subtypes must be either both constrained or both unconstrained.</s>
 <s id="3148">If a generic unit has a formal array type, the elaboration of a corresponding instantiation checks that the constraints (if any) on the component type are the same for the actual array type as for the formal array type, and likewise that for any given index position the index subtypes or the discrete ranges have the same bounds.</s>
 <s id="3149">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="3150">For the above rules, if any of the index or component types of the formal array type is itself a formal type, then within the instance its name denotes the corresponding actual subtype (see 12.3(d)).</s>
 <s id="3151">A formal access type is matched by an actual access subtype if the type of the designated objects is the same for the actual type as for the formal type.</s>
 <s id="3152">If the designated type is other than a scalar type, then the designated subtypes must be either both constrained or both unconstrained.</s>
 <s id="3153">If a generic unit has a formal access type, the elaboration of a corresponding instantiation checks that any constraints on the designated objects are the same for the actual access subtype as for the formal access type.</s>
 <s id="3154">The exception CONSTRAINT_ERROR is raised if this check fails.</s>
 <s id="3155">For the above rules, if the designated type is itself a formal type, then within the instance its name denotes the corresponding actual subtype (see 12.3(d)).</s>
 <s id="3156">A formal subprogram is matched by an actual subprogram, enumeration literal, or entry if both have the same parameter and result type profile (see 6.6); in addition, parameter modes must be identical for formal parameters that are at the same parameter position.</s>
 <s id="3157">If a generic unit has a default subprogram specified by a name, this name must denote a subprogram, an enumeration literal, or an entry, that matches the formal subprogram (in the above sense).</s>
 <s id="3158">The evaluation of the default name takes place during the elaboration of each instantiation that uses the default, as defined in section 12.3.</s>
 <s id="3159">If a generic unit has a default subprogram specified by a box, the corresponding actual parameter can be omitted if a subprogram, enumeration literal, or entry matching the formal subprogram, and with the same designator as the formal subprogram, is directly visible at the place of the generic instantiation; this subprogram, enumeration literal, or entry is then used by default (there must be exactly one subprogram, enumeration literal, or entry satisfying the previous conditions).</s>
 <s id="3160">The matching rules for formal subprograms state requirements that are similar to those applying to subprogram renaming declarations (see 8.5).</s>
 <s id="3161">In particular, the name of a parameter of the formal subprogram need not be the same as that of the corresponding parameter of the actual subprogram;</s>
 <s id="3162">similarly, for these parameters, default expressions need not correspond.</s>
 <s id="3163">A formal subprogram is matched by an attribute of a type if the attribute is a function with a matching specification.</s>
 <s id="3164">An enumeration literal of a given type matches a parameterless formal function whose result type is the given type.</s>
 <s id="3165">The following example provides a possible formulation of stacks by means of a generic package.</s>
 <s id="3166">The size of each stack and the type of the stack elements are provided as generic parameters.</s>
 <s id="3167">Instances of this generic package can be obtained as follows:</s>
 <s id="3168">Thereafter, the procedures of the instantiated packages can be called as follows:</s>
 <s id="3169">Alternatively, a generic formulation of the type STACK can be given as follows (package body omitted):</s>
 <s id="3170">In order to use such a package, an instantiation must be created and thereafter stacks of the corresponding type can be declared:</s>
 <s id="3171">This chapter describes representation clauses, certain implementation- dependent features, and other features that are used in system programming.</s>
 <s id="3172">Representation clauses specify how the types of the language are to be mapped onto the underlying machine.</s>
 <s id="3173">They can be provided to give more efficient representation or to interface with features that are outside the domain of the language (for example, peripheral hardware).</s>
 <s id="3174">A type representation clause applies either to a type or to a first named subtype</s>
 <s id="3175">(that is, to a subtype declared by a type declaration, the base type being therefore anonymous).</s>
 <s id="3176">Such a representation clause applies to all objects that have this type or this first named subtype.</s>
 <s id="3177">At most one enumeration or record representation clause is allowed for a given type: an enumeration representation clause is only allowed for an enumeration type; a record representation clause, only for a record type.</s>
 <s id="3178">(On the other hand, more than one length clause can be provided for a given type;</s>
 <s id="3179">moreover, both a length clause and an enumeration or record representation clause can be provided.)</s>
 <s id="3180">A length clause is the only form of representation clause allowed for a type derived from a parent type that has (user-defined) derivable subprograms.</s>
 <s id="3181">An address clause applies either to an object; to a subprogram, package, or task unit; or to an entry.</s>
 <s id="3182">At most one address clause is allowed for any of these entities.</s>
 <s id="3183">A representation clause and declaration of the entity to which the clause applies must both occur immediately within the same declarative part, package specification, or task specification;</s>
 <s id="3184">the declaration must occur before the clause.</s>
 <s id="3185">In the absence of a representation clause for a given declaration, a default representation of this declaration is determined by the implementation.</s>
 <s id="3186">Such a default determination occurs no later than the end of the immediately enclosing declarative part, package specification, or task specification.</s>
 <s id="3187">For a declaration given in a declarative part, this default determination occurs before any enclosed body.</s>
 <s id="3188">In the case of a type, certain occurrences of its name imply that the representation of the type must already have been determined.</s>
 <s id="3189">Consequently these occurrences force the default determination of any aspect of the representation not already determined by a prior type representation clause.</s>
 <s id="3190">This default determination is also forced by similar occurrences of the name of a subtype of the type, or of the name of any type or subtype that has subcomponents of the type.</s>
 <s id="3191">A forcing occurence is any occurrence other than in a type or subtype declaration, a subprogram specification, an entry declaration, a deferred constant declaration, a pragma, or a representation clause for the type itself.</s>
 <s id="3192">In any case, an occurrence within an expression is always forcing.</s>
 <s id="3193">A representation clause for a given entity must not appear after an occurrence of the name of the entity if this occurrence forces a default determination of representation for the entity.</s>
 <s id="3194">Similar restrictions exist for address clauses.</s>
 <s id="3195">For an object, any occurrence of its name (after the object declaration) is a forcing occurrence.</s>
 <s id="3196">For a subprogram, package, task unit, or entry, any occurrence of a representation attribute of such an entity is a forcing occurrence.</s>
 <s id="3197">The effect of the elaboration of a representation clause is to define the corresponding aspects of the representation.</s>
 <s id="3198">The interpretation of some of the expressions that appear in representation clauses is implementation dependent, for example, expressions specifying addresses.</s>
 <s id="3199">An implementation may limit its acceptance of representation clauses to those that can be handled simply by the underlying hardware.</s>
 <s id="3200">If a representation clause is accepted by an implementation, the compiler must guarantee that the net effect of the program is not changed by the presence of the clause, except for address clauses and for parts of the program that interrogate representation attributes.</s>
 <s id="3201">If a program contains a representation clause that is not accepted, the program is illegal.</s>
 <s id="3202">For each implementation, the allowed representation clauses, and the conventions used for implementation- dependent expressions, must be documented in Appendix F of the reference manual.</s>
 <s id="3203">Whereas a representation clause is used to impose certain characteristics of the mapping of an entity onto the underlying machine, pragmas can be used to provide an implementation, with criteria for its selection of such a mapping.</s>
 <s id="3204">The pragma PACK specifies that storage minimization should be the main criterion when selecting the representation of a record or array type.</s>
 <s id="3205">Its form is as follows:</s>
 <s id="3206">Packing means that gaps between the storage areas allocated to consecutive components should be minimized.</s>
 <s id="3207">It need not, however, affect the mapping of each component onto storage.</s>
 <s id="3208">This mapping can itself be influenced by a pragma (or controlled by a representation clause) for the component or component type.</s>
 <s id="3209">The position of a PACK pragma, and the restrictions on the named type, are governed by the same rules as for a representation clause;</s>
 <s id="3210">in particular, the pragma must appear before any use of a representation attribute of the packed entity.</s>
 <s id="3211">The pragma PACK is the only language-defied representation pragma.</s>
 <s id="3212">Additional representation pragmas may be provided by an implementation;</s>
 <s id="3213">these must be documented in Appendix F.</s>
 <s id="3214">(in contrast to representation clauses, a pragma that is not accepted by the implementation is ignored).</s>
 <s id="3215">No representation clause is allowed for a generic formal type.</s>
 <s id="3216">A length clause specifies an amount of storage associated with a type.</s>
 <s id="3217">The expression must be of some numeric type and is evaluated during the elaboration of the length clause</s>
 <s id="3218">(unless it is a static expression).</s>
 <s id="3219">The prefix of the attribute must denote either a type or a first named subtype.</s>
 <s id="3220">The prefix is called T in what follows.</s>
 <s id="3221">The only allowed attribute designators in a length clause are SIZE, STORAGE_SIZE, and SMALL.</s>
 <s id="3222">The effect of the length clause depends on the attribute designator:</s>
 <s id="3223">Size specification: T'SIZE</s>
 <s id="3224">The expression must be a static expression of some integer type.</s>
 <s id="3225">The value of the expression specifies an upper bound for the number of bits to be allocated to objects of the type or first named subtype T.</s>
 <s id="3226">The size specification must allow for enough storage space to accommodate every allowable value of these objects.</s>
 <s id="3227">A size specification for a composite type may affect the size of the gaps between the storage areas allocated to consecutive components.</s>
 <s id="3228">On the other hand, it need not affect the size of the storage area allocated to each component.</s>
 <s id="3229">The size specification is only allowed if the constraints on T and on its subcomponents (if any) are static.</s>
 <s id="3230">In the case of an unconstrained array type, the index subtypes must also be static.</s>
 <s id="3231">Specification of collection size: T'STORAGE_SIZE</s>
 <s id="3232">The prefix T must denote an access type.</s>
 <s id="3233">The expression must be of some integer type (but need not be static);</s>
 <s id="3234">its value specifies the number of storage units to be reserved for the collection, that is, the storage space needed to contain all objects designated by values of the access type and by values of other types derived form the access type, directly or indirectly.</s>
 <s id="3235">This form of length clause is not allowed for a type derived from an access type.</s>
 <s id="3236">Specification of storage for a task activation: T'STORAGE _SIZE</s>
 <s id="3237">The prefix T must denote a task type.</s>
 <s id="3238">The expression must be of some integer type (but need not be static);</s>
 <s id="3239">its value specifies the number of storage units to be reserved for an activation (not the code) of a task of the type.</s>
 <s id="3240">Specification of small for a fixed point type: T'SMALL</s>
 <s id="3241">The prefix T must denote the first named subtype of a fixed point type.</s>
 <s id="3242">The expression must be a static expression of some real type;</s>
 <s id="3243">its value must be greater than the delta of the first named subtype.</s>
 <s id="3244">The effect of the length clause is to use this value of small for the representation of values of the fixed point base type.</s>
 <s id="3245">(The length clause thereby also affects the amount of storage for objects that have this type).</s>
 <s id="3246">A size specification is allowed for an access, task, or fixed point type, whether or not another form of length clause is also given for the type.</s>
 <s id="3247">What is considered to be part of the storage reserved for a collection or for an activation of a task is implementation-dependent.</s>
 <s id="3248">The control afforded by length clauses is therefore relative to the implementation conventions.</s>
 <s id="3249">For example, the language does not define whether the storage reserved for an activation of a task includes any storage needed for the collection associated with an access type declared within the task body.</s>
 <s id="3250">Neither does it define the method of allocation for objects denoted by values of an access type.</s>
 <s id="3251">For example, the space allocated could be on a stack;</s>
 <s id="3252">alternatively, a general dynamic aliocation scheme or fixed storage could be used.</s>
 <s id="3253">The objects allocated in a collection need not have the same size if the designated type is an unconstrained array type or an unconstrained type with discriminants.</s>
 <s id="3254">Note also that the allocator itself may require some space for internal tables and links.</s>
 <s id="3255">Hence a length clause for the collection of an access type does not always give precise control over the maximum number of allocated objects.</s>
 <s id="3256">Notes on the examples:</s>
 <s id="3257">In the length clause for SHORT, fifteen bits is the minimum necessary, since the type definition requires SHORT'SMALL=2**(-7) and SHORT'MANTISSA = 14.</s>
 <s id="3258">The length clause for DEGREE forces the model numbers to exactly span the range of the type.</s>
 <s id="3259">An enumeration representation clause specifies the internal codes for the literals of the enumeration type that is named in the clause.</s>
 <s id="3260">The aggregate used to specify this mapping is written as a one-dimensional aggregate, for which the index subtype is the enumeration type and the component type is universal integer.</s>
 <s id="3261">All literals of the enumeration type must be provided with distinct integer codes, and all choices and component values given in the aggregate must be static.</s>
 <s id="3262">The integer codes specified for the enumeration type must satisfy the predefined ordering relation of the type.</s>
 <s id="3263">The attributes SUCC, PRED, and POS are defined even for enumeration types with a noncontiguous representation;</s>
 <s id="3264">their definition corresponds to the (logical) type declaration and is not affected by the enumeration representation clause.</s>
 <s id="3265">In the example, because of the need to avoid the omitted values, these functions are likely to be less efficiently implemented than they could be in the absence of a representation clause.</s>
 <s id="3266">Similar considerations apply when such types are used for indexing.</s>
 <s id="3267">A record representation clause specifies the storage representation of records, that is, the order, position, and size of record components (including discriminants, if any).</s>
 <s id="3268">The simple expression given after the reserved words at mod in an alignment clause, or after the reserved word at in a component clause, must be a static expression of some integer type.</s>
 <s id="3269">If the bounds of the range of a component clause are defined by simple expressions, then each bound of the range must be defined by a static expression of some integer type, but the two bounds need not have the same integer type.</s>
 <s id="3270">An alignment clause forces each record of the given type to be allocated at a starting address that is a multiple of the value of the given expression</s>
 <s id="3271">(that is, the address modulo the expression must be zero).</s>
 <s id="3272">An implementation may place restrictions on the allowable alignments.</s>
 <s id="3273">A component clause specifies the storage place of a component, relative to the start of the record.</s>
 <s id="3274">The integer defined by the static expression of a component clause is a relative address expressed in storage units.</s>
 <s id="3275">The range defines the bit positions of the storage place, relative to the storage unit.</s>
 <s id="3276">The first storage unit of a record is numbered zero.</s>
 <s id="3277">The first bit of a storage unit is numbered zero.</s>
 <s id="3278">The ordering of bits in a storage unit is machine dependent and may extend to adjacent storage units.</s>
 <s id="3279">(For a specific machine, the size in bits of a storage unit is given by the configuration-dependent named number SYSTEM.STORAGE_UNIT.)</s>
 <s id="3280">Whether a component is allowed to overlap a storage boundary, and if so, how, is implementation-defined.</s>
 <s id="3281">At most one component clause is allowed for each component of the record type, including for each discriminant</s>
 <s id="3282">(component clauses may be given for some, all, or none of the components).</s>
 <s id="3283">If no component clause is given for a component, then the choice of the storage place for the component is left to the compiler.</s>
 <s id="3284">If component clauses are given for all components, the record representation clause completely specifies the representation of the record type and must be obeyed exactly by the compiler.</s>
 <s id="3285">Storage places within a record variant must not overlap, but overlap of the storage for distinct variants is allowed.</s>
 <s id="3286">Each component clause must allow for enough storage space to accommodate every allowable value of the component.</s>
 <s id="3287">A component clause is only allowed for a component if any constraint on this component or on any of its subcomponents is static.</s>
 <s id="3288">An implementation may generate names that denote implementation-dependent components (for example, one containing the offset of another component).</s>
 <s id="3289">Such implementation-dependent names can be used in record representation clauses</s>
 <s id="3290">(these names need not be simple names; for example, they could be implementation-dependent attributes).</s>
 <s id="3291">Note on the example:</s>
 <s id="3292">The record representation clause defines the record layout.</s>
 <s id="3293">The length clause guarantees that exactly eight storage units are used.</s>
 <s id="3294">An address clause specifies a required address in storage for an entity.</s>
 <s id="3295">The expression given after the reserved word at must be of the type ADDRESS defined in the package SYSTEM (see 13.7);</s>
 <s id="3296">this package must be named by a with clause that applies to the compilation unit in which the address clause occurs.</s>
 <s id="3297">The conventions that define the interpretation of a value of the type ADDRESS as an address, as an interrupt level, or whatever it may be, are implementation-dependent.</s>
 <s id="3298">The allowed nature of the simple name and the meaning of the corresponding address are as follows:</s>
 <s id="3299">Name of an object: the address is that required for the object (variable or constant).</s>
 <s id="3300">Name of a subprogram, package, or task unit: the address is that required for the machine code associated with the body of the program unit.</s>
 <s id="3301">Name of a single entry: the address specifies a hardware interrupt to which the single entry is to be linked.</s>
 <s id="3302">If the simple name is that of a single task, the address clause is understood to refer to the task unit and not to the task object.</s>
 <s id="3303">In all cases, the address clause is only legal if exactly one declaration with this identifier occurs earlier, immediately within the same declarative part, package specification, or task specification.</s>
 <s id="3304">A name declared by a renaming declaration is not allowed as the simple name.</s>
 <s id="3305">Address clauses should not be used to achieve overlays of objects or overlays of program units.</s>
 <s id="3306">Nor should a given interrupt be linked to more than one entry.</s>
 <s id="3307">Any program using address clauses to achieve such effects is erroneous.</s>
 <s id="3308">The above rules imply that if two subprograms overload each other and are visible at a given point, an address clause for any of them is not legal at this point.</s>
 <s id="3309">Similarly if a task specification declares entries that overload each other, they cannot be interrupt entries.</s>
 <s id="3310">The syntax does not allow an address clause for a library unit.</s>
 <s id="3311">An implementation may provide pragmas for the specification of program overlays.</s>
 <s id="3312">An address clause given for an entry associates the entry with some device that may cause an interrupt;</s>
 <s id="3313">such an entry is referred to in this section as an interrupt entry.</s>
 <s id="3314">If control information is supplied upon an interrupt, it is passed to an associated interrupt entry as one or more parameters of mode in;</s>
 <s id="3315">only parameters of this mode are allowed.</s>
 <s id="3316">An interrupt acts as an entry call issued by a hardware task whose priority is higher than the priority of the main program, and also higher than the priority of any user-defined task</s>
 <s id="3317">(that is, any task whose type is declared by a task unit in the program).</s>
 <s id="3318">The entry call may be an ordinary entry call, a timed entry call, or a conditional entry call, depending on the kind of interrupt and on the implementation.</s>
 <s id="3319">If a select statement contains both a terminate alternative and an accept alternative for an interrupt entry, then an implementation may impose further requirements for the selection of the terminate alternative in addition to those given in section 9.4.</s>
 <s id="3320">Interrupt entry calls need only have the semantics described above;</s>
 <s id="3321">they may be implemented by having the hardware directly execute the appropriate accept statements.</s>
 <s id="3322">Queued interrupts correspond to ordinary entry calls.</s>
 <s id="3323">Interrupts that are lost if not immediately processed correspond to conditional entry calls.</s>
 <s id="3324">It is a consequence of the priority rules that an accept statement executed in response to an interrupt takes precedence over ordinary, user-defined tasks, and can be executed without first invoking a scheduling action.</s>
 <s id="3325">One of the possible effects of an address clause for an interrupt entry is to specify the priority of the interrupt (directly or indirectly).</s>
 <s id="3326">Direct calls to an interrupt entry are allowed.</s>
 <s id="3327">At most one representation clause is allowed for a given type and a given aspect of its representation.</s>
 <s id="3328">Hence, if an alternative representation is needed, it is necessary to declare a second type, derived from the first, and to specify a different representation for the second type.</s>
 <s id="3329">Change of representation can now be accomplished by assignment with explicit type conversions:</s>
 <s id="3330">For each implementation there is a predefined library package called SYSTEM which includes the definitions of certain configuration-dependent characteristics.</s>
 <s id="3331">The specification of the package SYSTEM is implementation-dependent and must be given in Appendix F.</s>
 <s id="3332">The visible part of this package must contain at least the following declarations.</s>
 <s id="3333">The type ADDRESS is the type of the addresses provided in address clauses;</s>
 <s id="3334">it is also the type of the result delivered by the attribute ADDRESS.</s>
 <s id="3335">Values of the enumeration type NAME are the names of alternative machine configurations handled by the implementation;</s>
 <s id="3336">one of these is the constant SYSTEM_NAME.</s>
 <s id="3337">The named number STORAGE_UNIT is the number of bits per storage unit; the named number MEMORY_SIZE is the number of available storage units in the configuration; these named numbers are of the type universal integer.</s>
 <s id="3338">An alternative form of the package SYSTEM, with given values for any of SYSTEM_NAME, STORAGE_UNIT, and MEMORY_SIZE, can be obtained by means of the corresponding pragmas.</s>
 <s id="3339">These pragmas are only allowed at the start of a compilation, before the first compilation unit (if any) of the compilation.</s>
 <s id="3340">The effect of the above pragma is to use the enumeration literal with the specified identifier for the definition of the constant SYSTEM_NAME.</s>
 <s id="3341">This pragma is only allowed if the specified identifier corresponds to one of the literals of the type NAME.</s>
 <s id="3342">The effect of the above pragma is to use the value of the specified numeric literal for the definition of the named number STORAGE_UNIT.</s>
 <s id="3343">The effect of the above pragma is to use the value of the specified numeric literal for the definition of the named number MEMORY_SIZE.</s>
 <s id="3344">The compilation of any of these pragmas causes an implicit recompilation of the package SYSTEM.</s>
 <s id="3345">Consequently any compilation unit that names SYSTEM in its context clause becomes obsolete after this implicit recompilation.</s>
 <s id="3346">An implementation may impose further limitations on the use of these pragmas.</s>
 <s id="3347">For example, an implementation may allow them only at the start of the first compilation, when creating a new program library.</s>
 <s id="3348">It is a consequence of the visibility rules that a declaration given in the package SYSTEM is not visible in a compilation unit unless this package is mentioned by a with clause that applies (directly or indirectly) to the compilation unit.</s>
 <s id="3349">Within the package SYSTEM, the following named numbers are declared.</s>
 <s id="3350">The numbers FINE_DELTA and TICK are of the type universal real; the others are of the type universal integer.</s>
 <s id="3351">The smallest (most negative) value of all predefined integer types.</s>
 <s id="3352">The largest (most positive) value of all predefined integer types.</s>
 <s id="3353">The largest value allowed for the number of significant decimal digits in a floating point constraint.</s>
 <s id="3354">The largest possible number of binary digits in the mantissa of model numbers of a fixed point subtype.</s>
 <p id="p3355">
  <s id="3355.1">The smallest delta allowed in a fixed point constraint that has the range constraint -1.0 ..</s>
  <s id="3355.2">1.0.</s>
 </p>
 <s id="3356">The basic clock period, in seconds.</s>
 <s id="3357">The values of certain implementation-dependent characteristics can be obtatined by interrogating appropriate representation attributes.</s>
 <s id="3358">These attributes are described below.</s>
 <s id="3359">For any object, program unit, label, or entry X:</s>
 <s id="3360">Yields the address of the first of the storage units allocated to X.</s>
 <s id="3361">For a subprogram, package, task unit or label, this value refers to the machine code associated with the corresponding body or statement.</s>
 <s id="3362">For an entry for which an address clause has been given, the value refers to the corresponding hardware interrupt.</s>
 <s id="3363">The value of this attribute is of the type ADDRESS defined in the package SYSTEM.</s>
 <s id="3364">For any type or subtype X or for any object X:</s>
 <s id="3365">Applied to an object, yields the number of bits allocated to hold the object.</s>
 <s id="3366">Applied to a type or subtype, yields the minimum number of bits that is needed by the implementation to hold any possible object of this type or subtype.</s>
 <s id="3367">The value of this attribute is of the type universal integer.</s>
 <s id="3368">For the above two representation attributes, if the prefix is the name of a function, the attribute is understood to be an attribute of the function (not of the result of calling the function).</s>
 <s id="3369">Similarly, if the type of the prefix is an access type, the attribute is understood to be an attribute of the prefix</s>
 <s id="3370">(not of the designated object: attributes of the latter can be written with a prefix ending with the reserved word all).</s>
 <s id="3371">For any component C of a record object R:</s>
 <s id="3372">Yields the offset, from the start of the first storage unit occupied by the record, of the first of the storage units occupied by C.</s>
 <s id="3373">This offset is measured in storage units.</s>
 <s id="3374">The value of this attribute is of the type universal integer.</s>
 <s id="3375">Yields the offset, from the start of the first of the storage units occupied by C, of the last bit occupied by C.</s>
 <s id="3376">This offset is measured in bits.</s>
 <s id="3377">The value of this attribute is of the type universal integer.</s>
 <s id="3378">Yields the offset, from the start of the first of the storage units occupied by C, of the last bit occupied by C.</s>
 <s id="3379">This offset is measured in bits.</s>
 <s id="3380">The value of this attribute is of the type universal integer.</s>
 <s id="3381">For any access type or subtype T:</s>
 <s id="3382">Yields the total number of storage units reserved for the collection associated with the base type of T.</s>
 <s id="3383">The value of this attribute is of the type universal integer.</s>
 <s id="3384">For any task type or task object T:</s>
 <s id="3385">Yields the number of storage units reserved for each activation of a task of the type T or for the activation of the task object T.</s>
 <s id="3386">The value of this attribute is of the type universal integer.</s>
 <s id="3387">For a task object X, the attribute X'SIZE gives the number of bits used to hold the object X, whereas X'STORAGE_SIZE gives the number of storage units allocated for the activation of the task designated by X.</s>
 <s id="3388">For a formal parameter X, if parameter passing is achieved by copy, then the attribute X'ADDRESS yields the address of the local copy;</s>
 <s id="3389">if parameter passing is by reference, then the address is that of the actual parameter.</s>
 <s id="3390">For every real type or subtype T, the following machine-dependent attributes are defined, which are not related to the model numbers.</s>
 <s id="3391">Programs using these attributes may thereby exploit properties that go beyond the minimal properties associated with the numeric type</s>
 <s id="3392">(see section 4.5.7 for the rules defining the accuracy of operations with real operands).</s>
 <s id="3393">Precautions must therefore be taken when using these machine- dependent attributes if portability is to be ensured.</s>
 <s id="3394">For both floating point and fixed point types:</s>
 <s id="3395">Yields the value TRUE if every predefined arithmetic operation on values of the base type of T either returns an exact result or performs rounding;</s>
 <s id="3396">yields the value FALSE otherwise.</s>
 <s id="3397">The value of this attribute is of the predefined type BOOLEAN.</s>
 <s id="3398">Yields the value TRUE if every predefined operation on values of the base type of T either provides a correct result, or raises the exception NUMERIC_ERROR in overflow situations (see 4.5.7);</s>
 <s id="3399">yields the value FALSE otherwise.</s>
 <s id="3400">The value of this attribute is of the predefined type BOOLEAN.</s>
 <s id="3401">For floating point types, the following attributes provide characteristics of the underlying machine representation, in terms of the canonical form defined in section 3.5.7:</s>
 <s id="3402">Yields the value of the radix used by the machine representation of the base type of T (the digits are extended digits in the range 0 to T'MACHINE_RADIX -1).</s>
 <s id="3403">The value of this attribute is of the type universal integer.</s>
 <s id="3404">Yields the largest value of exponent for the machine representation of the base type of T.</s>
 <s id="3405">The value of this attribute is of the type universal integer.</s>
 <s id="3406">Yields the smallest (most negative) value of exponent for the machine representation of the base type of T.</s>
 <s id="3407">The value of this attribute is of the type universal integer.</s>
 <s id="3408">For many machines the largest machine representable number of type F is almost X and the smallest positive representable number is Y.</s>
 <s id="3409">A machine code insertion can be achieved by a call to a procedure whose sequence of statements contains code statements.</s>
 <s id="3410">A code statement is only allowed in the sequence of statements of a procedure body.</s>
 <s id="3411">If a procedure body contains code statements, then within this procedure body the only allowed form of statement is a code statement (labeled or not), the only allowed declarative items are use clauses, and no exception handler is allowed</s>
 <s id="3412">(comments and pragmas are allowed as usual).</s>
 <s id="3413">Each machine instruction appears as a record aggregate of a record type that defines the corresponding instruction.</s>
 <s id="3414">The base type of the type mark of a code statement must be declared within the predefined library package called MACHINE_CODE;</s>
 <s id="3415">this package must be named by a with clause that applies to the compilation unit in which the code statement occurs.</s>
 <s id="3416">An implementation is not required to provide such a package.</s>
 <s id="3417">An implementation is allowed to impose further restrictions on the record aggregates allowed in code statements.</s>
 <s id="3418">For example, it may require that expressions contained in such aggregates be static expressions.</s>
 <s id="3419">An implementation may provide machine-dependent pragmas specifying register conventions and calling conventions.</s>
 <s id="3420">Such pragmas must be documented in Appendix F</s>
 <s id="3421">A subprogram written in another language can be called from an Ada program provided that all communication is achieved via parameters and function results.</s>
 <s id="3422">A pragma of the next form must be given for each such subprogram;</s>
 <s id="3423">a subprogram name is allowed to stand for several overloaded subprograms.</s>
 <s id="3424">This pragma is allowed at the place of a declarative item, and must apply in this case to a subprogram declared by an earlier declarative item of the same declarative part or package specification.</s>
 <s id="3425">The pragma is also allowed for a library unit;</s>
 <s id="3426">in this case the pragma must appear after the subprogram declaration, and before any subsequent compilation unit.</s>
 <s id="3427">The pragma specifies the other language (and therby the calling conventions ) and informs the compiler that an object module will be supplied for the corresponding subprogram.</s>
 <s id="3428">A body is not allowed for such a subprogram (not even in the form of a body stub) since the instructions of the subprogram are written in another language.</s>
 <s id="3429">This capability need not be provided by all implementations.</s>
 <s id="3430">An implementation may place restrictions on the allowable forms and places of parameters and calls.</s>
 <s id="3431">The conventions used by other language processors that call Ada programs are not part of the Ada language definition.</s>
 <s id="3432">Such conventions must be defined by these other language processors.</s>
 <s id="3433">The pragma INTERFACE is not defined for generic subprograms.</s>
 <s id="3434">The predefined generic library subprograms UNCHECKED_DEALLOCATION and UNCHECKED_CONVERSION are used for unchecked storage deallocation and for unchecked type conversions.</s>
 <s id="3435">Unchecked storage deallocation of an object designated by a value of an access type is achieved by a call of a procedure that is obtained by instantiation of the generic procedure UNCHECKED_DEALLOCATION.</s>
 <s id="3436">For example:</s>
 <s id="3437">Such a FREE procedure has the following effect:</s>
 <s id="3438">after executing FREE(X), the value of X is null</s>
 <s id="3439">FREE(X), when X is already equal to null, has no effect</s>
 <s id="3440">FREE(X), when X is not equal to null, is an indication that the object designated by X is no longer required, and that the storage it occupies is to be reclaimed.</s>
 <s id="3441">If X and Y designate the same object, then accessing this object through Y is erroneous if this access is performed (or attempted) after the call FREE(X);</s>
 <s id="3442">the efeect of each such access is not defined by the language.</s>
 <s id="3443">It is a consequence of the visibility rules that the generic procedure UNCHECKED_DEALLOCATION is not visible in a compilation unit unless this generic procedure is mentioned by a with clause that applies to the compilation unit.</s>
 <s id="3444">If X designates a task object, the call FREE(X); has no effect on the task designated by the value of this task object.</s>
 <s id="3445">The same holds for any subcomponent of the object designated by X, if this subcomponent is a task object.</s>
 <s id="3446">An unchecked type conversion can be achieved by a call of a function that is obtained by instantiation of the generic function UNCHECKED_CONVERSION.</s>
 <s id="3447">The effect of an unchecked conversion is to return the (uninterpreted) parameter value as a value of the target type, that is, the bit pattern defining the source value is returned unchanged as the bit pattern defining a value of the target type.</s>
 <s id="3448">An implementation may place restrictions on unchecked conversions, for example, restrictions dependeing on the respective sizes of objects of the source and target type.</s>
 <s id="3449">Such restrictions must be documented in appendix F.</s>
 <s id="3450">Whenever unchecked conversions are used, it is the programmer's responsibility to ensure that these conversions maintain the properties that are guaranteed by the language for objects of the target type.</s>
 <s id="3451">Programs that violate these properties by means of unchecked conversions are erroneous.</s>
 <s id="3452">It is a consequence of the visibility rules that the generic function UNCHECKED_CONVERSION is not visible in a compilation unit unless this generic function is mentioned by a with clause that applies to the compilation unit.</s>
 <s id="3453">Input-output is provided in the language by means of predefined packages.</s>
 <s id="3454">The generic packages SEQUENTIAL_IO and DIRECT_IO define input-output operations applicable to files containing elements of a given type.</s>
 <s id="3455">Additional operations for text input-output are supplied in the package TEXT_IO.</s>
 <s id="3456">The package IO_EXCEPTIONS defines the exceptions needed by the above three packages.</s>
 <s id="3457">Finally, a package LOW_LEVEL_IO is provided for direct control of peripheral devices.</s>
 <s id="3458">Values input from the external environment of the program, or output to the environment, are considered to occupy external files.</s>
 <s id="3459">An external file can be anything external to the program that can produce a value to be read or receive a value to be written.</s>
 <s id="3460">An external file is identified by a string (the name).</s>
 <s id="3461">A second string (the form) gives further system-dependent characteristics that may be associated with the file, such as the physical organization or access rights.</s>
 <s id="3462">The conventions governing the interpretation of such strings must be documented in Appendix F.</s>
 <s id="3463">Input and output operations are expressed as operations on objects of some file type, rather than directly in terms of the external files.</s>
 <s id="3464">In the remainder of this chapter, the term file is always used to refer to a file object;</s>
 <s id="3465">the term external file is used otherwise.</s>
 <s id="3466">The values transferred for a given file must all be of one type.</s>
 <s id="3467">Input-output for sequential files of values of a single element type is defined by means of the generic package SEQUENTIAL_IO.</s>
 <s id="3468">The skeleton of this package is given below.</s>
 <s id="3469">In order to define sequential input-output for a given element type, an instantiation of this generic unit, with the given type as actual parameter, must be declared.</s>
 <s id="3470">The resulting package contains the declaration of a file type (called FILE_TYPE) for files of such elements, as well as the operations applicable to these files, such as the OPEN, READ, and WRITE procedures.</s>
 <s id="3471">Input-output for direct access files is likewise defined by a generic package called DIRECT_IO.</s>
 <s id="3472">Input-output in human-readable form is defined by the (nongeneric) package TEXT_IO.</s>
 <s id="3473">Before input or output operations can be performed on a file, the file must first be associated with an external file.</s>
 <s id="3474">While such an association is in effect, the file is said to be open, and otherwise the file is said to be closed.</s>
 <s id="3475">The language does not define what happens to external files after the completion of the main program</s>
 <s id="3476">(in particular, if corresponding files have not been closed).</s>
 <s id="3477">The effect of input-output for access types is implementation-dependent.</s>
 <s id="3478">An open file has a current mode, which is a value of one of the enumeration types</s>
 <s id="3479">These values correspond respectively to the cases where only reading, both reading and writing, or only writing are to be performed.</s>
 <s id="3480">The mode of a file can be changed.</s>
 <s id="3481">Several file management operations are common to the three input-output packages.</s>
 <s id="3482">These operations are described in section 14.2.1 for sequential and direct files.</s>
 <s id="3483">Any additional effects concerning text input-output are described in section 14.3.1.</s>
 <s id="3484">The exceptions that can be raised by a call of an input-output subprogram are all defined in the package IO_EXCEPTIONS;</s>
 <s id="3485">the situations in which they can be raised are described, either following the description of the subprogram (and in section 14.4), or in Appendix F in the case of error situations that are implementation-dependent.</s>
 <s id="3486">Each instantiation of the generic packages SEQUENTIAL_IO and DIRECT_IO declares a different type FILE_TYPE;</s>
 <s id="3487">in the case of TEXT_IO, the type FILE_TYPE is unique.</s>
 <s id="3488">A bidirectional device can often be modeled as two sequential files associated with the device, one of mode IN_FILE, and one of mode OUT_FILE.</s>
 <s id="3489">An implementation may restrict the number of files that may be associated with a given external file.</s>
 <s id="3490">The effect of sharing an external file in this way by several file objects is implementation-dependent.</s>
 <s id="3491">Two kinds of access to external files are defined: sequential access and direct access.</s>
 <s id="3492">The corresponding file types and the associated operations are provided by the generic packages SEQUENTIAL_IO and DIRECT_IO.</s>
 <s id="3493">A file object to be used for sequential access is called a sequential file, and one to be used for direct access is called a direct file.</s>
 <s id="3494">For sequential access, the file is viewed as a sequence of values that are transferred in the order of their appearance (as produced by the program or by the environment).</s>
 <s id="3495">When the file is opened, transfer starts from the beginning of the file.</s>
 <s id="3496">For direct access, the file is viewed as a set of elements occupying consecutive positions in linear order;</s>
 <s id="3497">a value can be transferred to or from an element of the file at any selected position.</s>
 <s id="3498">The position of an element is specified by its index, which is a number, greater than zero, of the implementation-defined integer type COUNT.</s>
 <s id="3499">The first element, if any, has index one;</s>
 <s id="3500">the index of the last element, if any, is called the current size;</s>
 <s id="3501">the current size is zero if there are no elements.</s>
 <s id="3502">The current size is a property of the external file.</s>
 <s id="3503">An open direct file has a current index, which is the index that will be used by the next read or write operation.</s>
 <s id="3504">When a direct file is opened, the current index is set to one.</s>
 <s id="3505">The current index of a direct file is a property of a file object, not of an external file.</s>
 <s id="3506">All three file modes are allowed for direct files.</s>
 <s id="3507">The only allowed modes for sequential files are the modes IN_FILE and OUT_FILE.</s>
 <s id="3508">The procedures and functions described in this section provide for the control of external files;</s>
 <s id="3509">their declarations are repeated in each of the three packages for sequential, direct, and text input-output.</s>
 <s id="3510">For text input-output, the procedures CREATE, OPEN, and RESET have additional effects described in section 14.3.1.</s>
 <s id="3511">Establishes a new external file, with the given name and form, and associates this external file with the given file.</s>
 <s id="3512">The given file is left open.</s>
 <s id="3513">The current mode of the given file is set to the given access mode.</s>
 <s id="3514">The default access mode is the mode OUT_FILE for sequential and text input-output; it is the mode INOUT_FILE for direct input-output.</s>
 <s id="3515">For direct access, the size of the created file is implementation-dependent.</s>
 <s id="3516">A null string for NAME specifies an external file that is not accessible after the completion of the main program (a temporary file).</s>
 <s id="3517">A null string for FORM specifies the use of the default options of the implementation for the external file.</s>
 <s id="3518">The exception STATUS_ERROR is raised if the given file is already open.</s>
 <s id="3519">The exception NAME_ERROR is raised if the string given as NAME does not allow the identification of an external file.</s>
 <s id="3520">The exception USE_ERROR is raised if, for the specified mode, the environment does not support creation of an external file with the given name (in the absence of NAME_ERROR) and form.</s>
 <s id="3521">Associates the given file with an existing external file having the given name and form, and sets the current mode of the given file to the given mode.</s>
 <s id="3522">The given file is left open.</s>
 <s id="3523">The exception STATUS_ERROR is raised if the given file is already open.</s>
 <s id="3524">The exception NAME_ERROR is raised if the string given as NAME does not allow the identification of an external file;</s>
 <s id="3525">in particular, this exception is raised if no external file with the given name exists.</s>
 <s id="3526">The exception USE_ERROR is raised if, for the specified mode, the environment does not support opening for an external file with the given name (in the absence of NAME_ERROR) and form.</s>
 <s id="3527">Severs the association between the given file and its associated external file.</s>
 <s id="3528">The given file is left closed.</s>
 <s id="3529">The exception STATUS_ERROR is raised if the given file is not open.</s>
 <s id="3530">Deletes the external file associated with the given file.</s>
 <s id="3531">The given file is closed, and the external file ceases to exist.</s>
 <s id="3532">The exception STATUS_ERROR is raised if the given file is not open.</s>
 <s id="3533">The exception USE_ERROR is raised if (as fully defined in Appendix F) deletion of the external file is not supported by the environment.</s>
 <s id="3534">Resets the given file so that reading from or writing to its elements can be restarted from the beginning of the file;</s>
 <s id="3535">in particular, for direct access this means that the current index is set to one.</s>
 <s id="3536">If a MODE parameter is supplied, the current mode of the given file is set to the given mode.</s>
 <s id="3537">The exception STATUS_ERROR is raised if the file is not open.</s>
 <s id="3538">The exception USE_ERROR is raised if the environment does not support resetting for the external file and, also, if the environment does not support resetting to the specified mode for the external file.</s>
 <s id="3539">Returns the current mode of the given file.</s>
 <s id="3540">The exception STATUS_ERROR is raised if the file is not open.</s>
 <s id="3541">Returns a string which uniquely identifies the external file currently associated with the given file (and may thus be used in an OPEN operation).</s>
 <s id="3542">If an environment allows alternative specifications of the name (for example, abbreviations), the string returned by the function should correspond to a full specification of the name.</s>
 <s id="3543">The exception STATUS_ERROR is raised if the given file is not open.</s>
 <s id="3544">Returns the form string for the external file currently associated with the given file.</s>
 <s id="3545">If an environment allows alternative specifications of the form (for example, abbreviations using default options), the string returned by the function should correspond to a full specification</s>
 <s id="3546">(that is, it should indicate explicitly all options selected, including default options).</s>
 <s id="3547">The exception STATUS_ERROR is raised if the given file is not open.</s>
 <s id="3548">Returns TRUE if the file is open (that is, if it is associated with an external file), otherwise returns FALSE.</s>
 <s id="3549">The operations available for sequential input and output are described in this section.</s>
 <s id="3550">The exception STATUS_ERROR is raised if any of these operations is attempted for a file that is not open.</s>
 <s id="3551">Operates on a file of mode IN_FILE.</s>
 <s id="3552">Reads an element from the given file, and returns the value of this element in the ITEM parameter.</s>
 <s id="3553">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3554">The exception END_ERROR is raised if no more elements can be read from the given file.</s>
 <s id="3555">The exception DATA_ERROR is raised if the element read cannot be interpreted as a value of the type ELEMENT_TYPE;</s>
 <s id="3556">however, an implementation is allowed to omit this check if performing the check is too complex.</s>
 <s id="3557">Operates on a file of mode OUT_FILE.</s>
 <s id="3558">Writes the value of ITEM to the given file.</s>
 <s id="3559">The exception MODE_ERROR is raised if the mode is not OUT_FILE.</s>
 <s id="3560">The exception USE_ERROR is raised if the capacity of the external file is exceeded.</s>
 <s id="3561">Operates on a file of mode IN_FILE.</s>
 <s id="3562">Returns TRUE if no more elements can be read from the given file; otherwise returns FALSE.</s>
 <s id="3563">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3564">The operations available for direct input and output are described in this section.</s>
 <s id="3565">The exception STATUS_ERROR is raised if any of these operations is attempted for a file that is not open.</s>
 <s id="3566">Operates on a file of mode IN_FILE or INOUT_FILE.</s>
 <s id="3567">In the case of the first form, sets the current index of the given file to the index value given by the parameter FROM.</s>
 <s id="3568">Then (for both forms) returns, in the parameter ITEM, the value of the element whose position in the given file is specified by the current index of the file;</s>
 <s id="3569">finally, increases the current index by one.</s>
 <s id="3570">The exception MODE_ERROR is raised if the mode of the given file is OUT_FILE.</s>
 <s id="3571">The exception END_ERROR is raised if the index to be used exceeds the size of the external file.</s>
 <s id="3572">The exception DATA_ERROR is raised if the element read cannot be interpreted as a value of the type ELEMENT_TYPE;</s>
 <s id="3573">however, an implementation is allowed to omit this check if performing the check is too complex.</s>
 <s id="3574">Operates on a file of mode INOUT_FILE or OUT_FILE.</s>
 <s id="3575">In the case of the first form, sets the index of the given file to the index value given by the parameter TO.</s>
 <s id="3576">Then (for both forms) gives the value of the parameter ITEM to the element whose position in the given file is specified by the current index of the file;</s>
 <s id="3577">finally, increases the current index by one.</s>
 <s id="3578">The exception MODE_ERROR is raised if the mode of the given file is IN_FILE.</s>
 <s id="3579">The exception USE_ERROR is raised if the capacity of the external file is exceeded.</s>
 <s id="3580">Operates on a file of any mode.</s>
 <s id="3581">Sets the current index of the given file to the given index value</s>
 <s id="3582">(which may exceed the current size of the file).</s>
 <s id="3583">Operates on a file of any mode.</s>
 <s id="3584">Returns the current index of the given file.</s>
 <s id="3585">Operates on a file of any mode.</s>
 <s id="3586">Returns the current size of the external file that is associated with the given file.</s>
 <s id="3587">Operates on a file of mode IN_FILE or INOUT_FILE.</s>
 <s id="3588">Returns TRUE if the current index exceeds the size of the external file; otherwise returns FALSE.</s>
 <s id="3589">The exception MODE_ERROR is raised if the mode of the given file is OUT_FILE.</s>
 <s id="3590">This section describes the package TEXT_IO, which provides facilities for input and output in human-readable form.</s>
 <s id="3591">Each file is read or written sequentially, as a sequence of characters grouped into lines, and as a sequence of lines grouped into pages.</s>
 <s id="3592">The specification of the package is given below in section 14.3.10.</s>
 <s id="3593">The facilities for file management given above, in sections 14.2.1 and 14.2.2, are available for text input-output.</s>
 <s id="3594">In place of READ and WRITE, however, there are procedures GET and PUT that input values of suitable types from text files, and output values to them.</s>
 <s id="3595">These values are provided to the PUT procedures, and returned by the GET procedures, in a parameter ITEM.</s>
 <s id="3596">Several overloaded procedures of these names exist, for different types of ITEM.</s>
 <s id="3597">These GET procedures analyze the input sequences of characters as lexical elements (see Chapter 2) and return the corresponding values;</s>
 <s id="3598">the PUT procedures output the given values as appropriate lexical elements.</s>
 <s id="3599">Procedures GET and PUT are also available that input and output individual characters treated as character values rather than as lexical elements.</s>
 <s id="3600">In addition to the procedures GET and PUT for numeric and enumeration types of ITEM that operate on text files, analogous procedures are provided that read from and write to a parameter of type STRING.</s>
 <s id="3601">These procedures perform the same analysis and composition of character sequences as their counterparts which have a file parameter.</s>
 <s id="3602">For all GET and PUT procedures that operate on text files, and for many other subprograms, there are forms with and without a file parameter.</s>
 <s id="3603">Each such GET procedure operates on an input file, and each such PUT procedure operates on an output file.</s>
 <s id="3604">If no file is specified, a default input file or a default output file is used.</s>
 <s id="3605">At the beginning of program execution the default input and output files are the so-called standard input file and standard output file.</s>
 <s id="3606">These files are open, have respectively the current modes IN_FILE and OUT_FILE, and are associated with two implementation-defined external files.</s>
 <s id="3607">Procedures are provided to change the current default input file and the current default output file.</s>
 <s id="3608">From a logical point of view, a text file is a sequence of pages, a page is a sequence of lines, and a line is a sequence of characters;</s>
 <s id="3609">the end of a line is marked by a line terminator;</s>
 <s id="3610">the end of a page is marked by the combination of a line terminator immediately followed by a page terminator;</s>
 <s id="3611">and the end of a file is marked by the combination of a line terminator immediately followed by a page terminator and then a file terminator.</s>
 <s id="3612">Terminators are generated during output; either by calls of procedures provided expressly for that purpose; or implicitly as part of other operations, for example, when a bounded line length, a bounded page length, or both, have been specified for a file.</s>
 <s id="3613">The actual nature of terminators is not defined by the language and hence depends on the implementation.</s>
 <s id="3614">Although terminators are recognized or generated by certain of the procedures that follow, they are not necessarily implemented as characters or as sequences of characters.</s>
 <s id="3615">Whether they are characters (and if so which ones) in any particular implementation need not concern a user who neither explicitly outputs nor explicitly inputs control characters.</s>
 <s id="3616">The effect of input or output of control characters (other than horizontal tabulation) is not defined by the language.</s>
 <s id="3617">The characters of a line are numbered, starting from one;</s>
 <s id="3618">the number of a character is called its column number.</s>
 <s id="3619">For a line terminator, a column number is also defined: it is one more than the number of characters in the line.</s>
 <s id="3620">The lines of a page, and the pages of a file, are similarly numbered.</s>
 <s id="3621">The current column number is the column number of the next character or line terminator to be transferred.</s>
 <s id="3622">The current line number is the number of the current line.</s>
 <s id="3623">The current page number is the number of the current page.</s>
 <s id="3624">These numbers are values of the subtype POSITIVE_COUNT of the type COUNT</s>
 <s id="3625">(by convention, the value zero of the type COUNT is used to indicate special conditions).</s>
 <s id="3626">For an output file, a maximum line length can be specified and a maximum page length can be specified.</s>
 <s id="3627">If a value to be output cannot fit on the current line, for a specified maximum line length, then a new line is automatically started before the value is output;</s>
 <s id="3628">if, further, this new line cannot fit on the current page, for a specified maximum page length, then a new page is automatically started before the value is output.</s>
 <s id="3629">Functions are provided to determine the maximum line length and the maximum page length.</s>
 <s id="3630">When a file is opened with mode OUT_FILE, both values are zero: by convention, this means that the line lengths and page lengths are unbounded.</s>
 <s id="3631">(Consequently, output consists of a single line if the subprograms for explicit control of line and page structure are not used.)</s>
 <s id="3632">The constant UNBOUNDED is provided for this purpose.</s>
 <s id="3633">The only allowed file modes for text files are the modes IN_FILE and OUT_FILE.</s>
 <s id="3634">The subprograms given in section 14.2.1 for the control of external files, and the function END_OF_FILE given in section 14.2.2 for sequential input-output, are also available for text files.</s>
 <s id="3635">There is also a version of END_OF_FILE that refers to the current default input file.</s>
 <s id="3636">For text files, the procedures have the following additional effects:</s>
 <s id="3637">For the procedures CREATE and OPEN: After opening a file with mode OUT_FILE, the page length and line length are unbounded (both have the conventional value zero).</s>
 <s id="3638">After opening a file with mode IN_FILE or OUT_FILE, the current column, current line, and current page numbers are set to one.</s>
 <s id="3639">For the procedure CLOSE: If the file has the current mode OUT_FILE, has the effect of calling NEW_PAGE, unless the current page is already terminated;</s>
 <s id="3640">then outputs a file terminator.</s>
 <s id="3641">For the procedure RESET: If the file has the current mode OUT_FILE, has the effect of calling NEW_PAGE, unless the current page is already terminated;</s>
 <s id="3642">then outputs a file terminator.</s>
 <s id="3643">If the new file mode is OUT_FILE, the page and line lengths are unbounded.</s>
 <s id="3644">For all modes, the current column, line, and page numbers are set to one.</s>
 <s id="3645">The exception MODE_ERROR is raised by the procedure RESET upon an attempt to change the mode of a file that is either the current default input file, or the current default output file.</s>
 <s id="3646">The following subprograms provide for the control of the particular default files that are used when a file parameter is omitted from a GET, PUT or other operation of text input-output described below.</s>
 <s id="3647">Operates on a file of mode IN_FILE.</s>
 <s id="3648">Sets the current default input file to FILE.</s>
 <s id="3649">The exception STATUS_ERROR is raised if the given file is not open.</s>
 <s id="3650">The exception MODE_ERROR is raised if the mode of the given file is not IN_FILE.</s>
 <s id="3651">Operates on a file of mode OUT_FILE.</s>
 <s id="3652">Sets the current default output file to FILE.</s>
 <s id="3653">The exception STATUS_ERROR is raised if the given file is not open.</s>
 <s id="3654">The exception MODE_ERROR is raised if the mode of the given file is not OUT_FILE.</s>
 <s id="3655">Returns the standard input file (see 14.3).</s>
 <s id="3656">Returns the standard output file (see 14.3).</s>
 <s id="3657">Returns the current default input file.</s>
 <s id="3658">Returns the current default output file.</s>
 <s id="3659">The standard input and the standard output files cannot be opened, closed, reset, or deleted, because the parameter FILE of the corresponding procedures has the mode in out.</s>
 <s id="3660">The subprograms described in this section are concerned with the line and page structure of a file of mode OUT_FILE.</s>
 <s id="3661">They operate either on the file given as the first parameter, or, in the absence of such a file parameter, on the current default output file.</s>
 <s id="3662">They provide for output of text with a specified maximum line length or page length.</s>
 <s id="3663">In these cases, line and page terminators are output implicitly and automatically when needed.</s>
 <s id="3664">When line and page lengths are unbounded (that is, when they have the conventional value zero), as in the case of a newly opened file, new lines and new pages are only started when explicitly called for.</s>
 <s id="3665">In all cases, the exception STATUS_ERROR is raised if the file to be used is not open;</s>
 <s id="3666">the exception MODE_ERROR is raised if the mode of the file is not OUT_FILE.</s>
 <s id="3667">Sets the maximum line length of the specified output file to the number of characters specified by TO.</s>
 <s id="3668">The value zero for TO specifies an unbounded line length.</s>
 <s id="3669">The exception USE_ERROR is raised if the specified line length is inappropriate for the associated external file.</s>
 <s id="3670">Sets the maximum page length of the specified output file to the number of lines specified by TO.</s>
 <s id="3671">The value zero for TO specifies an unbounded page length.</s>
 <s id="3672">The exception USE_ERROR is raised if the specified page length is inappropriate for the associated external file.</s>
 <s id="3673">Returns the maximum line length currently set for the specified output file, or zero if the line length is unbounded.</s>
 <s id="3674">Returns the maximum page length currently set for the specified output file, or zero if the page length is unbounded.</s>
 <s id="3675">The subprograms described in this section provide for explicit control of line and page structure;</s>
 <s id="3676">they operate either on the file given as the first parameter, or, in the absence of such a file parameter, on the appropriate (input or output) current default file.</s>
 <s id="3677">The exception STATUS_ERROR is raised by any of these subprograms if the file to be used is not open.</s>
 <s id="3678">Operates on a file of mode OUT_FILE.</s>
 <s id="3679">For a SPACING of one: Outputs a line terminator and sets the current column number to one.</s>
 <s id="3680">Then increments the current line number by one, except in the case that the current line number is already greater than or equal to the maximum page length, for a bounded page length;</s>
 <s id="3681">in that case a page terminator is output, the current page number is incremented by one, and the current line number is set to one.</s>
 <s id="3682">For a SPACING greater than one, the above actions are performed SPACING times.</s>
 <s id="3683">The exception MODE_ERROR is raised if the mode is not OUT_FILE.</s>
 <s id="3684">Operates on a file of mode IN_FILE.</s>
 <s id="3685">For a SPACING of one: Reads and discards all characters until a line terminator has been read, and then sets the current column number to one.</s>
 <s id="3686">If the line terminator is not immediately followed by a page terminator, the current line number is incremented by one.</s>
 <s id="3687">Otherwise, if the line terminator is immediately followed by a page terminator, then the page terminator is skipped, the current page number is incremented by one, and the current line number is set to one.</s>
 <s id="3688">For a SPACING greater than one, the above actions are performed SPACING times.</s>
 <s id="3689">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3690">The exception END_ERROR is raised if an attempt is made to read a file terminator.</s>
 <s id="3691">Operates on a file of mode IN_FILE.</s>
 <s id="3692">Returns TRUE if a line terminator or a file terminator is next;</s>
 <s id="3693">otherwise returns FALSE.</s>
 <s id="3694">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3695">Operates on a file of mode OUT_FILE.</s>
 <s id="3696">Outputs a line terminator if the current line is not terminated, or if the current page is empty</s>
 <s id="3697">(that is, if the current column and line numbers are both equal to one).</s>
 <s id="3698">Then outputs a page terminator, which terminates the current page.</s>
 <s id="3699">Adds one to the current page number and sets the current column and line numbers to one.</s>
 <s id="3700">The exception MODE_ERROR is raised if the mode is not OUT_FILE.</s>
 <s id="3701">Operates on a file of mode IN_FILE.</s>
 <s id="3702">Reads and discards all characters and line terminators until a page terminator has been read.</s>
 <s id="3703">Then adds one to the current page number, and sets the current column and line numbers to one.</s>
 <s id="3704">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3705">The exception END_ERROR is raised if an attempt is made to read a file terminator.</s>
 <s id="3706">Operates on a file of mode IN_FILE.</s>
 <s id="3707">Returns TRUE if the combination of a line terminator and a page terminator is next, or if a file terminator is next;</s>
 <s id="3708">otherwise returns FALSE.</s>
 <s id="3709">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3710">Operates on a file of mode IN_FILE.</s>
 <s id="3711">Returns TRUE if a file terminator is next, or if the combination of a line, a page, and a file terminator is next;</s>
 <s id="3712">otherwise returns FALSE.</s>
 <s id="3713">The exception MODE_ERROR is raised if the mode is not IN_FILE.</s>
 <s id="3714">The following subprograms provide for the control of the current position of reading or writing in a file.</s>
 <s id="3715">In all cases, the default file is the current output file.</s>
 <s id="3716">If the file mode is OUT_FILE:</s>
 <s id="3717">If the value specified by TO is greater than the current column number, outputs spaces, adding one to the current column number after each space, until the current column number equals the specified value.</s>
 <s id="3718">If the value specified by TO is equal to the current column number, there is no effect.</s>
 <s id="3719">If the value specified by TO is less than the current column number, has the effect of calling NEW_LINE (with a spacing of one), then outputs (TO - 1) spaces, and sets the current column number to the specified value.</s>
 <s id="3720">The exception LAYOUT_ERROR is raised if the value specified by TO exceeds LINE_LENGTH when the line length is bounded (that is, when it does not have the conventional value zero).</s>
 <s id="3721">If the file mode is IN_FILE:</s>
 <s id="3722">Reads (and discards) individual characters, line terminators, and page terminators, until the next character to be read has a column number that equals the value specified by TO;</s>
 <s id="3723">there is no effect if the current column number already equals this value.</s>
 <s id="3724">Each transfer of a character or terminator maintains the current column, line, and page numbers in the same way as a GET procedure (see 14.3.5).</s>
 <s id="3725">(Short lines will be skipped until a line is reached that has a character at the specified column position.)</s>
 <s id="3726">The exception END_ERROR is raised if an attempt is made to read a file terminator.</s>
 <s id="3727">If the file mode is OUT_FILE:</s>
 <s id="3728">If the value specified by TO is greater than the current line number, has the effect of repeatedly calling NEW_LINE (with a spacing of one), until the current line number equals the specified value.</s>
 <s id="3729">If the value specified by TO is equal to the current line number, there is no effect.</s>
 <s id="3730">If the value specified by TO is less than the current line number, has the effect of calling NEW_PAGE followed by a call of NEW_LINE with a spacing equal to (TO - 1).</s>
 <s id="3731">The exception LAYOUT_ERROR is raised if the value specified by TO exceeds PAGE_LENGTH when the page length is bounded (that is, when it does not have the conventional value zero).</s>
 <s id="3732">If the mode is IN_FILE:</s>
 <s id="3733">Has the effect of repeatedly calling SKIP_LINE (with a spacing of one), until the current line number equals the value specified by TO;</s>
 <s id="3734">there is no effect if the current line number already equals this value.</s>
 <s id="3735">(Short pages will be skipped until a page is reached that has a line at the specified line position.)</s>
 <s id="3736">The exception END_ERROR is raised if an attempt is made to read a file terminator.</s>
 <s id="3737">Returns the current column number.</s>
 <s id="3738">The exception LAYOUT_ERROR is raised if this number exceeds COUNT'LAST.</s>
 <s id="3739">Returns the current line number.</s>
 <s id="3740">The exception LAYOUT_ERROR is raised if this number exceeds COUNT'LAST.</s>
 <s id="3741">Returns the current page number.</s>
 <s id="3742">The exception LAYOUT_ERROR is raised if this number exceeds COUNT'LAST.</s>
 <s id="3743">The column number, line number, or page number are allowed to exceed COUNT'LAST</s>
 <s id="3744">(as a consequence of the input or output of sufficiently many characters, lines, or pages).</s>
 <s id="3745">These events do not cause any exception to be raised.</s>
 <s id="3746">However, a call of COL, LINE, or PAGE raises the exception LAYOUT_ERROR if the corresponding number exceeds COUNT'LAST.</s>
 <s id="3747">A page terminator is always skipped whenever the preceding line terminator is skipped.</s>
 <s id="3748">An implementation may represent the combination of these terminators by a single character, provided that it is properly recognized at input.</s>
 <s id="3749">The procedures GET and PUT for items of the types CHARACTER, STRING, numeric types, and enumeration types are described in subsequent sections.</s>
 <s id="3750">Features of these procedures that are common to most of these types are described in this section.</s>
 <s id="3751">The GET and PUT procedures for items of type CHARACTER and STRING deal with individual character values; the GET and PUT procedures for numeric and enumeration types treat the items as lexical elements.</s>
 <s id="3752">All procedures GET and PUT have forms with a file parameter, written first.</s>
 <s id="3753">Where this parameter is omitted, the appropriate (input or output) current default file is understood to be specified.</s>
 <s id="3754">Each procedure GET operates on a file of mode IN_FILE.</s>
 <s id="3755">Each procedure PUT operates on a file of mode OUT_FILE.</s>
 <s id="3756">All procedures GET and PUT maintain the current column, line, and page numbers of the specified file: the effect of each of these procedures upon these numbers is the resultant of the effects of individual transfers of characters and of individual output or skipping of terminators.</s>
 <s id="3757">Each transfer of a character adds one to the current column number.</s>
 <s id="3758">Each output of a line terminator sets the current column number to one and adds one to the current line number.</s>
 <s id="3759">Each output of a page terminator sets the current column and line numbers to one and adds one to the current page number.</s>
 <s id="3760">For input, each skipping of a line terminator sets the current column number to one and adds one to the current line number;</s>
 <s id="3761">each skipping of a page terminator sets the current column and line numbers to one and adds one to the current page number.</s>
 <s id="3762">Similar considerations apply to the procedures GET_LINE, PUT_LINE, and SET_COL.</s>
 <s id="3763">Several GET and PUT procedures, for numeric and enumeration types, have format parameters which specify field lengths; these parameters are of the nonnegative subtype FIELD of the type INTEGER.</s>
 <s id="3764">Input-output of enumeration values uses the syntax of the corresponding lexical elements.</s>
 <s id="3765">Any GET procedure for an enumeration type begins by skipping any leading blanks, or line or page terminators;</s>
 <s id="3766">a blank being defined as a space or a horizontal tabulation character.</s>
 <s id="3767">Next, characters are input only so long as the sequence input is an initial sequence of an identifier or of a character literal</s>
 <s id="3768">(in particular, input ceases when a line terminator is encountered).</s>
 <s id="3769">The character or line terminator that causes input to cease remains available for subsequent input.</s>
 <s id="3770">For a numeric type, the GET procedures have a format parameter called WIDTH.</s>
 <s id="3771">If the value given for this parameter is zero, the GET procedure proceeds in the same manner as for enumeration types, but using the syntax of numeric literals instead of that of enumeration literals.</s>
 <s id="3772">If a nonzero value is given, then exactly WIDTH characters are input, or the characters up to a line terminator, whichever comes first;</s>
 <s id="3773">any skipped leading blanks are included in the count.</s>
 <s id="3774">The syntax used for numeric literals is an extended syntax that allows a leading sign</s>
 <s id="3775">(but no intervening blanks, or line or page terminators).</s>
 <s id="3776">Any PUT procedure, for an item of a numeric or an enumeration type, outputs the value of the item as a numeric literal, identifier, or character literal, as appropriate.</s>
 <s id="3777">This is preceded by leading spaces if required by the format parameters WIDTH or FORE (as described in later sections), and then a minus sign for a negative value;</s>
 <s id="3778">for an enumeration type, the spaces follow instead of leading.</s>
 <s id="3779">The format given for a PUT procedure is overridden if it is insufficiently wide.</s>
 <s id="3780">Two further cases arise for PUT procedures for numeric and enumeration types, if the line length of the specified output file is bounded</s>
 <s id="3781">(that is, if it does not have the conventional value zero).</s>
 <s id="3782">If the number of characters to be output does not exceed the maximum line length, but is such that they cannot fit on the current line, starting from the current column, then (in effect) NEW_LINE is called (with a spacing of one) before output of the item.</s>
 <s id="3783">Otherwise, if the number of characters exceeds the maximum line length, then the exception LAYOUT_ERROR is raised and no characters are output.</s>
 <s id="3784">The exception STATUS_ERROR is raised by any of the procedures GET, GET_LINE, PUT, and PUT_LINE if the file to be used is not open.</s>
 <s id="3785">The exception MODE_ERROR is raised by the procedures GET and GET_LINE if the mode of the file to be used is not IN_FILE; and by the procedures PUT and PUT_LINE, if the mode is not OUT_FILE.</s>
 <s id="3786">The exception END_ERROR is raised by a GET procedure if an attempt is made to skip a file terminator.</s>
 <s id="3787">The exception DATA_ERROR is raised by a GET procedure if the sequence finally input is not a lexical element corresponding to the type, in particular if no characters were input;</s>
 <s id="3788">for this test, leading blanks are ignored;</s>
 <s id="3789">for an item of a numeric type, when a sign is input, this rule applies to the succeeding numeric literal.</s>
 <s id="3790">The exception LAYOUT_ERROR is raised by a PUT procedure that outputs to a parameter of type STRING, if the length of the actual string is insufficient for the output of the item.</s>
 <s id="3791">In the examples, here and in sections 14.3.7 and 14.3.8, the string quotes and the lower case letter b are not transferred: they are shown only to reveal the layout and spaces.</s>
 <s id="3792">Example of overridden width parameter:</s>
 <s id="3793">For an item of type CHARACTER the following procedures are provided:</s>
 <s id="3794">After skipping any line terminators and any page terminators, reads the next character from the specified input file and returns the value of this character in the out parameter ITEM.</s>
 <s id="3795">The exception END_ERROR is raised if an attempt is made to skip a file terminator.</s>
 <s id="3796">If the line length of the specified output file is bounded (that is, does not have the conventional value zero), and the current column number exceeds it, has the effect of calling NEW_LINE with a spacing of one.</s>
 <s id="3797">Then, or otherwise, outputs the given character to the file.</s>
 <s id="3798">For an item of type STRING the following procedures are provided:</s>
 <s id="3799">Determines the length of the given string and attempts that number of GET operations for successive characters of the string</s>
 <s id="3800">(in particular, no operation is performed if the string is null).</s>
 <s id="3801">Determines the length of the given string and attempts that number of PUT operations for successive characters of the string</s>
 <s id="3802">(in particular, no operation is performed if the string is null).</s>
 <s id="3803">Replaces successive characters of the specified string by successive characters read from the specified input file.</s>
 <s id="3804">Reading stops if the end of the line is met, in which case the procedure SKIP_LINE is then called (in effect) with a spacing of one;</s>
 <s id="3805">reading also stops if the end of the string is met.</s>
 <s id="3806">Characters not replaced are left undefined.</s>
 <s id="3807">If characters are read, returns in LAST the index value such that ITEM(LAST) is the last character replaced</s>
 <s id="3808">(the index of the first character replaced is ITEM'FIRST).</s>
 <s id="3809">If no characters are read, returns in LAST an index value that is one less than ITEM'FIRST.</s>
 <s id="3810">The exception END_ERROR is raised if an attempt is made to skip a file terminator.</s>
 <s id="3811">Calls the procedure PUT for the given string, and then the procedure NEW_LINE with a spacing of one.</s>
 <s id="3812">In a literal string parameter of PUT, the enclosing string bracket characters are not output.</s>
 <s id="3813">Each doubled string bracket character in the enclosed string is output as a single string bracket character, as a consequence of the rule for string literals (see 2.6).</s>
 <s id="3814">A string read by GET or written by PUT can extend over several lines.</s>
 <s id="3815">The following procedures are defined in the generic package INTEGER_IO.</s>
 <s id="3816">This must be instantiated for the appropriate integer type (indicated by NUM in the specification).</s>
 <s id="3817">Values are output as decimal or based literals, without underline characters or exponent, and preceded by a minus sign if negative.</s>
 <s id="3818">The format (which includes any leading spaces and minus sign) can be specified by an optional field width parameter.</s>
 <s id="3819">Values of widths of fields in output formats are of the nonnegative integer subtype FIELD.</s>
 <s id="3820">Values of bases are of the integer subtype NUMBER_BASE.</s>
 <s id="3821">The default field width and base to be used by output procedures are defined by the following variables that are declared in the generic package INTEGER_IO:</s>
 <s id="3822">The following procedures are provided:</s>
 <s id="3823">If the value of the parameter WIDTH is zero, skips any leading blanks, line terminators, or page terminators, then reads a plus or a minus sign if present, then reads according to the syntax of an integer literal</s>
 <s id="3824">(which may be a based literal).</s>
 <s id="3825">If a nonzero value of WIDTH is supplied, then exactly WIDTH characters are input, or the characters (possibly none) up to a line terminator, whichever comes first;</s>
 <s id="3826">any skipped leading blanks are included in the count.</s>
 <s id="3827">Returns, in the parameter ITEM, the value of type NUM that corresponds to the sequence input.</s>
 <s id="3828">The exception DATA_ERROR is raised if the sequence input does not have the required syntax or if the value obtained is not of the subtype NUM.</s>
 <s id="3829">Outputs the value of the parameter ITEM as an integer literal, with no underlines, no exponent, and no leading zeros (but a single zero for the value zero), and a preceding minus sign for a negative value.</s>
 <s id="3830">If the resulting sequence of characters to be output has fewer than WIDTH characters, then leading spaces are first output to make up the difference.</s>
 <s id="3831">Uses the syntax for decimal literal if the parameter BASE has the value ten (either explicitly or through DEFAULT_BASE); otherwise, uses the syntax for based literal, with any letters in upper case.</s>
 <s id="3832">Reads an integer value from the beginning of the given string, following the same rules as the GET procedure that reads an integer value from a file, but treating the end of the string as a file terminator.</s>
 <s id="3833">Returns, in the parameter ITEM, the value of type NUM that corresponds to the sequence input.</s>
 <s id="3834">Returns in LAST the index value such that FROM(LAST) is the last character read.</s>
 <s id="3835">The exception DATA_ERROR is raised if the sequence input does not have the required syntax or if the value obtained is not of the subtype NUM.</s>
 <s id="3836">Outputs the value of the parameter ITEM to the given string, following the same rule as for output to a file, using the length of the given string as the value for WIDTH.</s>
 <s id="3837">The following procedures are defined in the generic packages FLOAT_IO and FIXED_IO, which must be instantiated for the appropriate floating point or fixed point type respectively (indicated by NUM in the specifications).</s>
 <s id="3838">Values are output as decimal literals without underline characters.</s>
 <s id="3839">The format of each value output consists of a FORE field, a decimal point, an AFT field, and (if a nonzero EXP parameter is supplied) the letter E and an EXP field.</s>
 <s id="3840">The two possible formats thus correspond to:</s>
 <s id="3841">and to:</s>
 <s id="3842">without any spaces between these fields.</s>
 <s id="3843">The FORE field may include leading spaces, and a minus sign for negative values.</s>
 <s id="3844">The AFT field includes only decimal digits (possibly with trailing zeros).</s>
 <s id="3845">The EXP field includes the sign (plus or minus) and the exponent (possibly with leading zeros).</s>
 <s id="3846">For floating point types, the default lengths of these fields are defined by the following variables that are declared in the generic package FLOAT_IO:</s>
 <s id="3847">For fixed point types, the default lengths of these fields are defined by the following variables that are declared in the generic package FIXED_IO:</s>
 <s id="3848">The following procedures are provided:</s>
 <s id="3849">If the value of the parameter WIDTH is zero, skips any leading blanks, line terminators, or page terminators, then reads a plus or a minus sign if present, then reads according to the syntax of a real literal</s>
 <s id="3850">(which may be a based literal).</s>
 <s id="3851">If a nonzero value of WIDTH is supplied, then exactly WIDTH characters are input, or the characters (possibly none) up to a line terminator, whichever comes first;</s>
 <s id="3852">any skipped leading blanks are included in the count.</s>
 <s id="3853">Returns, in the parameter ITEM, the value of type NUM that corresponds to the sequence input.</s>
 <s id="3854">The exception DATA_ERROR is raised if the sequence input does not have the required syntax or if the value obtained is not of the subtype NUM.</s>
 <s id="3855">Outputs the value of the parameter ITEM as a decimal literal with the format defined by FORE, AFT and EXP.</s>
 <s id="3856">If the value is negative, a minus sign is included in the integer part.</s>
 <s id="3857">If EXP has the value zero, then the integer part to be output has as many digits as are needed to represent the integer part of the value of ITEM, overriding FORE if necessary,</s>
 <s id="3858">or consists of the digit zero if the value of ITEM has no integer part.</s>
 <s id="3859">If EXP has a value greater than zero, then the integer part to be output has a single digit, which is nonzero except for the value 0.0 of ITEM.</s>
 <s id="3860">In both cases, however, if the integer part to be output has fewer than FORE characters, including any minus sign, then leading spaces are first output to make up the difference.</s>
 <s id="3861">The number of digits of the fractional part is given by AFT, or is one if AFT equals zero.</s>
 <s id="3862">The value is rounded;</s>
 <s id="3863">a value of exactly one half in the last place may be rounded either up or down.</s>
 <s id="3864">If EXP has the value zero, there is no exponent part.</s>
 <s id="3865">If EXP has a value greater than zero, then the exponent part to be output has as many digits as are needed to represent the exponent part of the value of ITEM (for which a single digit integer part is used), and includes an initial sign (plus or minus).</s>
 <s id="3866">If the exponent part to be output has fewer than EXP characters, including the sign, then leading zeros precede the digits, to make up the difference.</s>
 <s id="3867">For the value 0.0 of ITEM, the exponent has the value zero.</s>
 <s id="3868">Reads a real value from the beginning of the given string, following the same rule as the GET procedure that reads a real value from a file, but treating the end of the string as a file terminator.</s>
 <s id="3869">Returns, in the parameter ITEM, the value of type NUM that corresponds to the sequence input.</s>
 <s id="3870">Returns in LAST the index value such that FROM(LAST) is the last character read.</s>
 <s id="3871">The exception DATA_ERROR is raised if the sequence input does not have the required syntax, or if the value obtained is not of the subtype NUM.</s>
 <s id="3872">Outputs the value of the parameter ITEM to the given string, following the same rule as for output to a file, using a value for FORE such that the sequence of characters output exactly fills the string, including any leading spaces.</s>
 <s id="3873">For an item with a positive value, if output to a string exactly fills the string without leading spaces, then output of the corresponding negative value will raise LAYOUT_ERROR.</s>
 <s id="3874">The following procedures are defined in the generic package ENUMERATION_IO, which must be instantiated for the appropriate enumeration type (indicated by ENUM in the specification).</s>
 <s id="3875">Values are output using either upper or lower case letters for identifiers.</s>
 <s id="3876">This is specified by the parameter SET, which is of the enumeration type TYPE_SET.</s>
 <s id="3877">The format (which includes any trailing spaces) can be specified by an optional field width parameter.</s>
 <s id="3878">The default field width and letter case are defined by the following variables that are declared in the generic package ENUMERATION_IO:</s>
 <s id="3879">The following procedures are provided:</s>
 <s id="3880">After skipping any leading blanks, line terminators, or page terminators, reads an identifier according to the syntax of this lexical element (lower and upper case being considered equivalent), or a character literal according to the syntax of this lexical element (including the apostrophes).</s>
 <s id="3881">Returns, in the parameter ITEM, the value of type ENUM that corresponds to the sequence input.</s>
 <s id="3882">The exception DATA_ERROR is raised if the sequence input does not have the required syntax, or if the identifier or character literal does not correspond to a value of the subtype ENUM.</s>
 <s id="3883">Outputs the value of the parameter ITEM as an enumeration literal (either an identifier or a character literal).</s>
 <s id="3884">The optional parameter SET indicates whether lower case or upper case is used for identifiers; it has no effect for character literals.</s>
 <s id="3885">If the sequence of characters produced has fewer than WIDTH characters, then trailing spaces are finally output to make up the difference.</s>
 <s id="3886">Reads an enumeration value from the beginning of the given string, following the same rule as the GET procedure that reads an enumeration value from a file, but treating the end of the string as a file terminator.</s>
 <s id="3887">Returns, in the parameter ITEM, the value of type ENUM that corresponds to the sequence input.</s>
 <s id="3888">Returns in LAST the index value such that FROM(LAST) is the last character read.</s>
 <s id="3889">The exception DATA_ERROR is raised if the sequence input does not have the required syntax, or if the identifier or character literal does not correspond to a value of the subtype ENUM.</s>
 <s id="3890">Outputs the value of the parameter ITEM to the given string, following the same rule as for output to a file, using the length of the given string as the value for WIDTH.</s>
 <s id="3891">Although the specification of the package ENUMERATION_IO would allow instantiation for an integer type, this is not the intended purpose of this generic package, and the effect of such instantiations is not defined by the language.</s>
 <s id="3892">There is a difference between PUT defined for characters, and for enumeration values.</s>
 <s id="3893">The type BOOLEAN is an enumeration type, hence ENUMERATION_IO can be instantiated for this type.</s>
 <s id="3894">The following exceptions can be raised by input-output operations.</s>
 <s id="3895">They are declared in the package IO_EXCEPTIONS, defined in section 14.5;</s>
 <s id="3896">this package is named in the context clause for each of the three input-output packages.</s>
 <s id="3897">Only outline descriptions are given of the conditions under which NAME_ERROR, USE_ERROR, and DEVICE_ERROR are raised;</s>
 <s id="3898">for full details see Appendix F.</s>
 <s id="3899">If more than one error condition exists, the corresponding exception that appears earliest in the following list is the one that is raised.</s>
 <s id="3900">The exception STATUS_ERROR is raised by an attempt to operate upon a file that is not open, and by an attempt to open a file that is already open.</s>
 <s id="3901">The exception MODE_ERROR is raised by an attempt to read from, or test for the end of, a file whose current mode is OUT_FILE, and also by an attempt to write to a file whose current mode is IN_FILE.</s>
 <s id="3902">In the case of TEXT_IO, the exception MODE_ERROR is also raised by specifying a file whose current mode is OUT_FILE in a call of SET_INPUT, SKIP_LINE, END_OF_LINE, SKIP_PAGE, or END_OF_PAGE; and by specifying a file whose current mode is IN_FILE in a call of SET_OUTPUT, SET_LINE_LENGTH, SET_PAGE_LENGTH, LINE_LENGTH, PAGE_LENGTH, NEW_LINE, or NEW_PAGE.</s>
 <s id="3903">The exception NAME_ERROR is raised by a call of CREATE or OPEN if the string given for the parameter NAME does not allow the identification of an external file.</s>
 <s id="3904">For example, this exception is raised if the string is improper, or, alternatively, if either none or more than one external file corresponds to the string.</s>
 <s id="3905">The exception USE_ERROR is raised if an operation is attempted that is not possible for reasons that depend on characteristics of the external file.</s>
 <s id="3906">For example, this exception is raised by the procedure CREATE, among other circumstances, if the given mode is OUT_FILE but the form specifies an input only device, if the parameter FORM specifies invalid access rights, or if an external file with the given name already exists and overwriting is not allowed.</s>
 <s id="3907">The exception DEVICE_ERROR is raised if an input-output operation cannot be completed because of a malfunction of the underlying system.</s>
 <s id="3908">The exception END_ERROR is raised by an attempt to skip (read past) the end of a file.</s>
 <s id="3909">The exception DATA_ERROR may be raised by the procedure READ if the element read cannot be interpreted as a value of the required type.</s>
 <s id="3910">This exception is also raised by a procedure GET (defined in the package TEXT_IO) if the input character sequence fails to satisfy the required syntax, or if the value input does not belong to the range of the required type or subtype.</s>
 <s id="3911">The exception LAYOUT_ERROR is raised (in text input-output) by COL, LINE, or PAGE if the value returned exceeds COUNT'LAST.</s>
 <s id="3912">The exception LAYOUT_ERROR is also raised on output by an attempt to set column or line numbers in excess of specified maximum line or page lengths, respectively (excluding the unbounded cases).</s>
 <s id="3913">It is also raised by an attempt to PUT too many characters to a string.</s>
 <s id="3914">This package defines the exceptions needed by the packages SEQUENTIAL_IO, DIRECT_IO, and TEXT_IO.</s>
 <s id="3915">A low level input-output operation is an operation acting on a physical device.</s>
 <s id="3916">Such an operation is handled by using one of the (overloaded) predefined procedures SEND_CONTROL and RECEIVE_CONTROL.</s>
 <s id="3917">A procedure SEND_CONTROL may be used to send control information to a physical device.</s>
 <s id="3918">A procedure RECEIVE_CONTROL may be used to monitor the execution of an input-output operation by requesting information from the physical device.</s>
 <s id="3919">Such procedures are declared in the standard package LOW_LEVEL_IO and have two parameters identifying the device and the data.</s>
 <s id="3920">However, the kinds and formats of the control information will depend on the physical characteristics of the machine and the device.</s>
 <s id="3921">Hence, the types of the parameters are implementation-defined.</s>
 <s id="3922">Overloaded definitions of these procedures should be provided for the supported devices.</s>
 <s id="3923">The visible part of the package defining these procedures is outlined as follows:</s>
 <s id="3924">The bodies of the procedures SEND_CONTROL and RECEIVE_CONTROL for various devices can be supplied in the body of the package LOW_LEVEL_IO.</s>
 <s id="3925">These procedure bodies may be written with code statements.</s>
 <s id="3926">The following example shows the use of some of the text input-output facilities in a dialogue with a user at a terminal.</s>
 <s id="3927">The user is prompted to type a color, and the program responds by giving the number of items of that color available in stock, according to an inventory.</s>
 <s id="3928">The default input and output files are used.</s>
 <s id="3929">For simplicity, all the requisite instantiations are given within one subprogram;</s>
 <s id="3930">in practice, a package, separate from the procedure, would be used.</s>
 <s id="3931">Example of an interaction (characters typed by the user are italicized):</s>
 <s id="3932">For a prefix P that denotes an object, a program unit, a label, or an entry:</s>
 <s id="3933">Yields the address of the first of the storage units allocated to P.</s>
 <s id="3934">For a subprogram, package, task unit, or label, this value refers to the machine code associated with the corresponding body or statement.</s>
 <s id="3935">For an entry for which an address clause has been given, the value refers to the corresponding hardware interrupt.</s>
 <p id="p3936">
  <s id="3936.1">The value of this attribute is of the type ADDRESS defined in the package SYSTEM.</s>
  <s id="3936.2">(See 13.7.2.)</s>
 </p>
 <s id="3937">For a prefix P that denotes a fixed point subtype:</s>
 <s id="3938">Yields the number of decimal digits needed after the point to accommodate the precision of the subtype P, unless the delta of the subtype P is greater than 0.1, in which case the attribute yields the value one.</s>
 <s id="3939">(P'AFT is the smallest positive integer N for which (10**N)*P'DELTA is greater than or equal to one.)</s>
 <p id="p3940">
  <s id="3940.1">The value of this attribute is of the type universal integer.</s>
  <s id="3940.2">(See 3.5.10.)</s>
 </p>
 <s id="3941">For a prefix P that denotes a type or subtype:</s>
 <s id="3942">This attribute denotes the base type of P.</s>
 <p id="p3943">
  <s id="3943.1">It is only allowed as the prefix of the name of another attribute: for example, P'BASE'FIRST.</s>
  <s id="3943.2">(See 3.3.3.)</s>
 </p>
 <s id="3944">For a prefix P that is appropriate for a task type:</s>
 <s id="3945">Yields the value FALSE when the execution of the task P is either completed or terminated, or when the task is abnormal;</s>
 <s id="3946">yields the value TRUE otherwise.</s>
 <p id="p3947">
  <s id="3947.1">The value of this attribute is of the predefined type BOOLEAN.</s>
  <s id="3947.2">(See 9.9.)</s>
 </p>
 <s id="3948">For a prefix P that denotes an object of a type with discriminants:</s>
 <s id="3949">Yields the value TRUE if a discriminant constraint applies to the object P, or if the object is a constant</s>
 <s id="3950">(including a formal parameter or generic formal parameter of mode in);</s>
 <s id="3951">yields the value FALSE otherwise.</s>
 <s id="3952">If P is a generic formal parameter of mode in out, or if P is a formal parameter of mode in out or out and the type mark given in the corresponding parameter specification denotes an unconstrained type with discriminants, then the value of this attribute is obtained from that of the corresponding actual parameter.</s>
 <p id="p3953">
  <s id="3953.1">The value of this attribute is of the predefined type BOOLEAN.</s>
  <s id="3953.2">(See 3.7.4.)</s>
 </p>
 <s id="3954">For a prefix P that denotes a private type or subtype:</s>
 <s id="3955">Yields the value FALSE if P denotes an unconstrained nonformal private type with discriminants; also yields the value FALSE if P denotes a generic formal private type and the associated actual subtype is either an unconstrained type with discriminants or an unconstrained array type;</s>
 <s id="3956">yields the value TRUE otherwise.</s>
 <p id="p3957">
  <s id="3957.1">The value of this attribute is of the predefined type BOOLEAN.</s>
  <s id="3957.2">(See 7.4.2.)</s>
 </p>
 <s id="3958">For a prefix P that denotes an entry of a task unit:</s>
 <s id="3959">Yields the number of entry calls presently queued on the entry (if the attribute is evaluated within an accept statement for the entry P, the count does not include the calling task).</s>
 <p id="p3960">
  <s id="3960.1">The value of this attribute is of the type universal integer.</s>
  <s id="3960.2">(See 9.9.)</s>
 </p>
 <s id="3961">For a prefix P that denotes a fixed point subtype:</s>
 <s id="3962">Yields the value of the delta specified in the fixed accuracy definition for the subtype P.</s>
 <p id="p3963">
  <s id="3963.1">The value of this attribute is of the type universal real.</s>
  <s id="3963.2">(See 3.5.10.)</s>
 </p>
 <s id="3964">For a prefix P that denotes a floating point subtype:</s>
 <s id="3965">Yields the number of decimal digits in the decimal mantissa of model numbers of the subtype P.</s>
 <s id="3966">(This attribute yields the number D of section 3.5.7.)</s>
 <p id="p3967">
  <s id="3967.1">The value of this attribute is of the type universal integer.</s>
  <s id="3967.2">(See 3.5.8.)</s>
 </p>
 <s id="3968">For a prefix P that denotes a floating point subtype:</s>
 <s id="3969">Yields the largest exponent value in the binary canonical form of model numbers of the subtype P.</s>
 <s id="3970">(This attribute yields the product 4*B of section 3.5.7.)</s>
 <p id="p3971">
  <s id="3971.1">The value of this attribute is of the type universal integer.</s>
  <s id="3971.2">(See 3.5.8.)</s>
 </p>
 <s id="3972">For a prefix P that denotes a floating point subtype:</s>
 <s id="3973">Yields the absolute value of the difference between the model number 1.0 and the next model number above, for the subtype P.</s>
 <p id="p3974">
  <s id="3974.1">The value of this attribute is of the type universal real.</s>
  <s id="3974.2">(See 3.5.8.)</s>
 </p>
 <s id="3975">For a prefix P that denotes a scalar type, or a subtype of a scalar type:</s>
 <s id="3976">Yields the lower bound of P.</s>
 <p id="p3977">
  <s id="3977.1">The value of this attribute has the same type as P.</s>
  <s id="3977.2">(See 3.5.)</s>
 </p>
 <s id="3978">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <s id="3979">Yields the lower bound of the first index range.</s>
 <p id="p3980">
  <s id="3980.1">The value of this attribute has the same type as this lower bound.</s>
  <s id="3980.2">(See 3.6.2 and 3.8.2.)</s>
 </p>
 <s id="3981">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <s id="3982">Yields the lower bound of the N-th index range.</s>
 <s id="3983">The value of this attribute has the same type as this lower bound.</s>
 <s id="3984">The argument N must be a static expression of type universal integer.</s>
 <p id="p3985">
  <s id="3985.1">The value of N must be positive (nonzero) and no greater than the dimensionality of the array.</s>
  <s id="3985.2">(See 3.6.2 and 3.8.2.)</s>
 </p>
 <s id="3986">For a prefix P that denotes a component of a record object:</s>
 <s id="3987">Yields the offset, from the start of the first of the storage units occupied by the component, of the first bit occupied by the component.</s>
 <s id="3988">This offset is measured in bits.</s>
 <p id="p3989">
  <s id="3989.1">The value of this attribute is of the type universal integer.</s>
  <s id="3989.2">(See 13.7.2.)</s>
 </p>
 <s id="3990">For a prefix P that denotes a fixed point subtype:</s>
 <s id="3991">Yields the minimum number of characters needed for the integer part of the decimal representation of any value of the subtype P, assuming that the representation does not include an exponent, but includes a one-character prefix that is either a minus sign or a space.</s>
 <s id="3992">(This minimum number does not include superfluous zeros or underlines, and is at least two.)</s>
 <p id="p3993">
  <s id="3993.1">The value of this attribute is of the type universal integer.</s>
  <s id="3993.2">(See 3.5.10.)</s>
 </p>
 <s id="3994">For a prefix P that denotes a discrete type or subtype:</s>
 <s id="3995">This attribute is a function with a single parameter.</s>
 <s id="3996">The actual parameter X must be a value of the base type of P.</s>
 <s id="3997">The result type is the predefined type STRING.</s>
 <s id="3998">The result is the image of the value of X, that is, a sequence of characters representing the value in display form.</s>
 <s id="3999">The image of an integer value is the corresponding decimal literal; without underlines, leading zeros, exponent, or trailing spaces; but with a one character prefix that is either a minus sign or a space.</s>
 <s id="4000">The image of an enumeration value is either the corresponding identifier in upper case or the corresponding character literal (including the two apostrophes); neither leading nor trailing spaces are included.</s>
 <p id="p4001">
  <s id="4001.1">The image of a character other than a graphic character is implementation-defined.</s>
  <s id="4001.2">(See 3.5.5.)</s>
 </p>
 <s id="4002">For a prefix P that denotes a real subtype:</s>
 <s id="4003">The attribute yields the largest positive model number of the subtype P.</s>
 <p id="p4004">
  <s id="4004.1">The value of this attribute is of the type universal real.</s>
  <s id="4004.2">(See 3.5.8 and 3.5.10.)</s>
 </p>
 <s id="4005">For a prefix P that denotes a scalar type, or a subtype of a scalar type:</s>
 <s id="4006">Yields the upper bound of P.</s>
 <p id="p4007">
  <s id="4007.1">The value of this attribute has the same type as P.</s>
  <s id="4007.2">(See 3.5.)</s>
 </p>
 <s id="4008">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <s id="4009">Yields the upper bound of the first index range.</s>
 <p id="p4010">
  <s id="4010.1">The value of this attribute has the same type as this upper bound.</s>
  <s id="4010.2">(See 3.6.2 and 3.8.2.)</s>
 </p>
 <s id="4011">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <s id="4012">Yields the upper bound of the N-th index range.</s>
 <s id="4013">The value of this attribute has the same type as this upper bound.</s>
 <s id="4014">The argument N must be a static expression of type universal integer.</s>
 <p id="p4015">
  <s id="4015.1">The value of N must be positive (nonzero) and no greater than the dimensionality of the array.</s>
  <s id="4015.2">(See 3.6.2 and 3.8.2.)</s>
 </p>
 <s id="4016">For a prefix P that denotes a component of a record object:</s>
 <s id="4017">Yields the offset, from the start of the first of the storage units occupied by the component, of the last bit occupied by the component.</s>
 <s id="4018">This offset is measured in bits.</s>
 <p id="p4019">
  <s id="4019.1">The value of this attribute is of the type universal integer.</s>
  <s id="4019.2">(See 13.7.2.)</s>
 </p>
 <s id="4020">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <s id="4021">Yields the number of values of the first index range (zero for a null range).</s>
 <p id="p4022">
  <s id="4022.1">The value of this attribute is of the type universal integer.</s>
  <s id="4022.2">(See 3.6.2.)</s>
 </p>
 <s id="4023">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <s id="4024">Yields the number of values of the N-th index range (zero for a null range).</s>
 <s id="4025">The value of this attribute is of the type universal integer.</s>
 <s id="4026">The argument N must be a static expression of type universal integer.</s>
 <p id="p4027">
  <s id="4027.1">The value of N must be positive (nonzero) and no greater than the dimensionality of the array.</s>
  <s id="4027.2">(See 3.6.2 and 3.8.2.)</s>
 </p>
 <s id="4028">For a prefix P that denotes a floating point type or subtype:</s>
 <s id="4029">Yields the largest value of exponent for the machine representation of the base type of P.</s>
 <p id="p4030">
  <s id="4030.1">The value of this attribute is of the type universal integer.</s>
  <s id="4030.2">(See 13.7.3.)</s>
 </p>
 <s id="4031">For a prefix P that denotes a floating point type or subtype:</s>
 <s id="4032">Yields the smallest (most negative) value of exponent for the machine representation of the base type of P.</s>
 <p id="p4033">
  <s id="4033.1">The value of this attribute is of the type universal integer.</s>
  <s id="4033.2">(See 13.7.3.)</s>
 </p>
 <s id="4034">For a prefix P that denotes a floating point type or subtype:</s>
 <s id="4035">Yields the number of digits in the mantissa for the machine representation of the base type of P</s>
 <s id="4036">(the digits are extended digits in the range 0 to P'MACHINE_RADIX - 1).</s>
 <p id="p4037">
  <s id="4037.1">The value of this attribute is of the type universal integer.</s>
  <s id="4037.2">(See 13.7.3.)</s>
 </p>
 <s id="4038">For a prefix P that denotes a real type or subtype:</s>
 <s id="4039">Yields the value TRUE if every predefined operation on values of the base type of P either provides a correct result, or raises the exception NUMERIC_ERROR in overflow situations;</s>
 <s id="4040">yields the value FALSE otherwise.</s>
 <p id="p4041">
  <s id="4041.1">The value of this attribute is of the predefined type BOOLEAN.</s>
  <s id="4041.2">(See 13.7.3.)</s>
 </p>
 <s id="4042">For a prefix P that denotes a floating point type or subtype:</s>
 <s id="4043">Yields the value of the radix used by the machine representation of the base type of P.</s>
 <p id="p4044">
  <s id="4044.1">The value of this attribute is of the type universal integer.</s>
  <s id="4044.2">(See 13.7.3.)</s>
 </p>
 <s id="4045">For a prefix P that denotes a real type or subtype:</s>
 <s id="4046">Yields the value TRUE if every predefined arithmetic operation on values of the base type of P either returns an exact result or performs rounding;</s>
 <s id="4047">yields the value FALSE otherwise.</s>
 <p id="p4048">
  <s id="4048.1">The value of this attribute is of the predefined type BOOLEAN.</s>
  <s id="4048.2">(See 13.7.3.)</s>
 </p>
 <s id="4049">For a prefix P that denotes a real subtype:</s>
 <s id="4050">Yields the number of binary digits in the binary mantissa of model numbers of the subtype P.</s>
 <s id="4051">(This attribute yields the number B of section 3.5.7 for a floating point type, or of section 3.5.9 for a fixed point type.)</s>
 <p id="p4052">
  <s id="4052.1">The value of this attribute is of the type universal integer.</s>
  <s id="4052.2">(See 3.5.8 and 3.5.10.)</s>
 </p>
 <s id="4053">For a prefix P that denotes a discrete type or subtype:</s>
 <s id="4054">This attribute is a function with a single parameter.</s>
 <s id="4055">The actual parameter X must be a value of the base type of P.</s>
 <s id="4056">The result type is the type universal integer.</s>
 <p id="p4057">
  <s id="4057.1">The result is the position number of the value of the actual parameter.</s>
  <s id="4057.2">(See 3.5.5.)</s>
 </p>
 <s id="4058">For a prefix P that denotes a component of a record object:</s>
 <s id="4059">Yields the offset, from the start of the first storage unit occupied by the record, of the first of the storage units occupied by the component.</s>
 <s id="4060">This offset is measured in storage units.</s>
 <p id="p4061">
  <s id="4061.1">The value of this attribute is of the type universal integer.</s>
  <s id="4061.2">(See 13.7.2.)</s>
 </p>
 <s id="4062">For a prefix P that denotes a discrete type or subtype:</s>
 <s id="4063">This attribute is a function with a single parameter.</s>
 <s id="4064">The actual parameter X must be a value of the base type of P.</s>
 <s id="4065">The result type is the base type of P.</s>
 <s id="4066">The result is the value whose position number is one less than that of X.</s>
 <p id="p4067">
  <s id="4067.1">The exception CONSTRAINT_ERROR is raised if X equals P'BASE'FIRST.</s>
  <s id="4067.2">(See 3.5.5.)</s>
 </p>
 <s id="4068">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <p id="p4069">
  <s id="4069.1">Yields the first index range of P, that is, the range P'FIRST ..</s>
  <s id="4069.2">P'LAST.</s>
  <s id="4069.3">(See 3.6.2.)</s>
 </p>
 <s id="4070">For a prefix P that is appropriate for an array type, or that denotes a constrained array subtype:</s>
 <p id="p4071">
  <s id="4071.1">Yields the N-th index range of P, that is, the range P'FIRST(N) ..</s>
  <s id="4071.2">P'LAST(N).</s>
  <s id="4071.3">(See 3.6.2.)</s>
 </p>
 <s id="4072">For a prefix P that denotes a floating point type or subtype:</s>
 <s id="4073">Yields the largest exponent value in the binary canonical form of safe numbers of the base type of P.</s>
 <s id="4074">(This attribute yields the number E of section 3.5.7.)</s>
 <p id="p4075">
  <s id="4075.1">The value of this attribute is of the type universal integer.</s>
  <s id="4075.2">(See 3.5.8.)</s>
 </p>
 <s id="4076">For a prefix P that denotes a real type or subtype:</s>
 <s id="4077">Yields the largest positive safe number of the base type of P.</s>
 <p id="p4078">
  <s id="4078.1">The value of this attribute is of the type universal real.</s>
  <s id="4078.2">(See 3.5.8 and 3.5.10.)</s>
 </p>
 <s id="4079">For a prefix P that denotes a real type or subtype:</s>
 <s id="4080">Yields the smallest positive (nonzero) safe number of the base type of P.</s>
 <p id="p4081">
  <s id="4081.1">The value of this attribute is of the type universal real.</s>
  <s id="4081.2">(See 3.5.8 and 3.5.10.)</s>
 </p>
 <s id="4082">For a prefix P that denotes an object:</s>
 <s id="4083">Yields the number of bits allocated to hold the object.</s>
 <p id="p4084">
  <s id="4084.1">The value of this attribute is of the type universal integer.</s>
  <s id="4084.2">(See 13.7.2.)</s>
 </p>
 <s id="4085">For a prefix P that denotes any type or subtype:</s>
 <s id="4086">Yields the minimum number of bits that is needed by the implementation to hold any possible object of the type or subtype P.</s>
 <p id="p4087">
  <s id="4087.1">The value of this attribute is of the type universal integer.</s>
  <s id="4087.2">(See 13.7.2.)</s>
 </p>
 <s id="4088">For a prefix P that denotes a real subtype:</s>
 <s id="4089">Yields the smallest positive (nonzero) model number of the subtype P.</s>
 <p id="p4090">
  <s id="4090.1">The value of this attribute is of the type universal real.</s>
  <s id="4090.2">(See 3.5.8 and 3.5.10.)</s>
 </p>
 <s id="4091">For a prefix P that denotes an access type or subtype:</s>
 <s id="4092">Yields the total number of storage units reserved for the collection associated with the base type of P.</s>
 <p id="p4093">
  <s id="4093.1">The value of this attribute is of the type universal integer.</s>
  <s id="4093.2">(See 13.7.2.)</s>
 </p>
 <s id="4094">For a prefix P that denotes a task type or a task object:</s>
 <s id="4095">Yields the number of storage units reserved for each activation of a task of the type P or for the activation of the task object P.</s>
 <p id="p4096">
  <s id="4096.1">The value of this attribute is of the type universal integer.</s>
  <s id="4096.2">(See 13.7.2.)</s>
 </p>
 <s id="4097">For a prefix P that denotes a discrete type or subtype:</s>
 <s id="4098">This attribute is a function with a single parameter.</s>
 <s id="4099">The actual parameter X must be a value of the base type of P.</s>
 <s id="4100">The result type is the base type of P.</s>
 <s id="4101">The result is the value whose position number is one greater than that of X.</s>
 <p id="p4102">
  <s id="4102.1">The exception CONSTRAINT_ERROR is raised if X equals P'BASE'LAST.</s>
  <s id="4102.2">(See 3.5.5.)</s>
 </p>
 <s id="4103">For a prefix P that is appropriate for a task type:</s>
 <s id="4104">Yields the value TRUE if the task P is terminated; yields the value FALSE otherwise.</s>
 <p id="p4105">
  <s id="4105.1">The value of this attribute is of the predefined type BOOLEAN.</s>
  <s id="4105.2">(See 9.9.)</s>
 </p>
 <s id="4106">For a prefix P that denotes a discrete type or subtype:</s>
 <s id="4107">This attribute is a special function with a single parameter X which can be of any integer type.</s>
 <s id="4108">The result type is the base type of P.</s>
 <s id="4109">The result is the value whose position number is the universal integer value corresponding to X.</s>
 <p id="p4110">
  <s id="4110.1">The exception CONSTRAINT_ERROR is raised if the universal integer value corresponding to X is not in the range P'POS(P'BASE'FIRST) ..</s>
  <s id="4110.2">P'POS(P'BASE'LAST).</s>
  <s id="4110.3">(See 3.5.5.)</s>
 </p>
 <s id="4111">For a prefix P that denotes a discrete type or subtype:</s>
 <s id="4112">This attribute is a function with a single parameter.</s>
 <s id="4113">The actual parameter X must be a value of the predefined type STRING.</s>
 <s id="4114">The result type is the base type of P.</s>
 <s id="4115">Any leading and any trailing spaces of the sequence of characters that corresponds to X are ignored.</s>
 <s id="4116">For an enumeration type, if the sequence of characters has the syntax of an enumeration literal and if this literal exists for the base type of P, the result is the corresponding enumeration value.</s>
 <s id="4117">For an integer type, if the sequence of characters has the syntax of an integer literal, with an optional single leading character that is a plus or minus sign, and if there is a corresponding value in the base type of P, the result is this value.</s>
 <p id="p4118">
  <s id="4118.1">In any other case, the exception CONSTRAINT_ERROR is raised.</s>
  <s id="4118.2">(See 3.5.5.)</s>
 </p>
 <s id="4119">For a prefix P that denotes a discrete subtype:</s>
 <s id="4120">Yields the maximum image length over all values of the subtype P</s>
 <s id="4121">(the image is the sequence of characters returned by the attribute IMAGE).</s>
 <p id="p4122">
  <s id="4122.1">The value of this attribute is of the type universal integer.</s>
  <s id="4122.2">(See 3.5.5.)</s>
 </p>
</text>
